# 1 "GEEM1.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 404 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "GEEM1.cpp" 2
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_accessor.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_accessor.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 1 3
# 10 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_types.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_types.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdint" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdint" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++config.h" 1 3
# 229 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++config.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/os_defines.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 402 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 403 "/usr/include/features.h" 2 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/os_defines.h" 2 3
# 534 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++config.h" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/cpu_defines.h" 1 3
# 537 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++config.h" 2 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdint" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stdint.h" 1 3
# 52 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stdint.h" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_types.hpp" 2 3








namespace __spv {

struct Scope {

  enum Flag : uint32_t {
    CrossDevice = 0,
    Device = 1,
    Workgroup = 2,
    Subgroup = 3,
    Invocation = 4,
  };

  constexpr Scope(Flag flag) : flag_value(flag) {}

  constexpr operator uint32_t() const { return flag_value; }

  Flag flag_value;
};

struct MemorySemanticsMask {

  enum Flag : uint32_t {
    None = 0x0,
    Acquire = 0x2,
    Release = 0x4,
    AcquireRelease = 0x8,
    SequentiallyConsistent = 0x10,
    UniformMemory = 0x40,
    SubgroupMemory = 0x80,
    WorkgroupMemory = 0x100,
    CrossWorkgroupMemory = 0x200,
    AtomicCounterMemory = 0x400,
    ImageMemory = 0x800,
  };

  constexpr MemorySemanticsMask(Flag flag) : flag_value(flag) {}

  constexpr operator uint32_t() const { return flag_value; }

  Flag flag_value;
};

enum class GroupOperation : uint32_t {
  Reduce = 0,
  InclusiveScan = 1,
  ExclusiveScan = 2
};

}
# 97 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_types.hpp" 3
typedef void* __ocl_event_t;
typedef void* __ocl_sampler_t;
# 107 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_types.hpp" 3
typedef void *__ocl_image1d_ro_t; typedef void *__ocl_sampled_image1d_ro_t;
typedef void *__ocl_image2d_ro_t; typedef void *__ocl_sampled_image2d_ro_t;
typedef void *__ocl_image3d_ro_t; typedef void *__ocl_sampled_image3d_ro_t;
typedef void *__ocl_image1d_wo_t;
typedef void *__ocl_image2d_wo_t;
typedef void *__ocl_image3d_wo_t;
typedef void *__ocl_image1d_array_ro_t; typedef void *__ocl_sampled_image1d_array_ro_t;
typedef void *__ocl_image2d_array_ro_t; typedef void *__ocl_sampled_image2d_array_ro_t;
typedef void *__ocl_image1d_array_wo_t;
typedef void *__ocl_image2d_array_wo_t;
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/defines.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/defines.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/defines_elementary.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/defines.hpp" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/climits" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/climits" 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/limits.h" 1 3
# 46 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/limits.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/limits.h" 1 3
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 22 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/limits.h" 2 3
# 47 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/limits.h" 2 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/climits" 2 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/defines.hpp" 2 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/export.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstddef" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstddef" 3







# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3
# 38 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 49 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 3
typedef long unsigned int size_t;
# 105 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/__stddef_max_align_t.h" 1 3
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 106 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 2 3
# 51 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}



namespace std
{



  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };

  template<> struct __byte_operand<wchar_t> { using __type = byte; };

  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };
# 104 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstddef" 3
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = byte(static_cast<unsigned char>(__b) << __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return byte(static_cast<unsigned char>(__b) << __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = byte(static_cast<unsigned char>(__b) >> __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return byte(static_cast<unsigned char>(__b) >> __shift); }

  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  {
    return __l =
      byte(static_cast<unsigned char>(__l) | static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator|(byte __l, byte __r) noexcept
  {
    return
      byte(static_cast<unsigned char>(__l) | static_cast<unsigned char>(__r));
  }

  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  {
   return __l =
     byte(static_cast<unsigned char>(__l) & static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator&(byte __l, byte __r) noexcept
  {
    return
      byte(static_cast<unsigned char>(__l) & static_cast<unsigned char>(__r));
  }

  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  {
    return __l =
      byte(static_cast<unsigned char>(__l) ^ static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator^(byte __l, byte __r) noexcept
  {
    return
      byte(static_cast<unsigned char>(__l) ^ static_cast<unsigned char>(__r));
  }

  constexpr byte
  operator~(byte __b) noexcept
  { return byte(~static_cast<unsigned char>(__b)); }

  template<typename _IntegerType>
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }

}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
namespace std
{
  typedef unsigned short uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{
# 68 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  template<bool __v>
    using bool_constant = integral_constant<bool, __v>;




  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    struct conjunction
    : __and_<_Bn...>
    { };

  template<typename... _Bn>
    struct disjunction
    : __or_<_Bn...>
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>
    { };

  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;
# 192 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 324 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 352 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) const noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) const & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) const && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) const noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) const & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) const && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) volatile noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) volatile & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) volatile && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) volatile noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) volatile & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) volatile && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) const volatile noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) const volatile & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes...) const volatile && noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) const volatile noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) const volatile & noexcept (_NE)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct is_function<_Res(_ArgTypes......) const volatile && noexcept (_NE)>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args , bool _NE>
    struct __is_referenceable<_Res(_Args...) noexcept (_NE)>
    : public true_type
    { };

  template<typename _Res, typename... _Args , bool _NE>
    struct __is_referenceable<_Res(_Args......) noexcept (_NE)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 936 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;

  template<typename _Tp, typename... _Args>
    struct is_constructible;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>,
       __not_<is_constructible<__dst_t, _From>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<wchar_t> : __make_unsigned<int>
    { };
# 1771 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1860 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1890 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2036 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2075 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;



  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2553 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;






  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };





  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    { };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    { };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    { };

  template<typename _Result, typename _Ret, typename = void>
    struct __is_nt_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_nt_invocable_impl<_Result, _Ret,
      __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>,
     __and_<is_convertible<typename _Result::type, _Ret>,
     is_nothrow_constructible<_Ret, typename _Result::type>>>
    { };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    { };


  template<typename _Fn, typename... _Args>
    inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;


  template<typename _Fn, typename... _Args>
    inline constexpr bool is_nothrow_invocable_v
      = is_nothrow_invocable<_Fn, _Args...>::value;


  template<typename _Fn, typename... _Args>
    inline constexpr bool is_invocable_r_v
      = is_invocable_r<_Fn, _Args...>::value;


  template<typename _Fn, typename... _Args>
    inline constexpr bool is_nothrow_invocable_r_v
      = is_nothrow_invocable_r<_Fn, _Args...>::value;




template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_array_v = is_array<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v =
    is_lvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v =
    is_rvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    is_member_object_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    is_member_function_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_enum_v = is_enum<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_union_v = is_union<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_class_v = is_class<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_reference_v = is_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_const_v = is_const<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_volatile_v = is_volatile<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivial_v = is_trivial<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v =
    is_trivially_copyable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_pod_v = is_pod<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_empty_v = is_empty<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_abstract_v = is_abstract<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_final_v = is_final<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v =
    is_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_default_constructible_v =
    is_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v =
    is_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_constructible_v =
    is_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v =
    is_trivially_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v =
    is_trivially_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v =
    is_trivially_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v =
    is_trivially_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v =
    is_trivially_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v =
    is_trivially_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v =
    is_trivially_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v =
    is_nothrow_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v =
    is_nothrow_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v =
    is_nothrow_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v =
    is_nothrow_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v =
    is_nothrow_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v =
    is_nothrow_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v =
    is_nothrow_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v =
    has_virtual_destructor<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t rank_v = rank<_Tp>::value;
template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = is_same<_Tp, _Up>::value;
template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
# 3071 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    { };

  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;
# 3096 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/type_traits" 3
  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> { };


  template<typename _Tp>
    inline constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;






}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 2 3
# 523 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_ops.hpp" 3
template <typename dataT>
                    extern __ocl_event_t
OpGroupAsyncCopyGlobalToLocal(__spv::Scope::Flag, dataT *Dest, dataT *Src,
                              size_t NumElements, size_t Stride,
                              __ocl_event_t) noexcept {
  for (size_t i = 0; i < NumElements; i++) {
    Dest[i] = Src[i * Stride];
  }

  return nullptr;
}

template <typename dataT>
                    extern __ocl_event_t
OpGroupAsyncCopyLocalToGlobal(__spv::Scope::Flag, dataT *Dest, dataT *Src,
                              size_t NumElements, size_t Stride,
                              __ocl_event_t) noexcept {
  for (size_t i = 0; i < NumElements; i++) {
    Dest[i * Stride] = Src[i];
  }

  return nullptr;
}

extern __attribute__((visibility("default"))) void __spirv_ocl_prefetch(const char *Ptr,
                                               size_t NumBytes) noexcept;

                    extern __attribute__((visibility("default"))) void
__spirv_ControlBarrier(__spv::Scope Execution, __spv::Scope Memory,
                       uint32_t Semantics) noexcept;

                    extern __attribute__((visibility("default"))) void
__spirv_MemoryBarrier(__spv::Scope Memory, uint32_t Semantics) noexcept;

                    extern __attribute__((visibility("default"))) void
__spirv_GroupWaitEvents(__spv::Scope Execution, uint32_t NumEvents,
                        __ocl_event_t *WaitEvents) noexcept;
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 1 3
# 10 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 1 3
# 44 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 1 3
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_version.h" 1 3
# 22 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_version.h" 3
#pragma message("cl_version.h: CL_TARGET_OPENCL_VERSION is not defined. Defaulting to 220 (OpenCL 2.2)")
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 1 3
# 23 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
extern "C" {
# 227 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
typedef int8_t cl_char;
typedef uint8_t cl_uchar;
typedef int16_t cl_short;
typedef uint16_t cl_ushort;
typedef int32_t cl_int;
typedef uint32_t cl_uint;
typedef int64_t cl_long;
typedef uint64_t cl_ulong;

typedef uint16_t cl_half;
typedef float cl_float;
typedef double cl_double;
# 333 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3
# 334 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 2 3


typedef unsigned int cl_GLuint;
typedef int cl_GLint;
typedef unsigned int cl_GLenum;
# 381 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
typedef long long __m64 __attribute__((__vector_size__(8), __aligned__(8)));

typedef long long __v1di __attribute__((__vector_size__(8)));
typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));
# 30 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_empty(void)
{
    __builtin_ia32_emms();
}
# 47 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}
# 64 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}
# 80 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}
# 96 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}
# 126 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}
# 156 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}
# 186 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}
# 213 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}
# 236 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}
# 257 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}
# 284 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}
# 307 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}
# 328 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}
# 349 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}
# 370 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}
# 391 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}
# 413 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}
# 436 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}
# 458 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
# 480 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}
# 501 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
# 522 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
# 543 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}
# 566 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}
# 589 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}
# 613 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
# 637 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}
# 664 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}
# 685 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
# 706 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}
# 729 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}
# 751 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}
# 774 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}
# 796 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}
# 816 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq((__v1di)__m, __count);
}
# 836 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi((__v1di)__m, __count);
}
# 860 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}
# 883 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}
# 907 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}
# 930 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}
# 953 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}
# 975 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}
# 998 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}
# 1020 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}
# 1040 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq((__v1di)__m, __count);
}
# 1061 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi((__v1di)__m, __count);
}
# 1079 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand((__v1di)__m1, (__v1di)__m2);
}
# 1100 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn((__v1di)__m1, (__v1di)__m2);
}
# 1118 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por((__v1di)__m1, (__v1di)__m2);
}
# 1136 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor((__v1di)__m1, (__v1di)__m2);
}
# 1158 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}
# 1180 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}
# 1202 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}
# 1224 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}
# 1246 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}
# 1268 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}
# 1281 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setzero_si64(void)
{
    return __extension__ (__m64){ 0LL };
}
# 1302 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}
# 1325 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}
# 1356 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}
# 1377 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}
# 1396 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}
# 1414 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
# 1435 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}
# 1458 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}
# 1489 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx"), __min_vector_width__(64)))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 2 3

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16), __aligned__(16)));

typedef float __m128_u __attribute__((__vector_size__(16), __aligned__(1)));


typedef unsigned int __v4su __attribute__((__vector_size__(16)));





# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mm_malloc.h" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mm_malloc.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdlib.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdlib.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
# 75 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 158 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 250 "/usr/include/stdlib.h" 3 4
extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 272 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 273 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 337 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
 atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
 atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
 atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 195 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

extern unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));



__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int gnu_dev_major (__dev_t __dev) throw () { unsigned int __major; __major = ((__dev & (__dev_t) 0x00000000000fff00u) >> 8); __major |= ((__dev & (__dev_t) 0xfffff00000000000u) >> 32); return __major; }
__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int gnu_dev_minor (__dev_t __dev) throw () { unsigned int __minor; __minor = ((__dev & (__dev_t) 0x00000000000000ffu) >> 0); __minor |= ((__dev & (__dev_t) 0x00000ffffff00000u) >> 12); return __minor; }
__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () { __dev_t __dev; __dev = (((__dev_t) (__major & 0x00000fffu)) << 8); __dev |= (((__dev_t) (__major & 0xfffff000u)) << 32); __dev |= (((__dev_t) (__minor & 0x000000ffu)) << 0); __dev |= (((__dev_t) (__minor & 0xffffff00u)) << 12); return __dev; }



}
# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 246 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;





  short __spins; short __elision;
  __pthread_list_t __list;
# 146 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 823 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
 atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_abs.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_abs.h" 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_abs.h" 3
}
}
# 78 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 2 3
# 121 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mm_malloc.h" 2 3
# 25 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/mm_malloc.h" 3
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}
# 28 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 2 3
# 49 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}
# 69 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a + (__v4sf)__b);
}
# 91 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 112 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a - (__v4sf)__b);
}
# 134 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 154 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a * (__v4sf)__b);
}
# 176 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 195 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4sf)__a / (__v4sf)__b);
}
# 213 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_sqrtss((__v4sf)__a);
}
# 230 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps((__v4sf)__a);
}
# 248 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ss(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpss((__v4sf)__a);
}
# 265 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rcp_ps(__m128 __a)
{
  return (__m128)__builtin_ia32_rcpps((__v4sf)__a);
}
# 284 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ss(__m128 __a)
{
  return __builtin_ia32_rsqrtss((__v4sf)__a);
}
# 301 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps((__v4sf)__a);
}
# 324 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss((__v4sf)__a, (__v4sf)__b);
}
# 343 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps((__v4sf)__a, (__v4sf)__b);
}
# 366 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss((__v4sf)__a, (__v4sf)__b);
}
# 385 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps((__v4sf)__a, (__v4sf)__b);
}
# 403 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a & (__v4su)__b);
}
# 425 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4su)__a & (__v4su)__b);
}
# 443 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a | (__v4su)__b);
}
# 462 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4su)__a ^ (__v4su)__b);
}
# 484 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss((__v4sf)__a, (__v4sf)__b);
}
# 502 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps((__v4sf)__a, (__v4sf)__b);
}
# 525 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss((__v4sf)__a, (__v4sf)__b);
}
# 544 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__a, (__v4sf)__b);
}
# 568 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless((__v4sf)__a, (__v4sf)__b);
}
# 587 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__a, (__v4sf)__b);
}
# 610 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 631 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps((__v4sf)__b, (__v4sf)__a);
}
# 655 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 676 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps((__v4sf)__b, (__v4sf)__a);
}
# 699 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss((__v4sf)__a, (__v4sf)__b);
}
# 718 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps((__v4sf)__a, (__v4sf)__b);
}
# 742 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss((__v4sf)__a, (__v4sf)__b);
}
# 762 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__a, (__v4sf)__b);
}
# 787 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless((__v4sf)__a, (__v4sf)__b);
}
# 807 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__a, (__v4sf)__b);
}
# 832 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnltss((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 854 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps((__v4sf)__b, (__v4sf)__a);
}
# 879 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector((__v4sf)__a,
                                         (__v4sf)__builtin_ia32_cmpnless((__v4sf)__b, (__v4sf)__a),
                                         4, 1, 2, 3);
}
# 901 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps((__v4sf)__b, (__v4sf)__a);
}
# 926 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss((__v4sf)__a, (__v4sf)__b);
}
# 946 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps((__v4sf)__a, (__v4sf)__b);
}
# 971 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss((__v4sf)__a, (__v4sf)__b);
}
# 991 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps((__v4sf)__a, (__v4sf)__b);
}
# 1015 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq((__v4sf)__a, (__v4sf)__b);
}
# 1040 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt((__v4sf)__a, (__v4sf)__b);
}
# 1064 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile((__v4sf)__a, (__v4sf)__b);
}
# 1088 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt((__v4sf)__a, (__v4sf)__b);
}
# 1112 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige((__v4sf)__a, (__v4sf)__b);
}
# 1136 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq((__v4sf)__a, (__v4sf)__b);
}
# 1160 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq((__v4sf)__a, (__v4sf)__b);
}
# 1184 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt((__v4sf)__a, (__v4sf)__b);
}
# 1209 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile((__v4sf)__a, (__v4sf)__b);
}
# 1234 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt((__v4sf)__a, (__v4sf)__b);
}
# 1259 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige((__v4sf)__a, (__v4sf)__b);
}
# 1283 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq((__v4sf)__a, (__v4sf)__b);
}
# 1301 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si((__v4sf)__a);
}
# 1319 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}
# 1339 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64((__v4sf)__a);
}
# 1357 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi((__v4sf)__a);
}
# 1373 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}
# 1392 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si32(__m128 __a)
{
  return __builtin_ia32_cvttss2si((__v4sf)__a);
}
# 1411 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}
# 1431 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvttss_si64(__m128 __a)
{
  return __builtin_ia32_cvttss2si64((__v4sf)__a);
}
# 1450 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi((__v4sf)__a);
}
# 1467 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}
# 1489 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1512 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}
# 1536 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 1562 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps((__v4sf)__a, (__v2si)__b);
}
# 1585 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}
# 1602 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}
# 1623 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((const struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}
# 1650 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((const struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}
# 1677 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load_ss_struct*)__p)->__u;
  return __extension__ (__m128){ __u, 0, 0, 0 };
}
# 1699 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((const struct __mm_load1_ps_struct*)__p)->__u;
  return __extension__ (__m128){ __u, __u, __u, __u };
}
# 1722 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_load_ps(const float *__p)
{
  return *(const __m128*)__p;
}
# 1739 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_ps*)__p)->__v;
}
# 1761 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
}
# 1775 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_undefined_ps(void)
{
  return (__m128)__builtin_ia32_undef128();
}
# 1795 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ss(float __w)
{
  return __extension__ (__m128){ __w, 0, 0, 0 };
}
# 1813 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set1_ps(float __w)
{
  return __extension__ (__m128){ __w, __w, __w, __w };
}
# 1832 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}
# 1859 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __w, __x, __y, __z };
}
# 1887 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return __extension__ (__m128){ __z, __y, __x, __w };
}
# 1902 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_setzero_ps(void)
{
  return __extension__ (__m128){ 0, 0, 0, 0 };
}
# 1919 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 2, 3);
}
# 1940 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  typedef float __mm_storeh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_storeh_pi_struct {
    __mm_storeh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pi_struct*)__p)->__u = __builtin_shufflevector(__a, __a, 0, 1);
}
# 1961 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}
# 1982 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storeu_ps(float *__p, __m128 __a)
{
  struct __storeu_ps {
    __m128_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_ps*)__p)->__v = __a;
}
# 2003 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128*)__p = __a;
}
# 2022 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 0, 0, 0);
  _mm_store_ps(__p, __a);
}
# 2042 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_store_ps1(float *__p, __m128 __a)
{
  _mm_store1_ps(__p, __a);
}
# 2061 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 2119 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}
# 2138 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_nontemporal_store((__v4sf)__a, (__v4sf*)__p);
}


extern "C" {
# 2157 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
void _mm_sfence(void);


}
# 2230 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}
# 2249 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}
# 2268 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}
# 2287 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}
# 2305 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}
# 2324 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}
# 2387 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}
# 2406 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}
# 2425 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}
# 2447 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}


extern "C" {
# 2507 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
unsigned int _mm_getcsr(void);
# 2561 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
void _mm_setcsr(unsigned int __i);


}
# 2623 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 2, 6, 3, 7);
}
# 2645 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 4, 1, 5);
}
# 2667 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_move_ss(__m128 __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 2689 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 6, 7, 2, 3);
}
# 2710 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector((__v4sf)__a, (__v4sf)__b, 0, 1, 4, 5);
}
# 2728 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 2758 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}
# 2787 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 2812 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}
# 2839 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}
# 2868 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}
# 2898 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse"), __min_vector_width__(64)))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}
# 2923 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse"), __min_vector_width__(128)))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps((__v4sf)__a);
}
# 3005 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 2 3

typedef double __m128d __attribute__((__vector_size__(16), __aligned__(16)));
typedef long long __m128i __attribute__((__vector_size__(16), __aligned__(16)));

typedef double __m128d_u __attribute__((__vector_size__(16), __aligned__(1)));
typedef long long __m128i_u __attribute__((__vector_size__(16), __aligned__(1)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));


typedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));
typedef unsigned short __v8hu __attribute__((__vector_size__(16)));
typedef unsigned char __v16qu __attribute__((__vector_size__(16)));



typedef signed char __v16qs __attribute__((__vector_size__(16)));
# 55 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}
# 74 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a + (__v2df)__b);
}
# 97 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}
# 116 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a - (__v2df)__b);
}
# 138 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}
# 157 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a * (__v2df)__b);
}
# 180 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}
# 200 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2df)__a / (__v2df)__b);
}
# 225 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd((__v2df)__b);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 243 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd((__v2df)__a);
}
# 267 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd((__v2df)__a, (__v2df)__b);
}
# 287 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd((__v2df)__a, (__v2df)__b);
}
# 311 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd((__v2df)__a, (__v2df)__b);
}
# 331 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd((__v2df)__a, (__v2df)__b);
}
# 349 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a & (__v2du)__b);
}
# 370 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v2du)__a & (__v2du)__b);
}
# 388 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a | (__v2du)__b);
}
# 406 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v2du)__a ^ (__v2du)__b);
}
# 425 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqpd((__v2df)__a, (__v2df)__b);
}
# 445 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__a, (__v2df)__b);
}
# 466 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__a, (__v2df)__b);
}
# 487 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd((__v2df)__b, (__v2df)__a);
}
# 508 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd((__v2df)__b, (__v2df)__a);
}
# 531 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordpd((__v2df)__a, (__v2df)__b);
}
# 555 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordpd((__v2df)__a, (__v2df)__b);
}
# 576 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqpd((__v2df)__a, (__v2df)__b);
}
# 597 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__a, (__v2df)__b);
}
# 618 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__a, (__v2df)__b);
}
# 639 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd((__v2df)__b, (__v2df)__a);
}
# 660 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd((__v2df)__b, (__v2df)__a);
}
# 683 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqsd((__v2df)__a, (__v2df)__b);
}
# 708 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltsd((__v2df)__a, (__v2df)__b);
}
# 733 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplesd((__v2df)__a, (__v2df)__b);
}
# 758 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpltsd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 784 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmplesd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 812 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordsd((__v2df)__a, (__v2df)__b);
}
# 840 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordsd((__v2df)__a, (__v2df)__b);
}
# 865 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqsd((__v2df)__a, (__v2df)__b);
}
# 890 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltsd((__v2df)__a, (__v2df)__b);
}
# 915 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlesd((__v2df)__a, (__v2df)__b);
}
# 940 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnltsd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 966 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnlesd((__v2df)__b, (__v2df)__a);
  return __extension__ (__m128d) { __c[0], __a[1] };
}
# 991 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq((__v2df)__a, (__v2df)__b);
}
# 1017 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt((__v2df)__a, (__v2df)__b);
}
# 1043 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle((__v2df)__a, (__v2df)__b);
}
# 1069 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt((__v2df)__a, (__v2df)__b);
}
# 1095 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge((__v2df)__a, (__v2df)__b);
}
# 1121 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq((__v2df)__a, (__v2df)__b);
}
# 1145 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq((__v2df)__a, (__v2df)__b);
}
# 1171 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt((__v2df)__a, (__v2df)__b);
}
# 1197 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle((__v2df)__a, (__v2df)__b);
}
# 1223 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt((__v2df)__a, (__v2df)__b);
}
# 1249 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge((__v2df)__a, (__v2df)__b);
}
# 1275 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq((__v2df)__a, (__v2df)__b);
}
# 1294 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps((__v2df)__a);
}
# 1314 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtps_pd(__m128 __a)
{
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4sf)__a, (__v4sf)__a, 0, 1), __v2df);
}
# 1337 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtepi32_pd(__m128i __a)
{
  return (__m128d) __builtin_convertvector(
      __builtin_shufflevector((__v4si)__a, (__v4si)__a, 0, 1), __v2df);
}
# 1357 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq((__v2df)__a);
}
# 1374 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si((__v2df)__a);
}
# 1399 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  return (__m128)__builtin_ia32_cvtsd2ss((__v4sf)__a, (__v2df)__b);
}
# 1422 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}
# 1448 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}
# 1472 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq((__v2df)__a);
}
# 1490 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttsd_si32(__m128d __a)
{
  return __builtin_ia32_cvttsd2si((__v2df)__a);
}
# 1507 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi((__v2df)__a);
}
# 1527 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi((__v2df)__a);
}
# 1544 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}
# 1561 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}
# 1578 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_pd(double const *__dp)
{
  return *(const __m128d*)__dp;
}
# 1596 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load1_pd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __u, __u };
}
# 1622 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(const __m128d*)__dp;
  return __builtin_shufflevector((__v2df)__u, (__v2df)__u, 1, 0);
}
# 1640 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_pd*)__dp)->__v;
}
# 1660 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si64(void const *__a)
{
  struct __loadu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  long long __u = ((const struct __loadu_si64*)__a)->__v;
  return __extension__ (__m128i)(__v2di){__u, 0LL};
}
# 1681 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si32(void const *__a)
{
  struct __loadu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  int __u = ((const struct __loadu_si32*)__a)->__v;
  return __extension__ (__m128i)(__v4si){__u, 0, 0, 0};
}
# 1702 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si16(void const *__a)
{
  struct __loadu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  short __u = ((const struct __loadu_si16*)__a)->__v;
  return __extension__ (__m128i)(__v8hi){__u, 0, 0, 0, 0, 0, 0, 0};
}
# 1723 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_load_sd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __u, 0 };
}
# 1750 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadh_pd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __a[0], __u };
}
# 1777 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((const struct __mm_loadl_pd_struct*)__dp)->__u;
  return __extension__ (__m128d){ __u, __a[1] };
}
# 1798 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_undefined_pd(void)
{
  return (__m128d)__builtin_ia32_undef128();
}
# 1818 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_sd(double __w)
{
  return __extension__ (__m128d){ __w, 0 };
}
# 1836 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_pd(double __w)
{
  return __extension__ (__m128d){ __w, __w };
}
# 1854 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_pd1(double __w)
{
  return _mm_set1_pd(__w);
}
# 1874 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_pd(double __w, double __x)
{
  return __extension__ (__m128d){ __x, __w };
}
# 1895 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_pd(double __w, double __x)
{
  return __extension__ (__m128d){ __w, __x };
}
# 1910 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setzero_pd(void)
{
  return __extension__ (__m128d){ 0, 0 };
}
# 1931 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_move_sd(__m128d __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}
# 1949 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}
# 1971 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d*)__dp = __a;
}
# 1991 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store1_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 0, 0);
  _mm_store_pd(__dp, __a);
}
# 2012 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_pd1(double *__dp, __m128d __a)
{
  _mm_store1_pd(__dp, __a);
}
# 2030 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  struct __storeu_pd {
    __m128d_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_pd*)__dp)->__v = __a;
}
# 2053 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector((__v2df)__a, (__v2df)__a, 1, 0);
  *(__m128d *)__dp = __a;
}
# 2071 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}
# 2091 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}
# 2116 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qu)__a + (__v16qu)__b);
}
# 2138 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a + (__v8hu)__b);
}
# 2160 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4su)__a + (__v4su)__b);
}
# 2178 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_paddq((__v1di)__a, (__v1di)__b);
}
# 2200 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a + (__v2du)__b);
}
# 2221 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}
# 2243 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}
# 2264 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}
# 2285 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}
# 2305 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}
# 2325 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}
# 2351 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}
# 2371 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}
# 2391 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}
# 2411 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}
# 2431 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}
# 2451 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}
# 2471 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}
# 2491 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a * (__v8hu)__b);
}
# 2510 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}
# 2529 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}
# 2551 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}
# 2569 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qu)__a - (__v16qu)__b);
}
# 2587 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hu)__a - (__v8hu)__b);
}
# 2605 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4su)__a - (__v4su)__b);
}
# 2624 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx,sse2"), __min_vector_width__(64)))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psubq((__v1di)__a, (__v1di)__b);
}
# 2642 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a - (__v2du)__b);
}
# 2663 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}
# 2684 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}
# 2704 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}
# 2724 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}
# 2742 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a & (__v2du)__b);
}
# 2762 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return (__m128i)(~(__v2du)__a & (__v2du)__b);
}
# 2779 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a | (__v2du)__b);
}
# 2797 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return (__m128i)((__v2du)__a ^ (__v2du)__b);
}
# 2839 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}
# 2858 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}
# 2877 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}
# 2896 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}
# 2915 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128((__v2di)__a, __count);
}
# 2934 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128((__v2di)__a, (__v2di)__count);
}
# 2954 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}
# 2974 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}
# 2994 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}
# 3014 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 3056 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}
# 3075 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}
# 3094 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}
# 3113 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}
# 3132 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128((__v2di)__a, __count);
}
# 3151 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128((__v2di)__a, (__v2di)__count);
}
# 3170 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}
# 3189 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}
# 3208 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}
# 3228 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}
# 3251 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}
# 3272 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}
# 3293 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}
# 3314 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}
# 3335 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}
# 3359 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}
# 3377 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64((__v2df)__a);
}
# 3395 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttsd_si64(__m128d __a)
{
  return __builtin_ia32_cvttsd2si64((__v2df)__a);
}
# 3411 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtepi32_ps(__m128i __a)
{
  return (__m128)__builtin_convertvector((__v4si)__a, __v4sf);
}
# 3427 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq((__v4sf)__a);
}
# 3444 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq((__v4sf)__a);
}
# 3460 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi32_si128(int __a)
{
  return __extension__ (__m128i)(__v4si){ __a, 0, 0, 0 };
}
# 3477 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi64_si128(long long __a)
{
  return __extension__ (__m128i)(__v2di){ __a, 0 };
}
# 3495 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}
# 3514 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}
# 3531 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}
# 3547 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadu_si128(__m128i_u const *__p)
{
  struct __loadu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  return ((const struct __loadu_si128*)__p)->__v;
}
# 3568 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_loadl_epi64(__m128i_u const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return __extension__ (__m128i) { ((const struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}
# 3586 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_undefined_si128(void)
{
  return (__m128i)__builtin_ia32_undef128();
}
# 3608 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi64x(long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}
# 3630 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi64(__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x((long long)__q1, (long long)__q0);
}
# 3658 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi32(int __i3, int __i2, int __i1, int __i0)
{
  return __extension__ (__m128i)(__v4si){ __i0, __i1, __i2, __i3};
}
# 3698 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3, short __w2, short __w1, short __w0)
{
  return __extension__ (__m128i)(__v8hi){ __w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7 };
}
# 3746 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11, char __b10, char __b9, char __b8, char __b7, char __b6, char __b5, char __b4, char __b3, char __b2, char __b1, char __b0)
{
  return __extension__ (__m128i)(__v16qi){ __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7, __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15 };
}
# 3765 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi64x(long long __q)
{
  return _mm_set_epi64x(__q, __q);
}
# 3784 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi64(__m64 __q)
{
  return _mm_set_epi64(__q, __q);
}
# 3803 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi32(int __i)
{
  return _mm_set_epi32(__i, __i, __i, __i);
}
# 3822 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi16(short __w)
{
  return _mm_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w);
}
# 3841 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_set1_epi8(char __b)
{
  return _mm_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b);
}
# 3861 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi64(__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64(__q1, __q0);
}
# 3884 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi32(int __i0, int __i1, int __i2, int __i3)
{
  return _mm_set_epi32(__i3, __i2, __i1, __i0);
}
# 3915 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4, short __w5, short __w6, short __w7)
{
  return _mm_set_epi16(__w7, __w6, __w5, __w4, __w3, __w2, __w1, __w0);
}
# 3962 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5, char __b6, char __b7, char __b8, char __b9, char __b10, char __b11, char __b12, char __b13, char __b14, char __b15)
{
  return _mm_set_epi8(__b15, __b14, __b13, __b12, __b11, __b10, __b9, __b8, __b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 3976 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_setzero_si128(void)
{
  return __extension__ (__m128i)(__v2di){ 0LL, 0LL };
}
# 3994 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}
# 4010 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si128(__m128i_u *__p, __m128i __b)
{
  struct __storeu_si128 {
    __m128i_u __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si128*)__p)->__v = __b;
}
# 4031 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si64(void *__p, __m128i __b)
{
  struct __storeu_si64 {
    long long __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si64*)__p)->__v = ((__v2di)__b)[0];
}
# 4052 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si32(void *__p, __m128i __b)
{
  struct __storeu_si32 {
    int __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si32*)__p)->__v = ((__v4si)__b)[0];
}
# 4073 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storeu_si16(void *__p, __m128i __b)
{
  struct __storeu_si16 {
    short __v;
  } __attribute__((__packed__, __may_alias__));
  ((struct __storeu_si16*)__p)->__v = ((__v8hi)__b)[0];
}
# 4103 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}
# 4122 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_storel_epi64(__m128i_u *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}
# 4145 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_nontemporal_store((__v2df)__a, (__v2df*)__p);
}
# 4164 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_nontemporal_store((__v2di)__a, (__v2di*)__p);
}
# 4183 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}
# 4203 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}



extern "C" {
# 4224 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
void _mm_clflush(void const * __p);
# 4235 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
void _mm_lfence(void);
# 4246 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
void _mm_mfence(void);


}
# 4274 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}
# 4302 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}
# 4330 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}
# 4398 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 4524 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}
# 4551 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}
# 4574 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}
# 4595 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 1, 2+1);
}
# 4630 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}
# 4658 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}
# 4681 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}
# 4702 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v2di)__a, (__v2di)__b, 0, 2+0);
}
# 4719 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}
# 4736 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movpi64_epi64(__m64 __a)
{
  return __extension__ (__m128i)(__v2di){ (long long)__a, 0 };
}
# 4754 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector((__v2di)__a, _mm_setzero_si128(), 0, 2);
}
# 4775 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 1, 2+1);
}
# 4796 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector((__v2df)__a, (__v2df)__b, 0, 2+0);
}
# 4815 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd((__v2df)__a);
}
# 4861 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}
# 4878 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}
# 4895 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}
# 4912 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}
# 4929 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}
# 4946 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2"), __min_vector_width__(128)))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}


extern "C" {
# 4963 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/emmintrin.h" 3
void _mm_pause(void);


}
# 3006 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/xmmintrin.h" 2 3
# 382 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 2 3


        typedef float __cl_float4 __attribute__((vector_size(16)));
# 398 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
        typedef cl_uchar __cl_uchar16 __attribute__((vector_size(16)));
        typedef cl_char __cl_char16 __attribute__((vector_size(16)));
        typedef cl_ushort __cl_ushort8 __attribute__((vector_size(16)));
        typedef cl_short __cl_short8 __attribute__((vector_size(16)));
        typedef cl_uint __cl_uint4 __attribute__((vector_size(16)));
        typedef cl_int __cl_int4 __attribute__((vector_size(16)));
        typedef cl_ulong __cl_ulong2 __attribute__((vector_size(16)));
        typedef cl_long __cl_long2 __attribute__((vector_size(16)));
        typedef cl_double __cl_double2 __attribute__((vector_size(16)));
# 432 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
        typedef cl_uchar __cl_uchar8 __attribute__((vector_size(8)));
        typedef cl_char __cl_char8 __attribute__((vector_size(8)));
        typedef cl_ushort __cl_ushort4 __attribute__((vector_size(8)));
        typedef cl_short __cl_short4 __attribute__((vector_size(8)));
        typedef cl_uint __cl_uint2 __attribute__((vector_size(8)));
        typedef cl_int __cl_int2 __attribute__((vector_size(8)));
        typedef cl_ulong __cl_ulong1 __attribute__((vector_size(8)));
        typedef cl_long __cl_long1 __attribute__((vector_size(8)));
        typedef cl_float __cl_float2 __attribute__((vector_size(8)));
# 528 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
typedef union
{
    cl_char __attribute__ ((aligned(2))) s[2];
# 539 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_char2;

typedef union
{
    cl_char __attribute__ ((aligned(4))) s[4];
# 555 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_char4;


typedef cl_char4 cl_char3;

typedef union
{
    cl_char __attribute__ ((aligned(8))) s[8];
# 575 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_char8 v8;

}cl_char8;

typedef union
{
    cl_char __attribute__ ((aligned(16))) s[16];
# 594 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_char8 v8[2];


    __cl_char16 v16;

}cl_char16;



typedef union
{
    cl_uchar __attribute__ ((aligned(2))) s[2];
# 614 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_uchar2;

typedef union
{
    cl_uchar __attribute__ ((aligned(4))) s[4];
# 630 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_uchar4;


typedef cl_uchar4 cl_uchar3;

typedef union
{
    cl_uchar __attribute__ ((aligned(8))) s[8];
# 650 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_uchar8 v8;

}cl_uchar8;

typedef union
{
    cl_uchar __attribute__ ((aligned(16))) s[16];
# 669 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_uchar8 v8[2];


    __cl_uchar16 v16;

}cl_uchar16;



typedef union
{
    cl_short __attribute__ ((aligned(4))) s[2];
# 689 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_short2;

typedef union
{
    cl_short __attribute__ ((aligned(8))) s[4];
# 703 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_short4 v4;

}cl_short4;


typedef cl_short4 cl_short3;

typedef union
{
    cl_short __attribute__ ((aligned(16))) s[8];
# 722 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_short4 v4[2];


    __cl_short8 v8;

}cl_short8;

typedef union
{
    cl_short __attribute__ ((aligned(32))) s[16];
# 741 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_short4 v4[4];


    __cl_short8 v8[2];




}cl_short16;



typedef union
{
    cl_ushort __attribute__ ((aligned(4))) s[2];
# 764 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_ushort2;

typedef union
{
    cl_ushort __attribute__ ((aligned(8))) s[4];
# 778 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_ushort4 v4;

}cl_ushort4;


typedef cl_ushort4 cl_ushort3;

typedef union
{
    cl_ushort __attribute__ ((aligned(16))) s[8];
# 797 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_ushort4 v4[2];


    __cl_ushort8 v8;

}cl_ushort8;

typedef union
{
    cl_ushort __attribute__ ((aligned(32))) s[16];
# 816 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
    __cl_ushort4 v4[4];


    __cl_ushort8 v8[2];




}cl_ushort16;



typedef union
{
    cl_half __attribute__ ((aligned(4))) s[2];
# 839 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_half2;

typedef union
{
    cl_half __attribute__ ((aligned(8))) s[4];
# 855 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_half4;


typedef cl_half4 cl_half3;

typedef union
{
    cl_half __attribute__ ((aligned(16))) s[8];
# 877 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_half8;

typedef union
{
    cl_half __attribute__ ((aligned(32))) s[16];
# 899 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_half16;


typedef union
{
    cl_int __attribute__ ((aligned(8))) s[2];






    __cl_int2 v2;

}cl_int2;

typedef union
{
    cl_int __attribute__ ((aligned(16))) s[4];






    __cl_int2 v2[2];


    __cl_int4 v4;

}cl_int4;


typedef cl_int4 cl_int3;

typedef union
{
    cl_int __attribute__ ((aligned(32))) s[8];






    __cl_int2 v2[4];


    __cl_int4 v4[2];




}cl_int8;

typedef union
{
    cl_int __attribute__ ((aligned(64))) s[16];






    __cl_int2 v2[8];


    __cl_int4 v4[4];







}cl_int16;



typedef union
{
    cl_uint __attribute__ ((aligned(8))) s[2];






    __cl_uint2 v2;

}cl_uint2;

typedef union
{
    cl_uint __attribute__ ((aligned(16))) s[4];






    __cl_uint2 v2[2];


    __cl_uint4 v4;

}cl_uint4;


typedef cl_uint4 cl_uint3;

typedef union
{
    cl_uint __attribute__ ((aligned(32))) s[8];






    __cl_uint2 v2[4];


    __cl_uint4 v4[2];




}cl_uint8;

typedef union
{
    cl_uint __attribute__ ((aligned(64))) s[16];






    __cl_uint2 v2[8];


    __cl_uint4 v4[4];







}cl_uint16;


typedef union
{
    cl_long __attribute__ ((aligned(16))) s[2];






    __cl_long2 v2;

}cl_long2;

typedef union
{
    cl_long __attribute__ ((aligned(32))) s[4];






    __cl_long2 v2[2];




}cl_long4;


typedef cl_long4 cl_long3;

typedef union
{
    cl_long __attribute__ ((aligned(64))) s[8];






    __cl_long2 v2[4];







}cl_long8;

typedef union
{
    cl_long __attribute__ ((aligned(128))) s[16];






    __cl_long2 v2[8];
# 1122 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_long16;



typedef union
{
    cl_ulong __attribute__ ((aligned(16))) s[2];






    __cl_ulong2 v2;

}cl_ulong2;

typedef union
{
    cl_ulong __attribute__ ((aligned(32))) s[4];






    __cl_ulong2 v2[2];




}cl_ulong4;


typedef cl_ulong4 cl_ulong3;

typedef union
{
    cl_ulong __attribute__ ((aligned(64))) s[8];






    __cl_ulong2 v2[4];







}cl_ulong8;

typedef union
{
    cl_ulong __attribute__ ((aligned(128))) s[16];






    __cl_ulong2 v2[8];
# 1197 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_ulong16;




typedef union
{
    cl_float __attribute__ ((aligned(8))) s[2];






    __cl_float2 v2;

}cl_float2;

typedef union
{
    cl_float __attribute__ ((aligned(16))) s[4];






    __cl_float2 v2[2];


    __cl_float4 v4;

}cl_float4;


typedef cl_float4 cl_float3;

typedef union
{
    cl_float __attribute__ ((aligned(32))) s[8];






    __cl_float2 v2[4];


    __cl_float4 v4[2];




}cl_float8;

typedef union
{
    cl_float __attribute__ ((aligned(64))) s[16];






    __cl_float2 v2[8];


    __cl_float4 v4[4];







}cl_float16;



typedef union
{
    cl_double __attribute__ ((aligned(16))) s[2];






    __cl_double2 v2;

}cl_double2;

typedef union
{
    cl_double __attribute__ ((aligned(32))) s[4];






    __cl_double2 v2[2];




}cl_double4;


typedef cl_double4 cl_double3;

typedef union
{
    cl_double __attribute__ ((aligned(64))) s[8];






    __cl_double2 v2[4];







}cl_double8;

typedef union
{
    cl_double __attribute__ ((aligned(128))) s[16];






    __cl_double2 v2[8];
# 1348 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}cl_double16;
# 1375 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_platform.h" 3
}
# 22 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 2 3


extern "C" {




typedef struct _cl_platform_id * cl_platform_id;
typedef struct _cl_device_id * cl_device_id;
typedef struct _cl_context * cl_context;
typedef struct _cl_command_queue * cl_command_queue;
typedef struct _cl_mem * cl_mem;
typedef struct _cl_program * cl_program;
typedef struct _cl_kernel * cl_kernel;
typedef struct _cl_event * cl_event;
typedef struct _cl_sampler * cl_sampler;

typedef cl_uint cl_bool;
typedef cl_ulong cl_bitfield;
typedef cl_ulong cl_properties;
typedef cl_bitfield cl_device_type;
typedef cl_uint cl_platform_info;
typedef cl_uint cl_device_info;
typedef cl_bitfield cl_device_fp_config;
typedef cl_uint cl_device_mem_cache_type;
typedef cl_uint cl_device_local_mem_type;
typedef cl_bitfield cl_device_exec_capabilities;

typedef cl_bitfield cl_device_svm_capabilities;

typedef cl_bitfield cl_command_queue_properties;

typedef intptr_t cl_device_partition_property;
typedef cl_bitfield cl_device_affinity_domain;


typedef intptr_t cl_context_properties;
typedef cl_uint cl_context_info;

typedef cl_properties cl_queue_properties;

typedef cl_uint cl_command_queue_info;
typedef cl_uint cl_channel_order;
typedef cl_uint cl_channel_type;
typedef cl_bitfield cl_mem_flags;

typedef cl_bitfield cl_svm_mem_flags;

typedef cl_uint cl_mem_object_type;
typedef cl_uint cl_mem_info;

typedef cl_bitfield cl_mem_migration_flags;

typedef cl_uint cl_image_info;

typedef cl_uint cl_buffer_create_type;

typedef cl_uint cl_addressing_mode;
typedef cl_uint cl_filter_mode;
typedef cl_uint cl_sampler_info;
typedef cl_bitfield cl_map_flags;

typedef intptr_t cl_pipe_properties;
typedef cl_uint cl_pipe_info;

typedef cl_uint cl_program_info;
typedef cl_uint cl_program_build_info;

typedef cl_uint cl_program_binary_type;

typedef cl_int cl_build_status;
typedef cl_uint cl_kernel_info;

typedef cl_uint cl_kernel_arg_info;
typedef cl_uint cl_kernel_arg_address_qualifier;
typedef cl_uint cl_kernel_arg_access_qualifier;
typedef cl_bitfield cl_kernel_arg_type_qualifier;

typedef cl_uint cl_kernel_work_group_info;

typedef cl_uint cl_kernel_sub_group_info;

typedef cl_uint cl_event_info;
typedef cl_uint cl_command_type;
typedef cl_uint cl_profiling_info;

typedef cl_properties cl_sampler_properties;
typedef cl_uint cl_kernel_exec_info;
# 119 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
typedef struct _cl_image_format {
    cl_channel_order image_channel_order;
    cl_channel_type image_channel_data_type;
} cl_image_format;



typedef struct _cl_image_desc {
    cl_mem_object_type image_type;
    size_t image_width;
    size_t image_height;
    size_t image_depth;
    size_t image_array_size;
    size_t image_row_pitch;
    size_t image_slice_pitch;
    cl_uint num_mip_levels;
    cl_uint num_samples;


    __extension__





    union {

      cl_mem buffer;

      cl_mem mem_object;
    };




} cl_image_desc;





typedef struct _cl_buffer_region {
    size_t origin;
    size_t size;
} cl_buffer_region;
# 938 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
extern cl_int
clGetPlatformIDs(cl_uint num_entries,
                 cl_platform_id * platforms,
                 cl_uint * num_platforms) ;

extern cl_int
clGetPlatformInfo(cl_platform_id platform,
                  cl_platform_info param_name,
                  size_t param_value_size,
                  void * param_value,
                  size_t * param_value_size_ret) ;


extern cl_int
clGetDeviceIDs(cl_platform_id platform,
               cl_device_type device_type,
               cl_uint num_entries,
               cl_device_id * devices,
               cl_uint * num_devices) ;

extern cl_int
clGetDeviceInfo(cl_device_id device,
                cl_device_info param_name,
                size_t param_value_size,
                void * param_value,
                size_t * param_value_size_ret) ;



extern cl_int
clCreateSubDevices(cl_device_id in_device,
                   const cl_device_partition_property * properties,
                   cl_uint num_devices,
                   cl_device_id * out_devices,
                   cl_uint * num_devices_ret) ;

extern cl_int
clRetainDevice(cl_device_id device) ;

extern cl_int
clReleaseDevice(cl_device_id device) ;





extern cl_int
clSetDefaultDeviceCommandQueue(cl_context context,
                               cl_device_id device,
                               cl_command_queue command_queue) ;

extern cl_int
clGetDeviceAndHostTimer(cl_device_id device,
                        cl_ulong* device_timestamp,
                        cl_ulong* host_timestamp) ;

extern cl_int
clGetHostTimer(cl_device_id device,
               cl_ulong * host_timestamp) ;




extern cl_context
clCreateContext(const cl_context_properties * properties,
                cl_uint num_devices,
                const cl_device_id * devices,
                void ( * pfn_notify)(const char * errinfo,
                                                const void * private_info,
                                                size_t cb,
                                                void * user_data),
                void * user_data,
                cl_int * errcode_ret) ;

extern cl_context
clCreateContextFromType(const cl_context_properties * properties,
                        cl_device_type device_type,
                        void ( * pfn_notify)(const char * errinfo,
                                                        const void * private_info,
                                                        size_t cb,
                                                        void * user_data),
                        void * user_data,
                        cl_int * errcode_ret) ;

extern cl_int
clRetainContext(cl_context context) ;

extern cl_int
clReleaseContext(cl_context context) ;

extern cl_int
clGetContextInfo(cl_context context,
                 cl_context_info param_name,
                 size_t param_value_size,
                 void * param_value,
                 size_t * param_value_size_ret) ;
# 1049 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
extern cl_command_queue
clCreateCommandQueueWithProperties(cl_context context,
                                   cl_device_id device,
                                   const cl_queue_properties * properties,
                                   cl_int * errcode_ret) ;



extern cl_int
clRetainCommandQueue(cl_command_queue command_queue) ;

extern cl_int
clReleaseCommandQueue(cl_command_queue command_queue) ;

extern cl_int
clGetCommandQueueInfo(cl_command_queue command_queue,
                      cl_command_queue_info param_name,
                      size_t param_value_size,
                      void * param_value,
                      size_t * param_value_size_ret) ;


extern cl_mem
clCreateBuffer(cl_context context,
               cl_mem_flags flags,
               size_t size,
               void * host_ptr,
               cl_int * errcode_ret) ;



extern cl_mem
clCreateSubBuffer(cl_mem buffer,
                  cl_mem_flags flags,
                  cl_buffer_create_type buffer_create_type,
                  const void * buffer_create_info,
                  cl_int * errcode_ret) ;





extern cl_mem
clCreateImage(cl_context context,
              cl_mem_flags flags,
              const cl_image_format * image_format,
              const cl_image_desc * image_desc,
              void * host_ptr,
              cl_int * errcode_ret) ;





extern cl_mem
clCreatePipe(cl_context context,
             cl_mem_flags flags,
             cl_uint pipe_packet_size,
             cl_uint pipe_max_packets,
             const cl_pipe_properties * properties,
             cl_int * errcode_ret) ;
# 1134 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
extern cl_int
clRetainMemObject(cl_mem memobj) ;

extern cl_int
clReleaseMemObject(cl_mem memobj) ;

extern cl_int
clGetSupportedImageFormats(cl_context context,
                           cl_mem_flags flags,
                           cl_mem_object_type image_type,
                           cl_uint num_entries,
                           cl_image_format * image_formats,
                           cl_uint * num_image_formats) ;

extern cl_int
clGetMemObjectInfo(cl_mem memobj,
                   cl_mem_info param_name,
                   size_t param_value_size,
                   void * param_value,
                   size_t * param_value_size_ret) ;

extern cl_int
clGetImageInfo(cl_mem image,
               cl_image_info param_name,
               size_t param_value_size,
               void * param_value,
               size_t * param_value_size_ret) ;



extern cl_int
clGetPipeInfo(cl_mem pipe,
              cl_pipe_info param_name,
              size_t param_value_size,
              void * param_value,
              size_t * param_value_size_ret) ;





extern cl_int
clSetMemObjectDestructorCallback(cl_mem memobj,
                                 void ( * pfn_notify)(cl_mem memobj,
                                                                 void * user_data),
                                 void * user_data) ;







extern void *
clSVMAlloc(cl_context context,
           cl_svm_mem_flags flags,
           size_t size,
           cl_uint alignment) ;

extern void
clSVMFree(cl_context context,
          void * svm_pointer) ;







extern cl_sampler
clCreateSamplerWithProperties(cl_context context,
                              const cl_sampler_properties * sampler_properties,
                              cl_int * errcode_ret) ;



extern cl_int
clRetainSampler(cl_sampler sampler) ;

extern cl_int
clReleaseSampler(cl_sampler sampler) ;

extern cl_int
clGetSamplerInfo(cl_sampler sampler,
                 cl_sampler_info param_name,
                 size_t param_value_size,
                 void * param_value,
                 size_t * param_value_size_ret) ;


extern cl_program
clCreateProgramWithSource(cl_context context,
                          cl_uint count,
                          const char ** strings,
                          const size_t * lengths,
                          cl_int * errcode_ret) ;

extern cl_program
clCreateProgramWithBinary(cl_context context,
                          cl_uint num_devices,
                          const cl_device_id * device_list,
                          const size_t * lengths,
                          const unsigned char ** binaries,
                          cl_int * binary_status,
                          cl_int * errcode_ret) ;



extern cl_program
clCreateProgramWithBuiltInKernels(cl_context context,
                                  cl_uint num_devices,
                                  const cl_device_id * device_list,
                                  const char * kernel_names,
                                  cl_int * errcode_ret) ;





extern cl_program
clCreateProgramWithIL(cl_context context,
                     const void* il,
                     size_t length,
                     cl_int* errcode_ret) ;



extern cl_int
clRetainProgram(cl_program program) ;

extern cl_int
clReleaseProgram(cl_program program) ;

extern cl_int
clBuildProgram(cl_program program,
               cl_uint num_devices,
               const cl_device_id * device_list,
               const char * options,
               void ( * pfn_notify)(cl_program program,
                                                void * user_data),
               void * user_data) ;



extern cl_int
clCompileProgram(cl_program program,
                 cl_uint num_devices,
                 const cl_device_id * device_list,
                 const char * options,
                 cl_uint num_input_headers,
                 const cl_program * input_headers,
                 const char ** header_include_names,
                 void ( * pfn_notify)(cl_program program,
                                                  void * user_data),
                 void * user_data) ;

extern cl_program
clLinkProgram(cl_context context,
              cl_uint num_devices,
              const cl_device_id * device_list,
              const char * options,
              cl_uint num_input_programs,
              const cl_program * input_programs,
              void ( * pfn_notify)(cl_program program,
                                               void * user_data),
              void * user_data,
              cl_int * errcode_ret) ;





extern cl_int
clSetProgramReleaseCallback(cl_program program,
                            void ( * pfn_notify)(cl_program program,
                                                            void * user_data),
                            void * user_data) ;

extern cl_int
clSetProgramSpecializationConstant(cl_program program,
                                   cl_uint spec_id,
                                   size_t spec_size,
                                   const void* spec_value) ;





extern cl_int
clUnloadPlatformCompiler(cl_platform_id platform) ;



extern cl_int
clGetProgramInfo(cl_program program,
                 cl_program_info param_name,
                 size_t param_value_size,
                 void * param_value,
                 size_t * param_value_size_ret) ;

extern cl_int
clGetProgramBuildInfo(cl_program program,
                      cl_device_id device,
                      cl_program_build_info param_name,
                      size_t param_value_size,
                      void * param_value,
                      size_t * param_value_size_ret) ;


extern cl_kernel
clCreateKernel(cl_program program,
               const char * kernel_name,
               cl_int * errcode_ret) ;

extern cl_int
clCreateKernelsInProgram(cl_program program,
                         cl_uint num_kernels,
                         cl_kernel * kernels,
                         cl_uint * num_kernels_ret) ;



extern cl_kernel
clCloneKernel(cl_kernel source_kernel,
              cl_int* errcode_ret) ;



extern cl_int
clRetainKernel(cl_kernel kernel) ;

extern cl_int
clReleaseKernel(cl_kernel kernel) ;

extern cl_int
clSetKernelArg(cl_kernel kernel,
               cl_uint arg_index,
               size_t arg_size,
               const void * arg_value) ;



extern cl_int
clSetKernelArgSVMPointer(cl_kernel kernel,
                         cl_uint arg_index,
                         const void * arg_value) ;

extern cl_int
clSetKernelExecInfo(cl_kernel kernel,
                    cl_kernel_exec_info param_name,
                    size_t param_value_size,
                    const void * param_value) ;



extern cl_int
clGetKernelInfo(cl_kernel kernel,
                cl_kernel_info param_name,
                size_t param_value_size,
                void * param_value,
                size_t * param_value_size_ret) ;



extern cl_int
clGetKernelArgInfo(cl_kernel kernel,
                   cl_uint arg_indx,
                   cl_kernel_arg_info param_name,
                   size_t param_value_size,
                   void * param_value,
                   size_t * param_value_size_ret) ;



extern cl_int
clGetKernelWorkGroupInfo(cl_kernel kernel,
                         cl_device_id device,
                         cl_kernel_work_group_info param_name,
                         size_t param_value_size,
                         void * param_value,
                         size_t * param_value_size_ret) ;



extern cl_int
clGetKernelSubGroupInfo(cl_kernel kernel,
                        cl_device_id device,
                        cl_kernel_sub_group_info param_name,
                        size_t input_value_size,
                        const void* input_value,
                        size_t param_value_size,
                        void* param_value,
                        size_t* param_value_size_ret) ;




extern cl_int
clWaitForEvents(cl_uint num_events,
                const cl_event * event_list) ;

extern cl_int
clGetEventInfo(cl_event event,
               cl_event_info param_name,
               size_t param_value_size,
               void * param_value,
               size_t * param_value_size_ret) ;



extern cl_event
clCreateUserEvent(cl_context context,
                  cl_int * errcode_ret) ;



extern cl_int
clRetainEvent(cl_event event) ;

extern cl_int
clReleaseEvent(cl_event event) ;



extern cl_int
clSetUserEventStatus(cl_event event,
                     cl_int execution_status) ;

extern cl_int
clSetEventCallback(cl_event event,
                   cl_int command_exec_callback_type,
                   void ( * pfn_notify)(cl_event event,
                                                   cl_int event_command_status,
                                                   void * user_data),
                   void * user_data) ;




extern cl_int
clGetEventProfilingInfo(cl_event event,
                        cl_profiling_info param_name,
                        size_t param_value_size,
                        void * param_value,
                        size_t * param_value_size_ret) ;


extern cl_int
clFlush(cl_command_queue command_queue) ;

extern cl_int
clFinish(cl_command_queue command_queue) ;


extern cl_int
clEnqueueReadBuffer(cl_command_queue command_queue,
                    cl_mem buffer,
                    cl_bool blocking_read,
                    size_t offset,
                    size_t size,
                    void * ptr,
                    cl_uint num_events_in_wait_list,
                    const cl_event * event_wait_list,
                    cl_event * event) ;



extern cl_int
clEnqueueReadBufferRect(cl_command_queue command_queue,
                        cl_mem buffer,
                        cl_bool blocking_read,
                        const size_t * buffer_offset,
                        const size_t * host_offset,
                        const size_t * region,
                        size_t buffer_row_pitch,
                        size_t buffer_slice_pitch,
                        size_t host_row_pitch,
                        size_t host_slice_pitch,
                        void * ptr,
                        cl_uint num_events_in_wait_list,
                        const cl_event * event_wait_list,
                        cl_event * event) ;



extern cl_int
clEnqueueWriteBuffer(cl_command_queue command_queue,
                     cl_mem buffer,
                     cl_bool blocking_write,
                     size_t offset,
                     size_t size,
                     const void * ptr,
                     cl_uint num_events_in_wait_list,
                     const cl_event * event_wait_list,
                     cl_event * event) ;



extern cl_int
clEnqueueWriteBufferRect(cl_command_queue command_queue,
                         cl_mem buffer,
                         cl_bool blocking_write,
                         const size_t * buffer_offset,
                         const size_t * host_offset,
                         const size_t * region,
                         size_t buffer_row_pitch,
                         size_t buffer_slice_pitch,
                         size_t host_row_pitch,
                         size_t host_slice_pitch,
                         const void * ptr,
                         cl_uint num_events_in_wait_list,
                         const cl_event * event_wait_list,
                         cl_event * event) ;





extern cl_int
clEnqueueFillBuffer(cl_command_queue command_queue,
                    cl_mem buffer,
                    const void * pattern,
                    size_t pattern_size,
                    size_t offset,
                    size_t size,
                    cl_uint num_events_in_wait_list,
                    const cl_event * event_wait_list,
                    cl_event * event) ;



extern cl_int
clEnqueueCopyBuffer(cl_command_queue command_queue,
                    cl_mem src_buffer,
                    cl_mem dst_buffer,
                    size_t src_offset,
                    size_t dst_offset,
                    size_t size,
                    cl_uint num_events_in_wait_list,
                    const cl_event * event_wait_list,
                    cl_event * event) ;



extern cl_int
clEnqueueCopyBufferRect(cl_command_queue command_queue,
                        cl_mem src_buffer,
                        cl_mem dst_buffer,
                        const size_t * src_origin,
                        const size_t * dst_origin,
                        const size_t * region,
                        size_t src_row_pitch,
                        size_t src_slice_pitch,
                        size_t dst_row_pitch,
                        size_t dst_slice_pitch,
                        cl_uint num_events_in_wait_list,
                        const cl_event * event_wait_list,
                        cl_event * event) ;



extern cl_int
clEnqueueReadImage(cl_command_queue command_queue,
                   cl_mem image,
                   cl_bool blocking_read,
                   const size_t * origin,
                   const size_t * region,
                   size_t row_pitch,
                   size_t slice_pitch,
                   void * ptr,
                   cl_uint num_events_in_wait_list,
                   const cl_event * event_wait_list,
                   cl_event * event) ;

extern cl_int
clEnqueueWriteImage(cl_command_queue command_queue,
                    cl_mem image,
                    cl_bool blocking_write,
                    const size_t * origin,
                    const size_t * region,
                    size_t input_row_pitch,
                    size_t input_slice_pitch,
                    const void * ptr,
                    cl_uint num_events_in_wait_list,
                    const cl_event * event_wait_list,
                    cl_event * event) ;



extern cl_int
clEnqueueFillImage(cl_command_queue command_queue,
                   cl_mem image,
                   const void * fill_color,
                   const size_t * origin,
                   const size_t * region,
                   cl_uint num_events_in_wait_list,
                   const cl_event * event_wait_list,
                   cl_event * event) ;



extern cl_int
clEnqueueCopyImage(cl_command_queue command_queue,
                   cl_mem src_image,
                   cl_mem dst_image,
                   const size_t * src_origin,
                   const size_t * dst_origin,
                   const size_t * region,
                   cl_uint num_events_in_wait_list,
                   const cl_event * event_wait_list,
                   cl_event * event) ;

extern cl_int
clEnqueueCopyImageToBuffer(cl_command_queue command_queue,
                           cl_mem src_image,
                           cl_mem dst_buffer,
                           const size_t * src_origin,
                           const size_t * region,
                           size_t dst_offset,
                           cl_uint num_events_in_wait_list,
                           const cl_event * event_wait_list,
                           cl_event * event) ;

extern cl_int
clEnqueueCopyBufferToImage(cl_command_queue command_queue,
                           cl_mem src_buffer,
                           cl_mem dst_image,
                           size_t src_offset,
                           const size_t * dst_origin,
                           const size_t * region,
                           cl_uint num_events_in_wait_list,
                           const cl_event * event_wait_list,
                           cl_event * event) ;

extern void *
clEnqueueMapBuffer(cl_command_queue command_queue,
                   cl_mem buffer,
                   cl_bool blocking_map,
                   cl_map_flags map_flags,
                   size_t offset,
                   size_t size,
                   cl_uint num_events_in_wait_list,
                   const cl_event * event_wait_list,
                   cl_event * event,
                   cl_int * errcode_ret) ;

extern void *
clEnqueueMapImage(cl_command_queue command_queue,
                  cl_mem image,
                  cl_bool blocking_map,
                  cl_map_flags map_flags,
                  const size_t * origin,
                  const size_t * region,
                  size_t * image_row_pitch,
                  size_t * image_slice_pitch,
                  cl_uint num_events_in_wait_list,
                  const cl_event * event_wait_list,
                  cl_event * event,
                  cl_int * errcode_ret) ;

extern cl_int
clEnqueueUnmapMemObject(cl_command_queue command_queue,
                        cl_mem memobj,
                        void * mapped_ptr,
                        cl_uint num_events_in_wait_list,
                        const cl_event * event_wait_list,
                        cl_event * event) ;



extern cl_int
clEnqueueMigrateMemObjects(cl_command_queue command_queue,
                           cl_uint num_mem_objects,
                           const cl_mem * mem_objects,
                           cl_mem_migration_flags flags,
                           cl_uint num_events_in_wait_list,
                           const cl_event * event_wait_list,
                           cl_event * event) ;



extern cl_int
clEnqueueNDRangeKernel(cl_command_queue command_queue,
                       cl_kernel kernel,
                       cl_uint work_dim,
                       const size_t * global_work_offset,
                       const size_t * global_work_size,
                       const size_t * local_work_size,
                       cl_uint num_events_in_wait_list,
                       const cl_event * event_wait_list,
                       cl_event * event) ;

extern cl_int
clEnqueueNativeKernel(cl_command_queue command_queue,
                      void ( * user_func)(void *),
                      void * args,
                      size_t cb_args,
                      cl_uint num_mem_objects,
                      const cl_mem * mem_list,
                      const void ** args_mem_loc,
                      cl_uint num_events_in_wait_list,
                      const cl_event * event_wait_list,
                      cl_event * event) ;



extern cl_int
clEnqueueMarkerWithWaitList(cl_command_queue command_queue,
                            cl_uint num_events_in_wait_list,
                            const cl_event * event_wait_list,
                            cl_event * event) ;

extern cl_int
clEnqueueBarrierWithWaitList(cl_command_queue command_queue,
                             cl_uint num_events_in_wait_list,
                             const cl_event * event_wait_list,
                             cl_event * event) ;





extern cl_int
clEnqueueSVMFree(cl_command_queue command_queue,
                 cl_uint num_svm_pointers,
                 void * svm_pointers[],
                 void ( * pfn_free_func)(cl_command_queue queue,
                                                    cl_uint num_svm_pointers,
                                                    void * svm_pointers[],
                                                    void * user_data),
                 void * user_data,
                 cl_uint num_events_in_wait_list,
                 const cl_event * event_wait_list,
                 cl_event * event) ;

extern cl_int
clEnqueueSVMMemcpy(cl_command_queue command_queue,
                   cl_bool blocking_copy,
                   void * dst_ptr,
                   const void * src_ptr,
                   size_t size,
                   cl_uint num_events_in_wait_list,
                   const cl_event * event_wait_list,
                   cl_event * event) ;

extern cl_int
clEnqueueSVMMemFill(cl_command_queue command_queue,
                    void * svm_ptr,
                    const void * pattern,
                    size_t pattern_size,
                    size_t size,
                    cl_uint num_events_in_wait_list,
                    const cl_event * event_wait_list,
                    cl_event * event) ;

extern cl_int
clEnqueueSVMMap(cl_command_queue command_queue,
                cl_bool blocking_map,
                cl_map_flags flags,
                void * svm_ptr,
                size_t size,
                cl_uint num_events_in_wait_list,
                const cl_event * event_wait_list,
                cl_event * event) ;

extern cl_int
clEnqueueSVMUnmap(cl_command_queue command_queue,
                  void * svm_ptr,
                  cl_uint num_events_in_wait_list,
                  const cl_event * event_wait_list,
                  cl_event * event) ;





extern cl_int
clEnqueueSVMMigrateMem(cl_command_queue command_queue,
                       cl_uint num_svm_pointers,
                       const void ** svm_pointers,
                       const size_t * sizes,
                       cl_mem_migration_flags flags,
                       cl_uint num_events_in_wait_list,
                       const cl_event * event_wait_list,
                       cl_event * event) ;
# 1831 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
extern void *
clGetExtensionFunctionAddressForPlatform(cl_platform_id platform,
                                         const char * func_name) ;
# 1856 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl.h" 3
extern cl_mem
clCreateImage2D(cl_context context,
                cl_mem_flags flags,
                const cl_image_format * image_format,
                size_t image_width,
                size_t image_height,
                size_t image_row_pitch,
                void * host_ptr,
                cl_int * errcode_ret) __attribute__((deprecated));

extern cl_mem
clCreateImage3D(cl_context context,
                cl_mem_flags flags,
                const cl_image_format * image_format,
                size_t image_width,
                size_t image_height,
                size_t image_depth,
                size_t image_row_pitch,
                size_t image_slice_pitch,
                void * host_ptr,
                cl_int * errcode_ret) __attribute__((deprecated));

extern cl_int
clEnqueueMarker(cl_command_queue command_queue,
                cl_event * event) __attribute__((deprecated));

extern cl_int
clEnqueueWaitForEvents(cl_command_queue command_queue,
                        cl_uint num_events,
                        const cl_event * event_list) __attribute__((deprecated));

extern cl_int
clEnqueueBarrier(cl_command_queue command_queue) __attribute__((deprecated));

extern cl_int
clUnloadCompiler(void) __attribute__((deprecated));

extern void *
clGetExtensionFunctionAddress(const char * func_name) __attribute__((deprecated));


extern cl_command_queue
clCreateCommandQueue(cl_context context,
                     cl_device_id device,
                     cl_command_queue_properties properties,
                     cl_int * errcode_ret) __attribute__((deprecated));

extern cl_sampler
clCreateSampler(cl_context context,
                cl_bool normalized_coords,
                cl_addressing_mode addressing_mode,
                cl_filter_mode filter_mode,
                cl_int * errcode_ret) __attribute__((deprecated));

extern cl_int
clEnqueueTask(cl_command_queue command_queue,
              cl_kernel kernel,
              cl_uint num_events_in_wait_list,
              const cl_event * event_wait_list,
              cl_event * event) __attribute__((deprecated));


}
# 45 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 2 3



extern "C" {
# 78 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
typedef struct _cl_accelerator_intel* cl_accelerator_intel;
typedef cl_uint cl_accelerator_type_intel;
typedef cl_uint cl_accelerator_info_intel;

typedef struct _cl_motion_estimation_desc_intel {
    cl_uint mb_block_type;
    cl_uint subpixel_mode;
    cl_uint sad_adjust_mode;
    cl_uint search_path_type;
} cl_motion_estimation_desc_intel;
# 169 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
extern cl_accelerator_intel
clCreateAcceleratorINTEL(
    cl_context context,
    cl_accelerator_type_intel accelerator_type,
    size_t descriptor_size,
    const void* descriptor,
    cl_int* errcode_ret) ;

typedef cl_accelerator_intel ( *clCreateAcceleratorINTEL_fn)(
    cl_context context,
    cl_accelerator_type_intel accelerator_type,
    size_t descriptor_size,
    const void* descriptor,
    cl_int* errcode_ret) ;

extern cl_int
clGetAcceleratorInfoINTEL(
    cl_accelerator_intel accelerator,
    cl_accelerator_info_intel param_name,
    size_t param_value_size,
    void* param_value,
    size_t* param_value_size_ret) ;

typedef cl_int ( *clGetAcceleratorInfoINTEL_fn)(
    cl_accelerator_intel accelerator,
    cl_accelerator_info_intel param_name,
    size_t param_value_size,
    void* param_value,
    size_t* param_value_size_ret) ;

extern cl_int
clRetainAcceleratorINTEL(
    cl_accelerator_intel accelerator) ;

typedef cl_int ( *clRetainAcceleratorINTEL_fn)(
    cl_accelerator_intel accelerator) ;

extern cl_int
clReleaseAcceleratorINTEL(
    cl_accelerator_intel accelerator) ;

typedef cl_int ( *clReleaseAcceleratorINTEL_fn)(
    cl_accelerator_intel accelerator) ;
# 257 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
typedef cl_uint cl_diagnostics_verbose_level;
# 423 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
typedef cl_bitfield cl_device_unified_shared_memory_capabilities_intel;







typedef cl_properties cl_mem_properties_intel;




typedef cl_bitfield cl_mem_alloc_flags_intel;




typedef cl_uint cl_mem_info_intel;
# 450 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
typedef cl_uint cl_unified_shared_memory_type_intel;







typedef cl_uint cl_mem_advice_intel;
# 475 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
extern void*
clHostMemAllocINTEL(
            cl_context context,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

typedef void* ( *
clHostMemAllocINTEL_fn)(
            cl_context context,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

extern void*
clDeviceMemAllocINTEL(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

typedef void* ( *
clDeviceMemAllocINTEL_fn)(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

extern void*
clSharedMemAllocINTEL(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

typedef void* ( *
clSharedMemAllocINTEL_fn)(
            cl_context context,
            cl_device_id device,
            const cl_mem_properties_intel* properties,
            size_t size,
            cl_uint alignment,
            cl_int* errcode_ret);

extern cl_int
clMemFreeINTEL(
            cl_context context,
            void* ptr);

typedef cl_int ( *
clMemFreeINTEL_fn)(
            cl_context context,
            void* ptr);

extern cl_int
clGetMemAllocInfoINTEL(
            cl_context context,
            const void* ptr,
            cl_mem_info_intel param_name,
            size_t param_value_size,
            void* param_value,
            size_t* param_value_size_ret);

typedef cl_int ( *
clGetMemAllocInfoINTEL_fn)(
            cl_context context,
            const void* ptr,
            cl_mem_info_intel param_name,
            size_t param_value_size,
            void* param_value,
            size_t* param_value_size_ret);

extern cl_int
clSetKernelArgMemPointerINTEL(
            cl_kernel kernel,
            cl_uint arg_index,
            const void* arg_value);

typedef cl_int ( *
clSetKernelArgMemPointerINTEL_fn)(
            cl_kernel kernel,
            cl_uint arg_index,
            const void* arg_value);

extern cl_int
clEnqueueMemsetINTEL(
            cl_command_queue command_queue,
            void* dst_ptr,
            cl_int value,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

typedef cl_int ( *
clEnqueueMemsetINTEL_fn)(
            cl_command_queue command_queue,
            void* dst_ptr,
            cl_int value,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

extern cl_int
clEnqueueMemFillINTEL(
            cl_command_queue command_queue,
            void* dst_ptr,
            const void* pattern,
            size_t pattern_size,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

typedef cl_int ( *
clEnqueueMemFillINTEL_fn)(
            cl_command_queue command_queue,
            void* dst_ptr,
            const void* pattern,
            size_t pattern_size,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

extern cl_int
clEnqueueMemcpyINTEL(
            cl_command_queue command_queue,
            cl_bool blocking,
            void* dst_ptr,
            const void* src_ptr,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

typedef cl_int ( *
clEnqueueMemcpyINTEL_fn)(
            cl_command_queue command_queue,
            cl_bool blocking,
            void* dst_ptr,
            const void* src_ptr,
            size_t size,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);






extern cl_int
clEnqueueMigrateMemINTEL(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_migration_flags flags,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

typedef cl_int ( *
clEnqueueMigrateMemINTEL_fn)(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_migration_flags flags,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);



extern cl_int
clEnqueueMemAdviseINTEL(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_advice_intel advice,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);

typedef cl_int ( *
clEnqueueMemAdviseINTEL_fn)(
            cl_command_queue command_queue,
            const void* ptr,
            size_t size,
            cl_mem_advice_intel advice,
            cl_uint num_events_in_wait_list,
            const cl_event* event_wait_list,
            cl_event* event);







extern cl_mem
clCreateBufferWithPropertiesINTEL(
    cl_context context,
    const cl_mem_properties_intel* properties,
    cl_mem_flags flags,
    size_t size,
    void * host_ptr,
    cl_int * errcode_ret) ;

typedef cl_mem ( *
clCreateBufferWithPropertiesINTEL_fn)(
    cl_context context,
    const cl_mem_properties_intel* properties,
    cl_mem_flags flags,
    size_t size,
    void * host_ptr,
    cl_int * errcode_ret) ;
# 709 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext_intel.h" 3
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cl.h" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cl.h" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 1 3
# 24 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern "C" {
# 57 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
cl_int clSetMemObjectDestructorAPPLE( cl_mem memobj,
                                        void (* pfn_notify)(cl_mem memobj, void * user_data),
                                        void * user_data) ;
# 71 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern void clLogMessagesToSystemLogAPPLE( const char * errstr,
                                            const void * private_info,
                                            size_t cb,
                                            void * user_data) ;


extern void clLogMessagesToStdoutAPPLE( const char * errstr,
                                          const void * private_info,
                                          size_t cb,
                                          void * user_data) ;


extern void clLogMessagesToStderrAPPLE( const char * errstr,
                                          const void * private_info,
                                          size_t cb,
                                          void * user_data) ;
# 100 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_int
clIcdGetPlatformIDsKHR(cl_uint num_entries,
                       cl_platform_id * platforms,
                       cl_uint * num_platforms);

typedef cl_int
( *clIcdGetPlatformIDsKHR_fn)(cl_uint num_entries,
                                         cl_platform_id * platforms,
                                         cl_uint * num_platforms);
# 126 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_program
clCreateProgramWithILKHR(cl_context context,
                         const void * il,
                         size_t length,
                         cl_int * errcode_ret);

typedef cl_program
( *clCreateProgramWithILKHR_fn)(cl_context context,
                                           const void * il,
                                           size_t length,
                                           cl_int * errcode_ret) ;
# 178 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_int
clTerminateContextKHR(cl_context context) ;

typedef cl_int
( *clTerminateContextKHR_fn)(cl_context context) ;
# 201 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_properties cl_queue_properties_khr;

extern cl_command_queue
clCreateCommandQueueWithPropertiesKHR(cl_context context,
                                      cl_device_id device,
                                      const cl_queue_properties_khr* properties,
                                      cl_int* errcode_ret) ;

typedef cl_command_queue
( *clCreateCommandQueueWithPropertiesKHR_fn)(cl_context context,
                                                        cl_device_id device,
                                                        const cl_queue_properties_khr* properties,
                                                        cl_int* errcode_ret) ;
# 270 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_int
clReleaseDeviceEXT(cl_device_id device) ;

typedef cl_int
( *clReleaseDeviceEXT_fn)(cl_device_id device) ;

extern cl_int
clRetainDeviceEXT(cl_device_id device) ;

typedef cl_int
( *clRetainDeviceEXT_fn)(cl_device_id device) ;

typedef cl_ulong cl_device_partition_property_ext;
extern cl_int
clCreateSubDevicesEXT(cl_device_id in_device,
                      const cl_device_partition_property_ext * properties,
                      cl_uint num_entries,
                      cl_device_id * out_devices,
                      cl_uint * num_devices) ;

typedef cl_int
( * clCreateSubDevicesEXT_fn)(cl_device_id in_device,
                                         const cl_device_partition_property_ext * properties,
                                         cl_uint num_entries,
                                         cl_device_id * out_devices,
                                         cl_uint * num_devices) ;
# 334 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_bitfield cl_mem_migration_flags_ext;





extern cl_int
clEnqueueMigrateMemObjectEXT(cl_command_queue command_queue,
                             cl_uint num_mem_objects,
                             const cl_mem * mem_objects,
                             cl_mem_migration_flags_ext flags,
                             cl_uint num_events_in_wait_list,
                             const cl_event * event_wait_list,
                             cl_event * event);

typedef cl_int
( *clEnqueueMigrateMemObjectEXT_fn)(cl_command_queue command_queue,
                                               cl_uint num_mem_objects,
                                               const cl_mem * mem_objects,
                                               cl_mem_migration_flags_ext flags,
                                               cl_uint num_events_in_wait_list,
                                               const cl_event * event_wait_list,
                                               cl_event * event);
# 375 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_uint cl_image_pitch_info_qcom;

extern cl_int
clGetDeviceImageInfoQCOM(cl_device_id device,
                         size_t image_width,
                         size_t image_height,
                         const cl_image_format *image_format,
                         cl_image_pitch_info_qcom param_name,
                         size_t param_value_size,
                         void *param_value,
                         size_t *param_value_size_ret);

typedef struct _cl_mem_ext_host_ptr
{


    cl_uint allocation_type;


    cl_uint host_cache_policy;

} cl_mem_ext_host_ptr;
# 413 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef struct _cl_mem_ion_host_ptr
{


    cl_mem_ext_host_ptr ext_host_ptr;


    int ion_filedesc;


    void* ion_hostptr;

} cl_mem_ion_host_ptr;
# 434 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef struct _cl_mem_android_native_buffer_host_ptr
{


    cl_mem_ext_host_ptr ext_host_ptr;


    void* anb_ptr;

} cl_mem_android_native_buffer_host_ptr;
# 479 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_int
clEnqueueAcquireGrallocObjectsIMG(cl_command_queue command_queue,
                                  cl_uint num_objects,
                                  const cl_mem * mem_objects,
                                  cl_uint num_events_in_wait_list,
                                  const cl_event * event_wait_list,
                                  cl_event * event) ;

extern cl_int
clEnqueueReleaseGrallocObjectsIMG(cl_command_queue command_queue,
                                  cl_uint num_objects,
                                  const cl_mem * mem_objects,
                                  cl_uint num_events_in_wait_list,
                                  const cl_event * event_wait_list,
                                  cl_event * event) ;
# 513 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_int
clGetKernelSubGroupInfoKHR(cl_kernel in_kernel,
                           cl_device_id in_device,
                           cl_kernel_sub_group_info param_name,
                           size_t input_value_size,
                           const void * input_value,
                           size_t param_value_size,
                           void * param_value,
                           size_t * param_value_size_ret) __attribute__((deprecated));

typedef cl_int
( * clGetKernelSubGroupInfoKHR_fn)(cl_kernel in_kernel,
                                              cl_device_id in_device,
                                              cl_kernel_sub_group_info param_name,
                                              size_t input_value_size,
                                              const void * input_value,
                                              size_t param_value_size,
                                              void * param_value,
                                              size_t * param_value_size_ret) __attribute__((deprecated));
# 551 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_uint cl_queue_priority_khr;
# 569 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_uint cl_queue_throttle_khr;
# 614 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_uint cl_version_khr;



typedef struct _cl_name_version_khr
{
    cl_version_khr version;
    char name[64];
} cl_name_version_khr;
# 656 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef intptr_t cl_import_properties_arm;
# 695 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
extern cl_mem
clImportMemoryARM( cl_context context,
                   cl_mem_flags flags,
                   const cl_import_properties_arm *properties,
                   void *memory,
                   size_t size,
                   cl_int *errcode_ret) ;
# 736 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
typedef cl_bitfield cl_svm_mem_flags_arm;
typedef cl_uint cl_kernel_exec_info_arm;
typedef cl_bitfield cl_device_svm_capabilities_arm;

extern void *
clSVMAllocARM(cl_context context,
              cl_svm_mem_flags_arm flags,
              size_t size,
              cl_uint alignment) ;

extern void
clSVMFreeARM(cl_context context,
             void * svm_pointer) ;

extern cl_int
clEnqueueSVMFreeARM(cl_command_queue command_queue,
                    cl_uint num_svm_pointers,
                    void * svm_pointers[],
                    void ( * pfn_free_func)(cl_command_queue queue,
                                                       cl_uint num_svm_pointers,
                                                       void * svm_pointers[],
                                                       void * user_data),
                    void * user_data,
                    cl_uint num_events_in_wait_list,
                    const cl_event * event_wait_list,
                    cl_event * event) ;

extern cl_int
clEnqueueSVMMemcpyARM(cl_command_queue command_queue,
                      cl_bool blocking_copy,
                      void * dst_ptr,
                      const void * src_ptr,
                      size_t size,
                      cl_uint num_events_in_wait_list,
                      const cl_event * event_wait_list,
                      cl_event * event) ;

extern cl_int
clEnqueueSVMMemFillARM(cl_command_queue command_queue,
                       void * svm_ptr,
                       const void * pattern,
                       size_t pattern_size,
                       size_t size,
                       cl_uint num_events_in_wait_list,
                       const cl_event * event_wait_list,
                       cl_event * event) ;

extern cl_int
clEnqueueSVMMapARM(cl_command_queue command_queue,
                   cl_bool blocking_map,
                   cl_map_flags flags,
                   void * svm_ptr,
                   size_t size,
                   cl_uint num_events_in_wait_list,
                   const cl_event * event_wait_list,
                   cl_event * event) ;

extern cl_int
clEnqueueSVMUnmapARM(cl_command_queue command_queue,
                     void * svm_ptr,
                     cl_uint num_events_in_wait_list,
                     const cl_event * event_wait_list,
                     cl_event * event) ;

extern cl_int
clSetKernelArgSVMPointerARM(cl_kernel kernel,
                            cl_uint arg_index,
                            const void * arg_value) ;

extern cl_int
clSetKernelExecInfoARM(cl_kernel kernel,
                       cl_kernel_exec_info_arm param_name,
                       size_t param_value_size,
                       const void * param_value) ;
# 837 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/cl_ext.h" 3
}
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cl.h" 2 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 2 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stringfwd.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stringfwd.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/memoryfwd.h" 1 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stringfwd.h" 3
  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 1 3
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functexcept.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functexcept.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_defines.h" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cpp_type_traits.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cpp_type_traits.h" 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 278 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/type_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/numeric_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 54 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/concept_check.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/concept_check.h" 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }


}




namespace std __attribute__ ((__visibility__ ("default")))
{
# 71 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 115 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 135 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 3
  template<typename _Tp>
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 166 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 181 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 76 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };







  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 252 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 280 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;



  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 521 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 541 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_pair.h" 3
}
# 65 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/debug/assertions.h" 1 3
# 66 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


                                ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline constexpr _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {



      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {



      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 1 3
# 66 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ptr_traits.h" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 100 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 126 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator() : current() { }




      explicit constexpr
      reverse_iterator(iterator_type __x) : current(__x) { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      constexpr iterator_type
      base() const
      { return current; }
# 168 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
# 182 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
      constexpr pointer
      operator->() const
      { return std::__addressof(operator*()); }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 300 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 390 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 454 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 489 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 531 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 546 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 580 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 622 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 641 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 692 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 736 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 760 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 860 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
# 1012 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      constexpr iterator_type
      base() const
      { return _M_current; }

      constexpr reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      constexpr reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/debug/debug.h" 1 3
# 48 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/predefined_ops.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 118 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
# 148 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
# 1039 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {






                                                       ;
                                                       ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {



                                                       ;
                                                       ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
# 1215 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {



                                                       ;
                                                       ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {



                                                       ;
                                                       ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stdarg.h" 1 3 4
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 35 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));
# 164 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
# 174 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 201 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 212 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));
# 233 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));
# 253 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();







extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
 btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
 wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
 mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }




extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();
# 411 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();
# 529 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 2 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 2 3
# 68 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 61 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
# 227 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 3
  template<typename _CharT>
    static inline __attribute__((__always_inline__)) constexpr bool
    __constant_string_p(const _CharT* __s)
    {
      while (__builtin_constant_p(*__s) && *__s)
 __s++;
      return __builtin_constant_p(*__s);
    }
# 244 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 3
  template<typename _CharT>
    static inline __attribute__((__always_inline__)) constexpr bool
    __constant_char_array_p(const _CharT* __a, size_t __n)
    {
      size_t __i = 0;
      while (__i < __n && __builtin_constant_p(__a[__i]))
 __i++;
      return __i == __n;
    }
# 268 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return __builtin_strlen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 if (__n == 0)
   return 0;
 else
   return wmemcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);
 else

   return wcslen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 if (__n == 0)
   return 0;
 else
   return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}






namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocator.h" 1 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++allocator.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/new_allocator.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/new_allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 3

#pragma GCC visibility push(default)



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{
# 132 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cxxabi_init_exception.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/typeinfo" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/typeinfo" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hash_bytes.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 208 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/exception_ptr.h" 3
    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 143 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/nested_exception.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)








extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 144 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/exception" 2 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));






void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__));
void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
# 168 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 190 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/new" 3
namespace std
{


  template<typename _Tp>
    constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;
}




#pragma GCC visibility pop
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();


 if (alignof(_Tp) > 16UL)
   {
     std::align_val_t __al = std::align_val_t(alignof(_Tp));
     return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
   }

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {

 if (alignof(_Tp) > 16UL)
   {
     ::operator delete(__p, std::align_val_t(alignof(_Tp)));
     return;
   }

 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }
# 151 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocator.h" 2 3
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }

    };
# 107 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
 allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/localefwd.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/localefwd.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++locale.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++locale.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/clocale" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/clocale" 2 3








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/localefwd.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iosfwd" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 74 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/localefwd.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cctype" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cctype" 2 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ostream_insert.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ostream_insert.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cxxabi_forced.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 104 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/binders.h" 1 3
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{
# 107 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_function.h" 2 3
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/range_access.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/range_access.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/initializer_list" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/range_access.h" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 240 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/range_access.h" 3
  template <typename _Container>
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }





  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (& )[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }





  template <typename _Tp, size_t _Nm>
    constexpr bool
    empty(const _Tp (& )[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }




}
# 52 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/atomicity.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/atomicity.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr.h" 1 3
# 30 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
{
  int sched_priority;
};

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 743 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
 pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 2 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/atomicity.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/atomic_word.h" 1 3
# 32 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/alloc_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/alloc_traits.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 299 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 314 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 326 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 341 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 354 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 366 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 377 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 434 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 448 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 460 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 472 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 484 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/alloc_traits.h" 3
  };


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 2 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string_view" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string_view" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
# 158 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1593 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string_view" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functional_hash.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 187 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string_view" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 70 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string_view" 3
  template<typename _CharT, typename _Traits = std::char_traits<_CharT>>
    class basic_string_view
    {
    public:


      using traits_type = _Traits;
      using value_type = _CharT;
      using pointer = const _CharT*;
      using const_pointer = const _CharT*;
      using reference = const _CharT&;
      using const_reference = const _CharT&;
      using const_iterator = const _CharT*;
      using iterator = const_iterator;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using reverse_iterator = const_reverse_iterator;
      using size_type = size_t;
      using difference_type = ptrdiff_t;
      static constexpr size_type npos = size_type(-1);



      constexpr
      basic_string_view() noexcept
      : _M_len{0}, _M_str{nullptr}
      { }

      constexpr basic_string_view(const basic_string_view&) noexcept = default;

      constexpr basic_string_view(const _CharT* __str)
      : _M_len{__str == nullptr ? 0 : traits_type::length(__str)},
 _M_str{__str}
      { }

      constexpr basic_string_view(const _CharT* __str, size_type __len)
      : _M_len{__len},
        _M_str{__str}
      { }

      constexpr basic_string_view&
      operator=(const basic_string_view&) noexcept = default;



      constexpr const_iterator
      begin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      end() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_iterator
      cbegin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      cend() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }



      constexpr size_type
      size() const noexcept
      { return this->_M_len; }

      constexpr size_type
      length() const noexcept
      { return _M_len; }

      constexpr size_type
      max_size() const noexcept
      {
 return (npos - sizeof(size_type) - sizeof(void*))
  / sizeof(value_type) / 4;
      }

      constexpr bool
      empty() const noexcept
      { return this->_M_len == 0; }



      constexpr const _CharT&
      operator[](size_type __pos) const noexcept
      {


 return *(this->_M_str + __pos);
      }

      constexpr const _CharT&
      at(size_type __pos) const
      {
 return __pos < this->_M_len
      ? *(this->_M_str + __pos)
      : (__throw_out_of_range_fmt(("basic_string_view::at: __pos " "(which is %zu) >= this->size() " "(which is %zu)"),


      __pos, this->size()),
  *this->_M_str);
      }

      constexpr const _CharT&
      front() const
      {


 return *this->_M_str;
      }

      constexpr const _CharT&
      back() const
      {


 return *(this->_M_str + this->_M_len - 1);
      }

      constexpr const _CharT*
      data() const noexcept
      { return this->_M_str; }



      constexpr void
      remove_prefix(size_type __n)
      {
                                      ;
 this->_M_str += __n;
 this->_M_len -= __n;
      }

      constexpr void
      remove_suffix(size_type __n)
      { this->_M_len -= __n; }

      constexpr void
      swap(basic_string_view& __sv) noexcept
      {
 auto __tmp = *this;
 *this = __sv;
 __sv = __tmp;
      }




      size_type
      copy(_CharT* __str, size_type __n, size_type __pos = 0) const
      {
                                          ;
 if (__pos > this->_M_len)
   __throw_out_of_range_fmt(("basic_string_view::copy: __pos " "(which is %zu) > this->size() " "(which is %zu)"),


       __pos, this->size());
 size_type __rlen{std::min(__n, size_type{this->_M_len - __pos})};
 for (auto __begin = this->_M_str + __pos,
      __end = __begin + __rlen; __begin != __end;)
   *__str++ = *__begin++;
 return __rlen;
      }




      constexpr basic_string_view
      substr(size_type __pos, size_type __n=npos) const
      {
 return __pos <= this->_M_len
      ? basic_string_view{this->_M_str + __pos,
    std::min(__n, size_type{this->_M_len - __pos})}
      : (__throw_out_of_range_fmt(("basic_string_view::substr: __pos " "(which is %zu) > this->size() " "(which is %zu)"),


         __pos, this->size()), basic_string_view{});
      }

      constexpr int
      compare(basic_string_view __str) const noexcept
      {
 int __ret = traits_type::compare(this->_M_str, __str._M_str,
      std::min(this->_M_len, __str._M_len));
 if (__ret == 0)
   __ret = _S_compare(this->_M_len, __str._M_len);
 return __ret;
      }

      constexpr int
      compare(size_type __pos1, size_type __n1, basic_string_view __str) const
      { return this->substr(__pos1, __n1).compare(__str); }

      constexpr int
      compare(size_type __pos1, size_type __n1,
       basic_string_view __str, size_type __pos2, size_type __n2) const
      { return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2)); }

      constexpr int
      compare(const _CharT* __str) const noexcept
      { return this->compare(basic_string_view{__str}); }

      constexpr int
      compare(size_type __pos1, size_type __n1, const _CharT* __str) const
      { return this->substr(__pos1, __n1).compare(basic_string_view{__str}); }

      constexpr int
      compare(size_type __pos1, size_type __n1,
       const _CharT* __str, size_type __n2) const
      {
 return this->substr(__pos1, __n1)
     .compare(basic_string_view(__str, __n2));
      }

      constexpr size_type
      find(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find(_CharT __c, size_type __pos=0) const noexcept;

      constexpr size_type
      find(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      constexpr size_type
      find(const _CharT* __str, size_type __pos=0) const noexcept
      { return this->find(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      rfind(basic_string_view __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;

      constexpr size_type
      rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      constexpr size_type
      rfind(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_first_of(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }

      constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos, size_type __n) const;

      constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_last_of(basic_string_view __str,
     size_type __pos = npos) const noexcept
      { return this->find_last_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_last_of(_CharT __c, size_type __pos=npos) const noexcept
      { return this->rfind(__c, __pos); }

      constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos, size_type __n) const;

      constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->find_last_of(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_first_not_of(basic_string_view __str,
   size_type __pos = 0) const noexcept
      { return this->find_first_not_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept;

      constexpr size_type
      find_first_not_of(const _CharT* __str,
   size_type __pos, size_type __n) const;

      constexpr size_type
      find_first_not_of(const _CharT* __str, size_type __pos = 0) const noexcept
      {
 return this->find_first_not_of(__str, __pos,
           traits_type::length(__str));
      }

      constexpr size_type
      find_last_not_of(basic_string_view __str,
         size_type __pos = npos) const noexcept
      { return this->find_last_not_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept;

      constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos, size_type __n) const;

      constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos = npos) const noexcept
      {
 return this->find_last_not_of(__str, __pos,
          traits_type::length(__str));
      }

      constexpr size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)"),

       __s, __pos, this->size());
 return __pos;
      }


      constexpr size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }

    private:

      static constexpr int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 return difference_type{__n1 - __n2} > std::numeric_limits<int>::max()
      ? std::numeric_limits<int>::max()
      : difference_type{__n1 - __n2} < std::numeric_limits<int>::min()
      ? std::numeric_limits<int>::min()
      : static_cast<int>(difference_type{__n1 - __n2});
      }

      size_t _M_len;
      const _CharT* _M_str;
    };




  namespace __detail
  {




    template<typename _Tp>
      using __idt = common_type_t<_Tp>;

  }



  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) >= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               __detail::__idt<basic_string_view<_CharT, _Traits>> __y) noexcept
    { return __x.compare(__y) >= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) >= 0; }


  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        basic_string_view<_CharT,_Traits> __str)
    { return __ostream_insert(__os, __str.data(), __str.size()); }




  using string_view = basic_string_view<char>;

  using wstring_view = basic_string_view<wchar_t>;


  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;




  template<typename _Tp>
    struct hash;

  template<>
    struct hash<string_view>
    : public __hash_base<size_t, string_view>
    {
      size_t
      operator()(const string_view& __str) const noexcept
      { return std::_Hash_impl::hash(__str.data(), __str.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string_view>> : std::false_type
    { };


  template<>
    struct hash<wstring_view>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring_view>> : std::false_type
    { };



  template<>
    struct hash<u16string_view>
    : public __hash_base<size_t, u16string_view>
    {
      size_t
      operator()(const u16string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string_view>> : std::false_type
    { };

  template<>
    struct hash<u32string_view>
    : public __hash_base<size_t, u32string_view>
    {
      size_t
      operator()(const u32string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string_view>> : std::false_type
    { };



  inline namespace literals
  {
  inline namespace string_view_literals
  {


    inline constexpr basic_string_view<char>
    operator""sv(const char* __str, size_t __len) noexcept
    { return basic_string_view<char>{__str, __len}; }


    inline constexpr basic_string_view<wchar_t>
    operator""sv(const wchar_t* __str, size_t __len) noexcept
    { return basic_string_view<wchar_t>{__str, __len}; }



    inline constexpr basic_string_view<char16_t>
    operator""sv(const char16_t* __str, size_t __len) noexcept
    { return basic_string_view<char16_t>{__str, __len}; }

    inline constexpr basic_string_view<char32_t>
    operator""sv(const char32_t* __str, size_t __len) noexcept
    { return basic_string_view<char32_t>{__str, __len}; }



  }
  }

}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/string_view.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/string_view.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
                                               ;

      if (__n == 0)
 return __pos <= this->_M_len ? __pos : npos;

      if (__n <= this->_M_len)
 {
   for (; __pos <= this->_M_len - __n; ++__pos)
     if (traits_type::eq(this->_M_str[__pos], __str[0])
  && traits_type::compare(this->_M_str + __pos + 1,
     __str + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      if (__pos < this->_M_len)
 {
   const size_type __n = this->_M_len - __pos;
   const _CharT* __p = traits_type::find(this->_M_str + __pos, __n, __c);
   if (__p)
     __ret = __p - this->_M_str;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
                                               ;

      if (__n <= this->_M_len)
 {
   __pos = std::min(size_type(this->_M_len - __n), __pos);
   do
     {
       if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size > 0)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(this->_M_str[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_of(const _CharT* __str, size_type __pos, size_type __n) const
    {
                                               ;
      for (; __n && __pos < this->_M_len; ++__pos)
 {
   const _CharT* __p = traits_type::find(__str, __n,
      this->_M_str[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_of(const _CharT* __str, size_type __pos, size_type __n) const
    {
                                               ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(const _CharT* __str, size_type __pos, size_type __n) const
    {
                                               ;
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::find(__str, __n, this->_M_str[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::eq(this->_M_str[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(const _CharT* __str, size_type __pos, size_type __n) const
    {
                                               ;
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(this->_M_str[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }


}
# 673 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string_view" 2 3
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;




      typedef basic_string_view<_CharT, _Traits> __sv_type;

      template<typename _Tp, typename _Res>
 using _If_sv = enable_if_t<
   __and_<is_convertible<const _Tp&, __sv_type>,
   __not_<is_convertible<const _Tp*, const basic_string*>>,
   __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
   _Res>;


      static __sv_type
      _S_to_string_view(__sv_type __svt) noexcept
      { return __svt; }





      struct __sv_wrapper
      {
 explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
 __sv_type _M_sv;
      };



      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 298 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)"),

       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 450 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 481 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 499 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 531 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 599 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 617 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp, typename = _If_sv<_Tp, void>>
 basic_string(const _Tp& __t, size_type __pos, size_type __n,
       const _Alloc& __a = _Alloc())
 : basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }






      template<typename _Tp, typename = _If_sv<_Tp, void>>
 explicit
 basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
 : basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }







      explicit
      basic_string(__sv_wrapper __svw, const _Alloc& __a)
      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }





      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 703 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 721 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







     template<typename _Tp>
       _If_sv<_Tp, basic_string&>
       operator=(const _Tp& __svt)
       { return this->assign(__svt); }





      operator __sv_type() const noexcept
      { return __sv_type(data(), size()); }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 944 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 957 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1006 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1035 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
                                  ;
 return _M_data()[__pos];
      }
# 1052 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


                                  ;

                                                                   ;
 return _M_data()[__pos];
      }
# 1073 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }
# 1094 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
                           ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
                           ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
                           ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
                           ;
 return operator[](this->size() - 1);
      }
# 1157 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1199 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 operator+=(const _Tp& __svt)
 { return this->append(__svt); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1227 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
                                        ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1269 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1293 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }







      template<typename _Tp>
        _If_sv<_Tp, basic_string&>
        append(const _Tp& __svt)
        {
          __sv_type __sv = __svt;
          return this->append(__sv.data(), __sv.size());
        }
# 1323 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
        _If_sv<_Tp, basic_string&>
 append(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_append(__sv.data()
      + __sv._M_check(__pos, "basic_string::append"),
      __sv._M_limit(__pos, __n));
 }






      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1369 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1392 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1408 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
                                        ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1424 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1441 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1454 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1480 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->assign(__sv.data(), __sv.size());
 }
# 1495 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_replace(size_type(0), this->size(), __sv.data()
       + __sv._M_check(__pos, "basic_string::assign"),
       __sv._M_limit(__pos, __n));
 }
# 1522 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1564 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
                                                           ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1600 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
                                                         ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1620 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1643 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1666 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1685 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1709 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1727 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1743 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->insert(__pos, __sv.data(), __sv.size());
 }
# 1760 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos1, const _Tp& __svt,
        size_type __pos2, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, size_type(0), __sv.data()
          + __sv._M_check(__pos2, "basic_string::insert"),
          __sv._M_limit(__pos2, __n));
 }
# 1787 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1806 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1825 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
                           ;
 _M_erase(size() - 1, 1);
      }
# 1869 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1891 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1916 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
                                         ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1941 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1965 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1983 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2003 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2025 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2046 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2071 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                        ;
                                             ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2103 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2162 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2175 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos, size_type __n, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos, __n, __sv.data(), __sv.size());
 }
# 2192 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, __n1, __sv.data()
          + __sv._M_check(__pos2, "basic_string::replace"),
          __sv._M_limit(__pos2, __n2));
 }
# 2212 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__i1 - begin(), __i2 - __i1, __sv);
 }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2259 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2269 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2279 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2291 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2302 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      _CharT*
      data() noexcept
      { return _M_data(); }





      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2326 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2340 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2352 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find(__sv.data(), __pos, __sv.size());
 }
# 2372 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2389 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2402 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2414 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 rfind(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->rfind(__sv.data(), __pos, __sv.size());
 }
# 2436 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2450 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2467 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2481 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2494 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_first_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_of(__sv.data(), __pos, __sv.size());
 }
# 2516 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2530 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2550 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2565 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2578 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_last_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_of(__sv.data(), __pos, __sv.size());
 }
# 2600 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2614 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2634 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2648 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2661 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_not_of(__sv.data(), __pos, __sv.size());
 }
# 2683 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2697 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2715 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2730 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2743 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_not_of(__sv.data(), __pos, __sv.size());
 }
# 2765 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2779 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2797 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2813 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2832 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }







      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   const size_type __size = this->size();
   const size_type __osize = __sv.size();
   const size_type __len = std::min(__size, __osize);

   int __r = traits_type::compare(_M_data(), __sv.data(), __len);
   if (!__r)
     __r = _S_compare(__size, __osize);
   return __r;
 }
# 2875 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(size_type __pos, size_type __n, const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this).substr(__pos, __n).compare(__sv);
 }
# 2894 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this)
     .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
 }
# 2925 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2951 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2969 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 2993 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3020 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5886 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6007 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6054 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6092 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6130 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6168 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6206 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6244 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6264 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6282 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6305 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6322 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/string_conversions.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/string_conversions.h" 3








# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/string_conversions.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwchar" 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/string_conversions.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {




# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4






typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
}
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 78 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;




typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();







extern FILE *tmpfile (void) ;
# 169 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 256 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 859 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
 feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
 ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 860 "/usr/include/stdio.h" 2 3 4








}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 2 3
# 96 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/string_conversions.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cerrno" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;





typedef int error_t;




}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cerrno" 2 3
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6362 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
# 6666 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.h" 3
  inline namespace literals
  {
  inline namespace string_literals
  {


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }



  }
  }



}
# 53 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.tcc" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid"));


 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1155 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1615 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.tcc" 3
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
# 1636 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_string.tcc" 3
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/string" 2 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 2 3
# 27 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {


constexpr const char *SYCL_STREAM_NAME = "sycl";

constexpr const char *SYCL_PICALL_STREAM_NAME = "sycl.pi";


struct code_location {
# 49 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
  static constexpr code_location
  current(const char *fileName = __builtin_FILE(),
          const char *funcName = __builtin_FUNCTION(),
          unsigned long lineNo = __builtin_LINE(),
          unsigned long columnNo = 0) noexcept {
    return code_location(fileName, funcName, lineNo, columnNo);
  }


  constexpr code_location(const char *file, const char *func, int line,
                          int col) noexcept
      : MFileName(file), MFunctionName(func), MLineNo(line), MColumnNo(col) {}

  constexpr code_location() noexcept
      : MFileName(nullptr), MFunctionName(nullptr), MLineNo(0), MColumnNo(0) {}

  constexpr unsigned long lineNumber() const noexcept { return MLineNo; }
  constexpr unsigned long columnNumber() const noexcept { return MColumnNo; }
  constexpr const char *fileName() const noexcept { return MFileName; }
  constexpr const char *functionName() const noexcept { return MFunctionName; }

private:
  const char *MFileName;
  const char *MFunctionName;
  unsigned long MLineNo;
  unsigned long MColumnNo;
};
}
}
}

inline namespace cl {
namespace sycl {
namespace detail {

__attribute__((visibility("default"))) const char *stringifyErrorCode(cl_int error);

static inline std::string codeToString(cl_int code) {
  return std::string(std::to_string(code) + " (" + stringifyErrorCode(code) +
                     ")");
}

}
}
}
# 109 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iostream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iostream" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ios" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ios" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_classes.h" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 2 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/system_error" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/system_error" 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/error_constants.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/error_constants.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cerrno" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cerrno" 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/system_error" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdexcept" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/system_error" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };


  template <typename _Tp>
    inline constexpr bool is_error_code_enum_v =
      is_error_code_enum<_Tp>::value;
  template <typename _Tp>
    inline constexpr bool is_error_condition_enum_v =
      is_error_condition_enum<_Tp>::value;

  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };





  template<>
    struct hash<error_condition>
    : public __hash_base<size_t, error_condition>
    {
      size_t
      operator()(const error_condition& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(__e.category(), __tmp);
      }
    };



}
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 2147483647,
      _S_ios_fmtflags_min = ~2147483647
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 2147483647,
      _S_ios_openmode_min = ~2147483647
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 2147483647,
      _S_ios_iostate_min = ~2147483647
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
  public:
# 255 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 487 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 504 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 516 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 629 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 645 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 662 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 688 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 739 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 751 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 762 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 773 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 792 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 808 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 829 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 846 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 860 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/streambuf.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 851 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/streambuf" 2 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwctype" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwctype" 3
# 50 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 51 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwctype" 2 3
# 80 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cctype" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cctype" 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/ctype_base.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 2 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/streambuf_iterator.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 71 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1156 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/ctype_inline.h" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}
# 1947 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2505 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2563 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1206 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/locale_facets.h" 2 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/basic_ios.h" 2 3
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ios" 2 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      pos_type
      tellp();
# 368 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 674 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ostream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 694 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ostream" 2 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iostream" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      int_type
      get();
# 315 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      int_type
      peek();
# 485 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      unget();
# 555 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      int
      sync();
# 570 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      pos_type
      tellg();
# 585 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/istream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/istream" 2 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 110 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 2 3
# 121 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/exception.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/exception.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 1 3
# 54 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
extern "C" {


using pi_int32 = int32_t;
using pi_uint32 = uint32_t;
using pi_uint64 = uint64_t;
using pi_bool = pi_uint32;
using pi_bitfield = pi_uint64;
using pi_native_handle = uintptr_t;
# 71 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
typedef enum {
  PI_SUCCESS = 0,
  PI_INVALID_KERNEL_NAME = -46,
  PI_INVALID_OPERATION = -59,
  PI_INVALID_KERNEL = -48,
  PI_INVALID_QUEUE_PROPERTIES = -35,
  PI_INVALID_VALUE = -30,
  PI_INVALID_CONTEXT = -34,
  PI_INVALID_PLATFORM = -32,
  PI_INVALID_DEVICE = -33,
  PI_INVALID_BINARY = -42,
  PI_INVALID_QUEUE = -36,
  PI_OUT_OF_HOST_MEMORY = -6,
  PI_INVALID_PROGRAM = -44,
  PI_INVALID_MEM_OBJECT = -38,
  PI_OUT_OF_RESOURCES = -5,
  PI_INVALID_EVENT = -58,
  PI_INVALID_EVENT_WAIT_LIST = -57,
  PI_MISALIGNED_SUB_BUFFER_OFFSET = -13,
  PI_BUILD_PROGRAM_FAILURE = -11,
  PI_INVALID_WORK_GROUP_SIZE = -54,
  PI_COMPILER_NOT_AVAILABLE = -3,
  PI_PROFILING_INFO_NOT_AVAILABLE = -7,
  PI_DEVICE_NOT_FOUND = -1,
  PI_INVALID_WORK_ITEM_SIZE = -55,
  PI_INVALID_KERNEL_ARGS = -52,
  PI_INVALID_IMAGE_SIZE = -40,
  PI_IMAGE_FORMAT_NOT_SUPPORTED = -10,
  PI_MEM_OBJECT_ALLOCATION_FAILURE = -4,
  PI_ERROR_UNKNOWN = -999
} _pi_result;

typedef enum {
  PI_EVENT_COMPLETE = 0x0,
  PI_EVENT_RUNNING = 0x1,
  PI_EVENT_SUBMITTED = 0x2,
  PI_EVENT_QUEUED = 0x3
} _pi_event_status;

typedef enum {
  PI_PLATFORM_INFO_EXTENSIONS = 0x0904,
  PI_PLATFORM_INFO_NAME = 0x0902,
  PI_PLATFORM_INFO_PROFILE = 0x0900,
  PI_PLATFORM_INFO_VENDOR = 0x0903,
  PI_PLATFORM_INFO_VERSION = 0x0901
} _pi_platform_info;

typedef enum {
  PI_PROGRAM_BUILD_INFO_STATUS = 0x1181,
  PI_PROGRAM_BUILD_INFO_OPTIONS = 0x1182,
  PI_PROGRAM_BUILD_INFO_LOG = 0x1183
} _pi_program_build_info;

typedef enum {
  PI_PROGRAM_BUILD_STATUS_NONE = -1,
  PI_PROGRAM_BUILD_STATUS_ERROR = -2,
  PI_PROGRAM_BUILD_STATUS_SUCCESS = 0,
  PI_PROGRAM_BUILD_STATUS_IN_PROGRESS = -3
} _pi_program_build_status;




typedef enum : pi_uint64 {
  PI_DEVICE_TYPE_DEFAULT =
      (1 << 0),

  PI_DEVICE_TYPE_ALL =
      0xFFFFFFFF,
  PI_DEVICE_TYPE_CPU =
      (1 << 1),
  PI_DEVICE_TYPE_GPU = (1 << 2),
  PI_DEVICE_TYPE_ACC = (1 << 3)

} _pi_device_type;

typedef enum {
  PI_DEVICE_MEM_CACHE_TYPE_NONE = 0x0,
  PI_DEVICE_MEM_CACHE_TYPE_READ_ONLY_CACHE = 0x1,
  PI_DEVICE_MEM_CACHE_TYPE_READ_WRITE_CACHE = 0x2
} _pi_device_mem_cache_type;

typedef enum {
  PI_DEVICE_LOCAL_MEM_TYPE_LOCAL = 0x1,
  PI_DEVICE_LOCAL_MEM_TYPE_GLOBAL = 0x2
} _pi_device_local_mem_type;

typedef enum {
  PI_DEVICE_INFO_TYPE = 0x1000,
  PI_DEVICE_INFO_VENDOR_ID = 0x1001,
  PI_DEVICE_INFO_MAX_COMPUTE_UNITS = 0x1002,
  PI_DEVICE_INFO_MAX_WORK_ITEM_DIMENSIONS = 0x1003,
  PI_DEVICE_INFO_MAX_WORK_ITEM_SIZES = 0x1005,
  PI_DEVICE_INFO_MAX_WORK_GROUP_SIZE = 0x1004,
  PI_DEVICE_INFO_SINGLE_FP_CONFIG = 0x101B,
  PI_DEVICE_INFO_HALF_FP_CONFIG = 0x1033,
  PI_DEVICE_INFO_DOUBLE_FP_CONFIG = 0x1032,
  PI_DEVICE_INFO_QUEUE_PROPERTIES = 0x102A,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_CHAR =
      0x1006,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_SHORT =
      0x1007,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_INT =
      0x1008,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_LONG =
      0x1009,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_FLOAT =
      0x100A,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_DOUBLE =
      0x100B,
  PI_DEVICE_INFO_PREFERRED_VECTOR_WIDTH_HALF =
      0x1034,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_CHAR = 0x1036,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_SHORT =
      0x1037,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_INT = 0x1038,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_LONG = 0x1039,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_FLOAT =
      0x103A,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_DOUBLE =
      0x103B,
  PI_DEVICE_INFO_NATIVE_VECTOR_WIDTH_HALF = 0x103C,
  PI_DEVICE_INFO_MAX_CLOCK_FREQUENCY = 0x100C,
  PI_DEVICE_INFO_ADDRESS_BITS = 0x100D,
  PI_DEVICE_INFO_MAX_MEM_ALLOC_SIZE = 0x1010,
  PI_DEVICE_INFO_IMAGE_SUPPORT = 0x1016,
  PI_DEVICE_INFO_MAX_READ_IMAGE_ARGS = 0x100E,
  PI_DEVICE_INFO_MAX_WRITE_IMAGE_ARGS = 0x100F,
  PI_DEVICE_INFO_IMAGE2D_MAX_WIDTH = 0x1011,
  PI_DEVICE_INFO_IMAGE2D_MAX_HEIGHT = 0x1012,
  PI_DEVICE_INFO_IMAGE3D_MAX_WIDTH = 0x1013,
  PI_DEVICE_INFO_IMAGE3D_MAX_HEIGHT = 0x1014,
  PI_DEVICE_INFO_IMAGE3D_MAX_DEPTH = 0x1015,
  PI_DEVICE_INFO_IMAGE_MAX_BUFFER_SIZE = 0x1040,
  PI_DEVICE_INFO_IMAGE_MAX_ARRAY_SIZE = 0x1041,
  PI_DEVICE_INFO_MAX_SAMPLERS = 0x1018,
  PI_DEVICE_INFO_MAX_PARAMETER_SIZE = 0x1017,
  PI_DEVICE_INFO_MEM_BASE_ADDR_ALIGN = 0x1019,
  PI_DEVICE_INFO_GLOBAL_MEM_CACHE_TYPE = 0x101C,
  PI_DEVICE_INFO_GLOBAL_MEM_CACHELINE_SIZE =
      0x101D,
  PI_DEVICE_INFO_GLOBAL_MEM_CACHE_SIZE = 0x101E,
  PI_DEVICE_INFO_GLOBAL_MEM_SIZE = 0x101F,
  PI_DEVICE_INFO_MAX_CONSTANT_BUFFER_SIZE = 0x1020,
  PI_DEVICE_INFO_MAX_CONSTANT_ARGS = 0x1021,
  PI_DEVICE_INFO_LOCAL_MEM_TYPE = 0x1022,
  PI_DEVICE_INFO_LOCAL_MEM_SIZE = 0x1023,
  PI_DEVICE_INFO_ERROR_CORRECTION_SUPPORT = 0x1024,
  PI_DEVICE_INFO_HOST_UNIFIED_MEMORY = 0x1035,
  PI_DEVICE_INFO_PROFILING_TIMER_RESOLUTION =
      0x1025,
  PI_DEVICE_INFO_ENDIAN_LITTLE = 0x1026,
  PI_DEVICE_INFO_AVAILABLE = 0x1027,
  PI_DEVICE_INFO_COMPILER_AVAILABLE = 0x1028,
  PI_DEVICE_INFO_LINKER_AVAILABLE = 0x103E,
  PI_DEVICE_INFO_EXECUTION_CAPABILITIES = 0x1029,
  PI_DEVICE_INFO_QUEUE_ON_DEVICE_PROPERTIES =
      0x104E,
  PI_DEVICE_INFO_QUEUE_ON_HOST_PROPERTIES = 0x102A,
  PI_DEVICE_INFO_BUILT_IN_KERNELS = 0x103F,
  PI_DEVICE_INFO_PLATFORM = 0x1031,
  PI_DEVICE_INFO_REFERENCE_COUNT = 0x1047,
  PI_DEVICE_INFO_IL_VERSION = 0x105B,
  PI_DEVICE_INFO_NAME = 0x102B,
  PI_DEVICE_INFO_VENDOR = 0x102C,
  PI_DEVICE_INFO_DRIVER_VERSION = 0x102D,
  PI_DEVICE_INFO_PROFILE = 0x102E,
  PI_DEVICE_INFO_VERSION = 0x102F,
  PI_DEVICE_INFO_OPENCL_C_VERSION = 0x103D,
  PI_DEVICE_INFO_EXTENSIONS = 0x1030,
  PI_DEVICE_INFO_PRINTF_BUFFER_SIZE = 0x1049,
  PI_DEVICE_INFO_PREFERRED_INTEROP_USER_SYNC =
      0x1048,
  PI_DEVICE_INFO_PARENT_DEVICE = 0x1042,
  PI_DEVICE_INFO_PARTITION_PROPERTIES = 0x1044,
  PI_DEVICE_INFO_PARTITION_MAX_SUB_DEVICES =
      0x1043,
  PI_DEVICE_INFO_PARTITION_AFFINITY_DOMAIN =
      0x1045,
  PI_DEVICE_INFO_PARTITION_TYPE = 0x1046,
  PI_DEVICE_INFO_MAX_NUM_SUB_GROUPS = 0x105C,
  PI_DEVICE_INFO_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS =
      0x105D,
  PI_DEVICE_INFO_SUB_GROUP_SIZES_INTEL = 0x4108,
  PI_DEVICE_INFO_USM_HOST_SUPPORT = 0x4190,
  PI_DEVICE_INFO_USM_DEVICE_SUPPORT = 0x4191,
  PI_DEVICE_INFO_USM_SINGLE_SHARED_SUPPORT =
      0x4192,
  PI_DEVICE_INFO_USM_CROSS_SHARED_SUPPORT =
      0x4193,
  PI_DEVICE_INFO_USM_SYSTEM_SHARED_SUPPORT =
      0x4194
} _pi_device_info;

typedef enum {
  PI_PROGRAM_INFO_REFERENCE_COUNT = 0x1160,
  PI_PROGRAM_INFO_CONTEXT = 0x1161,
  PI_PROGRAM_INFO_NUM_DEVICES = 0x1162,
  PI_PROGRAM_INFO_DEVICES = 0x1163,
  PI_PROGRAM_INFO_SOURCE = 0x1164,
  PI_PROGRAM_INFO_BINARY_SIZES = 0x1165,
  PI_PROGRAM_INFO_BINARIES = 0x1166,
  PI_PROGRAM_INFO_NUM_KERNELS = 0x1167,
  PI_PROGRAM_INFO_KERNEL_NAMES = 0x1168
} _pi_program_info;

typedef enum {
  PI_CONTEXT_INFO_DEVICES = 0x1081,
  PI_CONTEXT_INFO_NUM_DEVICES = 0x1083,
  PI_CONTEXT_INFO_PROPERTIES = 0x1082,
  PI_CONTEXT_INFO_REFERENCE_COUNT = 0x1080,
} _pi_context_info;

typedef enum {
  PI_QUEUE_INFO_CONTEXT = 0x1090,
  PI_QUEUE_INFO_DEVICE = 0x1091,
  PI_QUEUE_INFO_DEVICE_DEFAULT = 0x1095,
  PI_QUEUE_INFO_PROPERTIES = 0x1093,
  PI_QUEUE_INFO_REFERENCE_COUNT = 0x1092,
  PI_QUEUE_INFO_SIZE = 0x1094
} _pi_queue_info;

typedef enum {
  PI_IMAGE_INFO_FORMAT = 0x1110,
  PI_IMAGE_INFO_ELEMENT_SIZE = 0x1111,
  PI_IMAGE_INFO_ROW_PITCH = 0x1112,
  PI_IMAGE_INFO_SLICE_PITCH = 0x1113,
  PI_IMAGE_INFO_WIDTH = 0x1114,
  PI_IMAGE_INFO_HEIGHT = 0x1115,
  PI_IMAGE_INFO_DEPTH = 0x1116
} _pi_image_info;

typedef enum {
  PI_KERNEL_INFO_FUNCTION_NAME = 0x1190,
  PI_KERNEL_INFO_NUM_ARGS = 0x1191,
  PI_KERNEL_INFO_REFERENCE_COUNT = 0x1192,
  PI_KERNEL_INFO_CONTEXT = 0x1193,
  PI_KERNEL_INFO_PROGRAM = 0x1194,
  PI_KERNEL_INFO_ATTRIBUTES = 0x1195
} _pi_kernel_info;

typedef enum {
  PI_KERNEL_GROUP_INFO_GLOBAL_WORK_SIZE = 0x11B5,
  PI_KERNEL_GROUP_INFO_WORK_GROUP_SIZE = 0x11B0,
  PI_KERNEL_GROUP_INFO_COMPILE_WORK_GROUP_SIZE =
      0x11B1,
  PI_KERNEL_GROUP_INFO_LOCAL_MEM_SIZE = 0x11B2,
  PI_KERNEL_GROUP_INFO_PREFERRED_WORK_GROUP_SIZE_MULTIPLE =
      0x11B3,
  PI_KERNEL_GROUP_INFO_PRIVATE_MEM_SIZE = 0x11B4
} _pi_kernel_group_info;

typedef enum {
  PI_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT = (1 << 7),
  PI_FP_ROUND_TO_NEAREST = (1 << 2),
  PI_FP_ROUND_TO_ZERO = (1 << 3),
  PI_FP_ROUND_TO_INF = (1 << 4),
  PI_FP_INF_NAN = (1 << 1),
  PI_FP_DENORM = (1 << 0),
  PI_FP_FMA = (1 << 5)
} _pi_fp_capabilities;

typedef enum {
  PI_KERNEL_MAX_SUB_GROUP_SIZE = 0x2033,
  PI_KERNEL_MAX_NUM_SUB_GROUPS = 0x11B9,
  PI_KERNEL_COMPILE_NUM_SUB_GROUPS = 0x11BA,
  PI_KERNEL_COMPILE_SUB_GROUP_SIZE_INTEL =
      0x410A
} _pi_kernel_sub_group_info;

typedef enum {
  PI_EVENT_INFO_COMMAND_QUEUE = 0x11D0,
  PI_EVENT_INFO_CONTEXT = 0x11D4,
  PI_EVENT_INFO_COMMAND_TYPE = 0x11D1,
  PI_EVENT_INFO_COMMAND_EXECUTION_STATUS = 0x11D3,
  PI_EVENT_INFO_REFERENCE_COUNT = 0x11D2
} _pi_event_info;

typedef enum {
  PI_COMMAND_TYPE_NDRANGE_KERNEL = 0x11F0,
  PI_COMMAND_TYPE_MEM_BUFFER_READ = 0x11F3,
  PI_COMMAND_TYPE_MEM_BUFFER_WRITE = 0x11F4,
  PI_COMMAND_TYPE_MEM_BUFFER_COPY = 0x11F5,
  PI_COMMAND_TYPE_MEM_BUFFER_MAP = 0x11FB,
  PI_COMMAND_TYPE_MEM_BUFFER_UNMAP = 0x11FD,
  PI_COMMAND_TYPE_MEM_BUFFER_READ_RECT = 0x1201,
  PI_COMMAND_TYPE_MEM_BUFFER_WRITE_RECT = 0x1202,
  PI_COMMAND_TYPE_MEM_BUFFER_COPY_RECT = 0x1203,
  PI_COMMAND_TYPE_USER = 0x1204,
  PI_COMMAND_TYPE_MEM_BUFFER_FILL = 0x1207,
  PI_COMMAND_TYPE_IMAGE_READ = 0x11F6,
  PI_COMMAND_TYPE_IMAGE_WRITE = 0x11F7,
  PI_COMMAND_TYPE_IMAGE_COPY = 0x11F8,
  PI_COMMAND_TYPE_NATIVE_KERNEL = 0x11F2,
  PI_COMMAND_TYPE_COPY_BUFFER_TO_IMAGE = 0x11FA,
  PI_COMMAND_TYPE_COPY_IMAGE_TO_BUFFER = 0x11F9,
  PI_COMMAND_TYPE_MAP_IMAGE = 0x11FC,
  PI_COMMAND_TYPE_MARKER = 0x11FE,
  PI_COMMAND_TYPE_ACQUIRE_GL_OBJECTS = 0x11FF,
  PI_COMMAND_TYPE_RELEASE_GL_OBJECTS = 0x1200,
  PI_COMMAND_TYPE_BARRIER = 0x1205,
  PI_COMMAND_TYPE_MIGRATE_MEM_OBJECTS = 0x1206,
  PI_COMMAND_TYPE_FILL_IMAGE = 0x1208,
  PI_COMMAND_TYPE_SVM_FREE = 0x1209,
  PI_COMMAND_TYPE_SVM_MEMCPY = 0x120A,
  PI_COMMAND_TYPE_SVM_MEMFILL = 0x120B,
  PI_COMMAND_TYPE_SVM_MAP = 0x120C,
  PI_COMMAND_TYPE_SVM_UNMAP = 0x120D
} _pi_command_type;

typedef enum {
  PI_MEM_TYPE_BUFFER = 0x10F0,
  PI_MEM_TYPE_IMAGE2D = 0x10F1,
  PI_MEM_TYPE_IMAGE3D = 0x10F2,
  PI_MEM_TYPE_IMAGE2D_ARRAY = 0x10F3,
  PI_MEM_TYPE_IMAGE1D = 0x10F4,
  PI_MEM_TYPE_IMAGE1D_ARRAY = 0x10F5,
  PI_MEM_TYPE_IMAGE1D_BUFFER = 0x10F6
} _pi_mem_type;

typedef enum {

  PI_MEM_ADVISE_UNKNOWN
} _pi_mem_advice;

typedef enum {
  PI_IMAGE_CHANNEL_ORDER_A = 0x10B1,
  PI_IMAGE_CHANNEL_ORDER_R = 0x10B0,
  PI_IMAGE_CHANNEL_ORDER_RG = 0x10B2,
  PI_IMAGE_CHANNEL_ORDER_RA = 0x10B3,
  PI_IMAGE_CHANNEL_ORDER_RGB = 0x10B4,
  PI_IMAGE_CHANNEL_ORDER_RGBA = 0x10B5,
  PI_IMAGE_CHANNEL_ORDER_BGRA = 0x10B6,
  PI_IMAGE_CHANNEL_ORDER_ARGB = 0x10B7,
  PI_IMAGE_CHANNEL_ORDER_ABGR = 0x10C3,
  PI_IMAGE_CHANNEL_ORDER_INTENSITY = 0x10B8,
  PI_IMAGE_CHANNEL_ORDER_LUMINANCE = 0x10B9,
  PI_IMAGE_CHANNEL_ORDER_Rx = 0x10BA,
  PI_IMAGE_CHANNEL_ORDER_RGx = 0x10BB,
  PI_IMAGE_CHANNEL_ORDER_RGBx = 0x10BC
} _pi_image_channel_order;

typedef enum {
  PI_IMAGE_CHANNEL_TYPE_SNORM_INT8 = 0x10D0,
  PI_IMAGE_CHANNEL_TYPE_SNORM_INT16 = 0x10D1,
  PI_IMAGE_CHANNEL_TYPE_UNORM_INT8 = 0x10D2,
  PI_IMAGE_CHANNEL_TYPE_UNORM_INT16 = 0x10D3,
  PI_IMAGE_CHANNEL_TYPE_UNORM_SHORT_565 = 0x10D4,
  PI_IMAGE_CHANNEL_TYPE_UNORM_SHORT_555 = 0x10D5,
  PI_IMAGE_CHANNEL_TYPE_UNORM_INT_101010 = 0x10D6,
  PI_IMAGE_CHANNEL_TYPE_SIGNED_INT8 = 0x10D7,
  PI_IMAGE_CHANNEL_TYPE_SIGNED_INT16 = 0x10D8,
  PI_IMAGE_CHANNEL_TYPE_SIGNED_INT32 = 0x10D9,
  PI_IMAGE_CHANNEL_TYPE_UNSIGNED_INT8 = 0x10DA,
  PI_IMAGE_CHANNEL_TYPE_UNSIGNED_INT16 = 0x10DB,
  PI_IMAGE_CHANNEL_TYPE_UNSIGNED_INT32 = 0x10DC,
  PI_IMAGE_CHANNEL_TYPE_HALF_FLOAT = 0x10DD,
  PI_IMAGE_CHANNEL_TYPE_FLOAT = 0x10DE
} _pi_image_channel_type;

typedef enum {
  PI_BUFFER_CREATE_TYPE_REGION = 0x1220
} _pi_buffer_create_type;

const pi_bool PI_TRUE = 1;
const pi_bool PI_FALSE = 0;

typedef enum {
  PI_SAMPLER_INFO_REFERENCE_COUNT = 0x1150,
  PI_SAMPLER_INFO_CONTEXT = 0x1151,
  PI_SAMPLER_INFO_NORMALIZED_COORDS = 0x1152,
  PI_SAMPLER_INFO_ADDRESSING_MODE = 0x1153,
  PI_SAMPLER_INFO_FILTER_MODE = 0x1154,
  PI_SAMPLER_INFO_MIP_FILTER_MODE = 0x1155,
  PI_SAMPLER_INFO_LOD_MIN = 0x1156,
  PI_SAMPLER_INFO_LOD_MAX = 0x1157
} _pi_sampler_info;

typedef enum {
  PI_SAMPLER_ADDRESSING_MODE_MIRRORED_REPEAT = 0x1134,
  PI_SAMPLER_ADDRESSING_MODE_REPEAT = 0x1133,
  PI_SAMPLER_ADDRESSING_MODE_CLAMP_TO_EDGE = 0x1131,
  PI_SAMPLER_ADDRESSING_MODE_CLAMP = 0x1132,
  PI_SAMPLER_ADDRESSING_MODE_NONE = 0x1130
} _pi_sampler_addressing_mode;

typedef enum {
  PI_SAMPLER_FILTER_MODE_NEAREST = 0x1140,
  PI_SAMPLER_FILTER_MODE_LINEAR = 0x1141,
} _pi_sampler_filter_mode;

using pi_context_properties = intptr_t;

using pi_device_exec_capabilities = pi_bitfield;
constexpr pi_device_exec_capabilities PI_DEVICE_EXEC_CAPABILITIES_KERNEL =
    (1 << 0);
constexpr pi_device_exec_capabilities
    PI_DEVICE_EXEC_CAPABILITIES_NATIVE_KERNEL = (1 << 1);

using pi_sampler_properties = pi_bitfield;
constexpr pi_sampler_properties PI_SAMPLER_PROPERTIES_NORMALIZED_COORDS =
    0x1152;
constexpr pi_sampler_properties PI_SAMPLER_PROPERTIES_ADDRESSING_MODE =
    0x1153;
constexpr pi_sampler_properties PI_SAMPLER_PROPERTIES_FILTER_MODE =
    0x1154;

typedef enum {
  PI_PROFILING_INFO_COMMAND_QUEUED = 0x1280,
  PI_PROFILING_INFO_COMMAND_SUBMIT = 0x1281,
  PI_PROFILING_INFO_COMMAND_START = 0x1282,
  PI_PROFILING_INFO_COMMAND_END = 0x1283
} _pi_profiling_info;





using pi_mem_flags = pi_bitfield;

constexpr pi_mem_flags PI_MEM_FLAGS_ACCESS_RW = (1 << 0);

constexpr pi_mem_flags PI_MEM_FLAGS_HOST_PTR_USE = (1 << 3);
constexpr pi_mem_flags PI_MEM_FLAGS_HOST_PTR_COPY = (1 << 5);
constexpr pi_mem_flags PI_MEM_FLAGS_HOST_PTR_ALLOC = (1 << 4);



using pi_queue_properties = pi_bitfield;
constexpr pi_queue_properties PI_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE =
    (1 << 0);
constexpr pi_queue_properties PI_QUEUE_PROFILING_ENABLE =
    (1 << 1);
constexpr pi_queue_properties PI_QUEUE_ON_DEVICE = (1 << 2);
constexpr pi_queue_properties PI_QUEUE_ON_DEVICE_DEFAULT =
    (1 << 3);

using pi_result = _pi_result;
using pi_platform_info = _pi_platform_info;
using pi_device_type = _pi_device_type;
using pi_device_mem_cache_type = _pi_device_mem_cache_type;
using pi_device_local_mem_type = _pi_device_local_mem_type;
using pi_device_info = _pi_device_info;
using pi_program_info = _pi_program_info;
using pi_context_info = _pi_context_info;
using pi_queue_info = _pi_queue_info;
using pi_image_info = _pi_image_info;
using pi_kernel_info = _pi_kernel_info;
using pi_kernel_group_info = _pi_kernel_group_info;
using pi_kernel_sub_group_info = _pi_kernel_sub_group_info;
using pi_fp_capabilities = _pi_fp_capabilities;
using pi_event_info = _pi_event_info;
using pi_command_type = _pi_command_type;
using pi_mem_type = _pi_mem_type;
using pi_mem_advice = _pi_mem_advice;
using pi_image_channel_order = _pi_image_channel_order;
using pi_image_channel_type = _pi_image_channel_type;
using pi_buffer_create_type = _pi_buffer_create_type;
using pi_sampler_addressing_mode = _pi_sampler_addressing_mode;
using pi_sampler_filter_mode = _pi_sampler_filter_mode;
using pi_sampler_info = _pi_sampler_info;
using pi_event_status = _pi_event_status;
using pi_program_build_info = _pi_program_build_info;
using pi_program_build_status = _pi_program_build_status;
using pi_kernel_info = _pi_kernel_info;
using pi_profiling_info = _pi_profiling_info;


using pi_device_partition_property = intptr_t;
static constexpr pi_device_partition_property PI_DEVICE_PARTITION_EQUALLY =
    0x1086;
static constexpr pi_device_partition_property
    PI_DEVICE_PARTITION_BY_AFFINITY_DOMAIN =
        0x1088;


using pi_device_affinity_domain = pi_bitfield;
static constexpr pi_device_affinity_domain PI_DEVICE_AFFINITY_DOMAIN_NUMA =
    (1 << 0);
static constexpr pi_device_affinity_domain
    PI_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE =
        (1 << 5);


struct _pi_offload_entry_struct {
  void *addr;
  char *name;
  size_t size;
  int32_t flags;
  int32_t reserved;
};

using _pi_offload_entry = _pi_offload_entry_struct *;


typedef enum {
  PI_PROPERTY_TYPE_UNKNOWN,
  PI_PROPERTY_TYPE_UINT32,
  PI_PROPERTY_TYPE_BYTE_ARRAY,
  PI_PROPERTY_TYPE_STRING
} pi_property_type;





struct _pi_device_binary_property_struct {
  char *Name;
  void *ValAddr;
  uint32_t Type;
  uint64_t ValSize;
};

typedef _pi_device_binary_property_struct *pi_device_binary_property;


struct _pi_device_binary_property_set_struct {
  char *Name;
  pi_device_binary_property PropertiesBegin;
  pi_device_binary_property PropertiesEnd;
};

typedef _pi_device_binary_property_set_struct *pi_device_binary_property_set;


using pi_device_binary_type = uint8_t;

static constexpr pi_device_binary_type PI_DEVICE_BINARY_TYPE_NONE = 0;

static constexpr pi_device_binary_type PI_DEVICE_BINARY_TYPE_NATIVE = 1;


static constexpr pi_device_binary_type PI_DEVICE_BINARY_TYPE_SPIRV = 2;

static constexpr pi_device_binary_type PI_DEVICE_BINARY_TYPE_LLVMIR_BITCODE = 3;


static const uint16_t PI_DEVICE_BINARY_VERSION = 1;


static const uint8_t PI_DEVICE_BINARY_OFFLOAD_KIND_SYCL = 4;
# 648 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
struct pi_device_binary_struct {



  uint16_t Version;

  uint8_t Kind;

  uint8_t Format;
# 665 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
  const char *DeviceTargetSpec;


  const char *CompileOptions;


  const char *LinkOptions;

  const char *ManifestStart;

  const char *ManifestEnd;

  const unsigned char *BinaryStart;

  const unsigned char *BinaryEnd;

  _pi_offload_entry EntriesBegin;
  _pi_offload_entry EntriesEnd;


  pi_device_binary_property_set PropertySetsBegin;
  pi_device_binary_property_set PropertySetsEnd;



};
using pi_device_binary = pi_device_binary_struct *;


struct pi_buffer_region_struct {
  size_t origin;
  size_t size;
};
using pi_buffer_region = pi_buffer_region_struct *;


static const uint16_t PI_DEVICE_BINARIES_VERSION = 1;




struct pi_device_binaries_struct {



  uint16_t Version;

  uint16_t NumDeviceBinaries;

  pi_device_binary DeviceBinaries;

  _pi_offload_entry *HostEntriesBegin;
  _pi_offload_entry *HostEntriesEnd;
};
using pi_device_binaries = pi_device_binaries_struct *;


struct _pi_platform;
struct _pi_device;
struct _pi_context;
struct _pi_queue;
struct _pi_mem;
struct _pi_program;
struct _pi_kernel;
struct _pi_event;
struct _pi_sampler;

using pi_platform = _pi_platform *;
using pi_device = _pi_device *;
using pi_context = _pi_context *;
using pi_queue = _pi_queue *;
using pi_mem = _pi_mem *;
using pi_program = _pi_program *;
using pi_kernel = _pi_kernel *;
using pi_event = _pi_event *;
using pi_sampler = _pi_sampler *;

typedef struct {
  pi_image_channel_order image_channel_order;
  pi_image_channel_type image_channel_data_type;
} _pi_image_format;

typedef struct {
  pi_mem_type image_type;
  size_t image_width;
  size_t image_height;
  size_t image_depth;
  size_t image_array_size;
  size_t image_row_pitch;
  size_t image_slice_pitch;
  pi_uint32 num_mip_levels;
  pi_uint32 num_samples;
  pi_mem buffer;
} _pi_image_desc;

using pi_image_format = _pi_image_format;
using pi_image_desc = _pi_image_desc;
# 775 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
struct _pi_plugin;
using pi_plugin = _pi_plugin;






__attribute__((visibility("default"))) pi_result piPluginInit(pi_plugin *plugin_info);




__attribute__((visibility("default"))) pi_result piPlatformsGet(pi_uint32 num_entries,
                                       pi_platform *platforms,
                                       pi_uint32 *num_platforms);

__attribute__((visibility("default"))) pi_result piPlatformGetInfo(pi_platform platform,
                                          pi_platform_info param_name,
                                          size_t param_value_size,
                                          void *param_value,
                                          size_t *param_value_size_ret);





__attribute__((visibility("default"))) pi_result piextPlatformGetNativeHandle(
    pi_platform platform, pi_native_handle *nativeHandle);






__attribute__((visibility("default"))) pi_result piextPlatformCreateWithNativeHandle(
    pi_native_handle nativeHandle, pi_platform *platform);

__attribute__((visibility("default"))) pi_result piDevicesGet(pi_platform platform,
                                     pi_device_type device_type,
                                     pi_uint32 num_entries, pi_device *devices,
                                     pi_uint32 *num_devices);

__attribute__((visibility("default"))) pi_result piDeviceGetInfo(pi_device device,
                                        pi_device_info param_name,
                                        size_t param_value_size,
                                        void *param_value,
                                        size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piDeviceRetain(pi_device device);

__attribute__((visibility("default"))) pi_result piDeviceRelease(pi_device device);

__attribute__((visibility("default"))) pi_result piDevicePartition(
    pi_device device, const pi_device_partition_property *properties,
    pi_uint32 num_devices, pi_device *out_devices, pi_uint32 *out_num_devices);





__attribute__((visibility("default"))) pi_result
piextDeviceGetNativeHandle(pi_device device, pi_native_handle *nativeHandle);







__attribute__((visibility("default"))) pi_result piextDeviceCreateWithNativeHandle(
    pi_native_handle nativeHandle, pi_platform platform, pi_device *device);




__attribute__((visibility("default"))) pi_result piextDeviceSelectBinary(pi_device device,
                                                pi_device_binary *binaries,
                                                pi_uint32 num_binaries,
                                                pi_uint32 *selected_binary_ind);
# 864 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextGetDeviceFunctionPointer(
    pi_device device, pi_program program, const char *function_name,
    pi_uint64 *function_pointer_ret);




__attribute__((visibility("default"))) pi_result piContextCreate(
    const pi_context_properties *properties, pi_uint32 num_devices,
    const pi_device *devices,
    void (*pfn_notify)(const char *errinfo, const void *private_info, size_t cb,
                       void *user_data),
    void *user_data, pi_context *ret_context);

__attribute__((visibility("default"))) pi_result piContextGetInfo(pi_context context,
                                         pi_context_info param_name,
                                         size_t param_value_size,
                                         void *param_value,
                                         size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piContextRetain(pi_context context);

__attribute__((visibility("default"))) pi_result piContextRelease(pi_context context);

typedef void (*pi_context_extended_deleter)(void *user_data);

__attribute__((visibility("default"))) pi_result piextContextSetExtendedDeleter(
    pi_context context, pi_context_extended_deleter func, void *user_data);





__attribute__((visibility("default"))) pi_result
piextContextGetNativeHandle(pi_context context, pi_native_handle *nativeHandle);






__attribute__((visibility("default"))) pi_result piextContextCreateWithNativeHandle(
    pi_native_handle nativeHandle, pi_context *context);




__attribute__((visibility("default"))) pi_result piQueueCreate(pi_context context, pi_device device,
                                      pi_queue_properties properties,
                                      pi_queue *queue);

__attribute__((visibility("default"))) pi_result piQueueGetInfo(pi_queue command_queue,
                                       pi_queue_info param_name,
                                       size_t param_value_size,
                                       void *param_value,
                                       size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piQueueRetain(pi_queue command_queue);

__attribute__((visibility("default"))) pi_result piQueueRelease(pi_queue command_queue);

__attribute__((visibility("default"))) pi_result piQueueFinish(pi_queue command_queue);





__attribute__((visibility("default"))) pi_result
piextQueueGetNativeHandle(pi_queue queue, pi_native_handle *nativeHandle);







__attribute__((visibility("default"))) pi_result piextQueueCreateWithNativeHandle(
    pi_native_handle nativeHandle, pi_context context, pi_queue *queue);




__attribute__((visibility("default"))) pi_result piMemBufferCreate(
    pi_context context, pi_mem_flags flags, size_t size, void *host_ptr,
    pi_mem *ret_mem, const cl_mem_properties_intel *properties = nullptr);

__attribute__((visibility("default"))) pi_result piMemImageCreate(pi_context context, pi_mem_flags flags,
                                         const pi_image_format *image_format,
                                         const pi_image_desc *image_desc,
                                         void *host_ptr, pi_mem *ret_mem);

__attribute__((visibility("default"))) pi_result piMemGetInfo(
    pi_mem mem,
    cl_mem_info param_name,
    size_t param_value_size, void *param_value, size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piMemImageGetInfo(pi_mem image,
                                          pi_image_info param_name,
                                          size_t param_value_size,
                                          void *param_value,
                                          size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piMemRetain(pi_mem mem);

__attribute__((visibility("default"))) pi_result piMemRelease(pi_mem mem);

__attribute__((visibility("default"))) pi_result piMemBufferPartition(
    pi_mem buffer, pi_mem_flags flags, pi_buffer_create_type buffer_create_type,
    void *buffer_create_info, pi_mem *ret_mem);





__attribute__((visibility("default"))) pi_result piextMemGetNativeHandle(pi_mem mem,
                                                pi_native_handle *nativeHandle);






__attribute__((visibility("default"))) pi_result
piextMemCreateWithNativeHandle(pi_native_handle nativeHandle, pi_mem *mem);





__attribute__((visibility("default"))) pi_result piProgramCreate(pi_context context, const void *il,
                                        size_t length, pi_program *res_program);

__attribute__((visibility("default"))) pi_result piclProgramCreateWithSource(pi_context context,
                                                    pi_uint32 count,
                                                    const char **strings,
                                                    const size_t *lengths,
                                                    pi_program *ret_program);

__attribute__((visibility("default"))) pi_result piProgramCreateWithBinary(
    pi_context context, pi_uint32 num_devices, const pi_device *device_list,
    const size_t *lengths, const unsigned char **binaries,
    pi_int32 *binary_status, pi_program *ret_program);

__attribute__((visibility("default"))) pi_result piProgramGetInfo(pi_program program,
                                         pi_program_info param_name,
                                         size_t param_value_size,
                                         void *param_value,
                                         size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result
piProgramLink(pi_context context, pi_uint32 num_devices,
              const pi_device *device_list, const char *options,
              pi_uint32 num_input_programs, const pi_program *input_programs,
              void (*pfn_notify)(pi_program program, void *user_data),
              void *user_data, pi_program *ret_program);

__attribute__((visibility("default"))) pi_result piProgramCompile(
    pi_program program, pi_uint32 num_devices, const pi_device *device_list,
    const char *options, pi_uint32 num_input_headers,
    const pi_program *input_headers, const char **header_include_names,
    void (*pfn_notify)(pi_program program, void *user_data), void *user_data);

__attribute__((visibility("default"))) pi_result piProgramBuild(
    pi_program program, pi_uint32 num_devices, const pi_device *device_list,
    const char *options,
    void (*pfn_notify)(pi_program program, void *user_data), void *user_data);

__attribute__((visibility("default"))) pi_result piProgramGetBuildInfo(
    pi_program program, pi_device device,
    cl_program_build_info param_name,
    size_t param_value_size, void *param_value, size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piProgramRetain(pi_program program);

__attribute__((visibility("default"))) pi_result piProgramRelease(pi_program program);







__attribute__((visibility("default"))) pi_result
piextProgramSetSpecializationConstant(pi_program prog, pi_uint32 spec_id,
                                      size_t spec_size, const void *spec_value);





__attribute__((visibility("default"))) pi_result
piextProgramGetNativeHandle(pi_program program, pi_native_handle *nativeHandle);







__attribute__((visibility("default"))) pi_result piextProgramCreateWithNativeHandle(
    pi_native_handle nativeHandle, pi_context context, pi_program *program);





typedef enum {

  PI_USM_INDIRECT_ACCESS,

  PI_USM_PTRS = 0x4203
} _pi_kernel_exec_info;

using pi_kernel_exec_info = _pi_kernel_exec_info;

__attribute__((visibility("default"))) pi_result piKernelCreate(pi_program program,
                                       const char *kernel_name,
                                       pi_kernel *ret_kernel);

__attribute__((visibility("default"))) pi_result piKernelSetArg(pi_kernel kernel, pi_uint32 arg_index,
                                       size_t arg_size, const void *arg_value);

__attribute__((visibility("default"))) pi_result piKernelGetInfo(pi_kernel kernel,
                                        pi_kernel_info param_name,
                                        size_t param_value_size,
                                        void *param_value,
                                        size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piKernelGetGroupInfo(pi_kernel kernel, pi_device device,
                                             pi_kernel_group_info param_name,
                                             size_t param_value_size,
                                             void *param_value,
                                             size_t *param_value_size_ret);
# 1116 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piKernelGetSubGroupInfo(
    pi_kernel kernel, pi_device device, pi_kernel_sub_group_info param_name,
    size_t input_value_size, const void *input_value, size_t param_value_size,
    void *param_value, size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piKernelRetain(pi_kernel kernel);

__attribute__((visibility("default"))) pi_result piKernelRelease(pi_kernel kernel);
# 1132 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextKernelSetArgPointer(pi_kernel kernel,
                                                 pi_uint32 arg_index,
                                                 size_t arg_size,
                                                 const void *arg_value);
# 1148 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piKernelSetExecInfo(pi_kernel kernel,
                                            pi_kernel_exec_info value_name,
                                            size_t param_value_size,
                                            const void *param_value);




__attribute__((visibility("default"))) pi_result piEventCreate(pi_context context, pi_event *ret_event);

__attribute__((visibility("default"))) pi_result piEventGetInfo(pi_event event, pi_event_info param_name,
                                       size_t param_value_size,
                                       void *param_value,
                                       size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piEventGetProfilingInfo(pi_event event,
                                                pi_profiling_info param_name,
                                                size_t param_value_size,
                                                void *param_value,
                                                size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piEventsWait(pi_uint32 num_events,
                                     const pi_event *event_list);

__attribute__((visibility("default"))) pi_result piEventSetCallback(
    pi_event event, pi_int32 command_exec_callback_type,
    void (*pfn_notify)(pi_event event, pi_int32 event_command_status,
                       void *user_data),
    void *user_data);

__attribute__((visibility("default"))) pi_result piEventSetStatus(pi_event event,
                                         pi_int32 execution_status);

__attribute__((visibility("default"))) pi_result piEventRetain(pi_event event);

__attribute__((visibility("default"))) pi_result piEventRelease(pi_event event);





__attribute__((visibility("default"))) pi_result
piextEventGetNativeHandle(pi_event event, pi_native_handle *nativeHandle);






__attribute__((visibility("default"))) pi_result piextEventCreateWithNativeHandle(
    pi_native_handle nativeHandle, pi_event *event);




__attribute__((visibility("default"))) pi_result piSamplerCreate(
    pi_context context, const pi_sampler_properties *sampler_properties,
    pi_sampler *result_sampler);

__attribute__((visibility("default"))) pi_result piSamplerGetInfo(pi_sampler sampler,
                                         pi_sampler_info param_name,
                                         size_t param_value_size,
                                         void *param_value,
                                         size_t *param_value_size_ret);

__attribute__((visibility("default"))) pi_result piSamplerRetain(pi_sampler sampler);

__attribute__((visibility("default"))) pi_result piSamplerRelease(pi_sampler sampler);




__attribute__((visibility("default"))) pi_result piEnqueueKernelLaunch(
    pi_queue queue, pi_kernel kernel, pi_uint32 work_dim,
    const size_t *global_work_offset, const size_t *global_work_size,
    const size_t *local_work_size, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueNativeKernel(
    pi_queue queue, void (*user_func)(void *), void *args, size_t cb_args,
    pi_uint32 num_mem_objects, const pi_mem *mem_list,
    const void **args_mem_loc, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueEventsWait(pi_queue command_queue,
                                            pi_uint32 num_events_in_wait_list,
                                            const pi_event *event_wait_list,
                                            pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueEventsWaitWithBarrier(
    pi_queue command_queue, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemBufferRead(
    pi_queue queue, pi_mem buffer, pi_bool blocking_read, size_t offset,
    size_t size, void *ptr, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemBufferReadRect(
    pi_queue command_queue, pi_mem buffer, pi_bool blocking_read,
    const size_t *buffer_offset, const size_t *host_offset,
    const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch,
    size_t host_row_pitch, size_t host_slice_pitch, void *ptr,
    pi_uint32 num_events_in_wait_list, const pi_event *event_wait_list,
    pi_event *event);

__attribute__((visibility("default"))) pi_result
piEnqueueMemBufferWrite(pi_queue command_queue, pi_mem buffer,
                        pi_bool blocking_write, size_t offset, size_t size,
                        const void *ptr, pi_uint32 num_events_in_wait_list,
                        const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemBufferWriteRect(
    pi_queue command_queue, pi_mem buffer, pi_bool blocking_write,
    const size_t *buffer_offset, const size_t *host_offset,
    const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch,
    size_t host_row_pitch, size_t host_slice_pitch, const void *ptr,
    pi_uint32 num_events_in_wait_list, const pi_event *event_wait_list,
    pi_event *event);

__attribute__((visibility("default"))) pi_result
piEnqueueMemBufferCopy(pi_queue command_queue, pi_mem src_buffer,
                       pi_mem dst_buffer, size_t src_offset, size_t dst_offset,
                       size_t size, pi_uint32 num_events_in_wait_list,
                       const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemBufferCopyRect(
    pi_queue command_queue, pi_mem src_buffer, pi_mem dst_buffer,
    const size_t *src_origin, const size_t *dst_origin, const size_t *region,
    size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch,
    size_t dst_slice_pitch, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result
piEnqueueMemBufferFill(pi_queue command_queue, pi_mem buffer,
                       const void *pattern, size_t pattern_size, size_t offset,
                       size_t size, pi_uint32 num_events_in_wait_list,
                       const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemImageRead(
    pi_queue command_queue, pi_mem image, pi_bool blocking_read,
    const size_t *origin, const size_t *region, size_t row_pitch,
    size_t slice_pitch, void *ptr, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemImageWrite(
    pi_queue command_queue, pi_mem image, pi_bool blocking_write,
    const size_t *origin, const size_t *region, size_t input_row_pitch,
    size_t input_slice_pitch, const void *ptr,
    pi_uint32 num_events_in_wait_list, const pi_event *event_wait_list,
    pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemImageCopy(
    pi_queue command_queue, pi_mem src_image, pi_mem dst_image,
    const size_t *src_origin, const size_t *dst_origin, const size_t *region,
    pi_uint32 num_events_in_wait_list, const pi_event *event_wait_list,
    pi_event *event);

__attribute__((visibility("default"))) pi_result
piEnqueueMemImageFill(pi_queue command_queue, pi_mem image,
                      const void *fill_color, const size_t *origin,
                      const size_t *region, pi_uint32 num_events_in_wait_list,
                      const pi_event *event_wait_list, pi_event *event);

__attribute__((visibility("default"))) pi_result piEnqueueMemBufferMap(
    pi_queue command_queue, pi_mem buffer, pi_bool blocking_map,
    cl_map_flags map_flags,
    size_t offset, size_t size, pi_uint32 num_events_in_wait_list,
    const pi_event *event_wait_list, pi_event *event, void **ret_map);

__attribute__((visibility("default"))) pi_result piEnqueueMemUnmap(pi_queue command_queue, pi_mem memobj,
                                          void *mapped_ptr,
                                          pi_uint32 num_events_in_wait_list,
                                          const pi_event *event_wait_list,
                                          pi_event *event);





__attribute__((visibility("default"))) pi_result piextKernelSetArgMemObj(pi_kernel kernel,
                                                pi_uint32 arg_index,
                                                const pi_mem *arg_value);





__attribute__((visibility("default"))) pi_result piextKernelSetArgSampler(pi_kernel kernel,
                                                 pi_uint32 arg_index,
                                                 const pi_sampler *arg_value);




typedef enum {
  PI_USM_HOST_SUPPORT = 0x4190,
  PI_USM_DEVICE_SUPPORT = 0x4191,
  PI_USM_SINGLE_SHARED_SUPPORT =
      0x4192,
  PI_USM_CROSS_SHARED_SUPPORT =
      0x4193,
  PI_USM_SYSTEM_SHARED_SUPPORT = 0x4194
} _pi_usm_capability_query;

typedef enum : pi_bitfield {
  PI_USM_ACCESS = (1 << 0),
  PI_USM_ATOMIC_ACCESS = (1 << 1),
  PI_USM_CONCURRENT_ACCESS = (1 << 2),
  PI_USM_CONCURRENT_ATOMIC_ACCESS =
      (1 << 3)
} _pi_usm_capabilities;

typedef enum {
  PI_MEM_ALLOC_TYPE = 0x419A,
  PI_MEM_ALLOC_BASE_PTR = 0x419B,
  PI_MEM_ALLOC_SIZE = 0x419C,
  PI_MEM_ALLOC_DEVICE = 0x419D,
} _pi_mem_info;

typedef enum {
  PI_MEM_TYPE_UNKNOWN = 0x4196,
  PI_MEM_TYPE_HOST = 0x4197,
  PI_MEM_TYPE_DEVICE = 0x4198,
  PI_MEM_TYPE_SHARED = 0x4199
} _pi_usm_type;

typedef enum : pi_bitfield {
  PI_MEM_ALLOC_FLAGS = 0x4195
} _pi_usm_mem_properties;

typedef enum : pi_bitfield {
  PI_USM_MIGRATION_TBD0 = (1 << 0)
} _pi_usm_migration_flags;

using pi_usm_capability_query = _pi_usm_capability_query;
using pi_usm_capabilities = _pi_usm_capabilities;
using pi_mem_info = _pi_mem_info;
using pi_usm_type = _pi_usm_type;
using pi_usm_mem_properties = _pi_usm_mem_properties;
using pi_usm_migration_flags = _pi_usm_migration_flags;
# 1397 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMHostAlloc(void **result_ptr, pi_context context,
                                          pi_usm_mem_properties *properties,
                                          size_t size, pi_uint32 alignment);
# 1409 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMDeviceAlloc(void **result_ptr,
                                            pi_context context,
                                            pi_device device,
                                            pi_usm_mem_properties *properties,
                                            size_t size, pi_uint32 alignment);
# 1423 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMSharedAlloc(void **result_ptr,
                                            pi_context context,
                                            pi_device device,
                                            pi_usm_mem_properties *properties,
                                            size_t size, pi_uint32 alignment);





__attribute__((visibility("default"))) pi_result piextUSMFree(pi_context context, void *ptr);
# 1446 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMEnqueueMemset(pi_queue queue, void *ptr,
                                              pi_int32 value, size_t count,
                                              pi_uint32 num_events_in_waitlist,
                                              const pi_event *events_waitlist,
                                              pi_event *event);
# 1462 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMEnqueueMemcpy(pi_queue queue, pi_bool blocking,
                                              void *dst_ptr,
                                              const void *src_ptr, size_t size,
                                              pi_uint32 num_events_in_waitlist,
                                              const pi_event *events_waitlist,
                                              pi_event *event);
# 1478 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMEnqueuePrefetch(
    pi_queue queue, const void *ptr, size_t size, pi_usm_migration_flags flags,
    pi_uint32 num_events_in_waitlist, const pi_event *events_waitlist,
    pi_event *event);
# 1491 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMEnqueueMemAdvise(pi_queue queue,
                                                 const void *ptr, size_t length,
                                                 pi_mem_advice advice,
                                                 pi_event *event);
# 1512 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 3
__attribute__((visibility("default"))) pi_result piextUSMGetMemAllocInfo(
    pi_context context, const void *ptr, pi_mem_info param_name,
    size_t param_value_size, void *param_value, size_t *param_value_size_ret);

struct _pi_plugin {







  char PiVersion[4];

  char PluginVersion[4];
  char *Targets;
  struct FunctionPointers {


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.def" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.def" 3
decltype(::piPlatformsGet) *piPlatformsGet;
decltype(::piPlatformGetInfo) *piPlatformGetInfo;
decltype(::piextPlatformGetNativeHandle) *piextPlatformGetNativeHandle;
decltype(::piextPlatformCreateWithNativeHandle) *piextPlatformCreateWithNativeHandle;

decltype(::piDevicesGet) *piDevicesGet;
decltype(::piDeviceGetInfo) *piDeviceGetInfo;
decltype(::piDevicePartition) *piDevicePartition;
decltype(::piDeviceRetain) *piDeviceRetain;
decltype(::piDeviceRelease) *piDeviceRelease;
decltype(::piextDeviceSelectBinary) *piextDeviceSelectBinary;
decltype(::piextGetDeviceFunctionPointer) *piextGetDeviceFunctionPointer;
decltype(::piextDeviceGetNativeHandle) *piextDeviceGetNativeHandle;
decltype(::piextDeviceCreateWithNativeHandle) *piextDeviceCreateWithNativeHandle;

decltype(::piContextCreate) *piContextCreate;
decltype(::piContextGetInfo) *piContextGetInfo;
decltype(::piContextRetain) *piContextRetain;
decltype(::piContextRelease) *piContextRelease;
decltype(::piextContextSetExtendedDeleter) *piextContextSetExtendedDeleter;
decltype(::piextContextGetNativeHandle) *piextContextGetNativeHandle;
decltype(::piextContextCreateWithNativeHandle) *piextContextCreateWithNativeHandle;

decltype(::piQueueCreate) *piQueueCreate;
decltype(::piQueueGetInfo) *piQueueGetInfo;
decltype(::piQueueFinish) *piQueueFinish;
decltype(::piQueueRetain) *piQueueRetain;
decltype(::piQueueRelease) *piQueueRelease;
decltype(::piextQueueGetNativeHandle) *piextQueueGetNativeHandle;
decltype(::piextQueueCreateWithNativeHandle) *piextQueueCreateWithNativeHandle;

decltype(::piMemBufferCreate) *piMemBufferCreate;
decltype(::piMemImageCreate) *piMemImageCreate;
decltype(::piMemGetInfo) *piMemGetInfo;
decltype(::piMemImageGetInfo) *piMemImageGetInfo;
decltype(::piMemRetain) *piMemRetain;
decltype(::piMemRelease) *piMemRelease;
decltype(::piMemBufferPartition) *piMemBufferPartition;
decltype(::piextMemGetNativeHandle) *piextMemGetNativeHandle;
decltype(::piextMemCreateWithNativeHandle) *piextMemCreateWithNativeHandle;

decltype(::piProgramCreate) *piProgramCreate;
decltype(::piclProgramCreateWithSource) *piclProgramCreateWithSource;
decltype(::piProgramCreateWithBinary) *piProgramCreateWithBinary;
decltype(::piProgramGetInfo) *piProgramGetInfo;
decltype(::piProgramCompile) *piProgramCompile;
decltype(::piProgramBuild) *piProgramBuild;
decltype(::piProgramLink) *piProgramLink;
decltype(::piProgramGetBuildInfo) *piProgramGetBuildInfo;
decltype(::piProgramRetain) *piProgramRetain;
decltype(::piProgramRelease) *piProgramRelease;
decltype(::piextProgramSetSpecializationConstant) *piextProgramSetSpecializationConstant;
decltype(::piextProgramGetNativeHandle) *piextProgramGetNativeHandle;
decltype(::piextProgramCreateWithNativeHandle) *piextProgramCreateWithNativeHandle;

decltype(::piKernelCreate) *piKernelCreate;
decltype(::piKernelSetArg) *piKernelSetArg;
decltype(::piKernelGetInfo) *piKernelGetInfo;
decltype(::piKernelGetGroupInfo) *piKernelGetGroupInfo;
decltype(::piKernelGetSubGroupInfo) *piKernelGetSubGroupInfo;
decltype(::piKernelRetain) *piKernelRetain;
decltype(::piKernelRelease) *piKernelRelease;
decltype(::piextKernelSetArgPointer) *piextKernelSetArgPointer;
decltype(::piKernelSetExecInfo) *piKernelSetExecInfo;

decltype(::piEventCreate) *piEventCreate;
decltype(::piEventGetInfo) *piEventGetInfo;
decltype(::piEventGetProfilingInfo) *piEventGetProfilingInfo;
decltype(::piEventsWait) *piEventsWait;
decltype(::piEventSetCallback) *piEventSetCallback;
decltype(::piEventSetStatus) *piEventSetStatus;
decltype(::piEventRetain) *piEventRetain;
decltype(::piEventRelease) *piEventRelease;
decltype(::piextEventGetNativeHandle) *piextEventGetNativeHandle;
decltype(::piextEventCreateWithNativeHandle) *piextEventCreateWithNativeHandle;

decltype(::piSamplerCreate) *piSamplerCreate;
decltype(::piSamplerGetInfo) *piSamplerGetInfo;
decltype(::piSamplerRetain) *piSamplerRetain;
decltype(::piSamplerRelease) *piSamplerRelease;

decltype(::piEnqueueKernelLaunch) *piEnqueueKernelLaunch;
decltype(::piEnqueueNativeKernel) *piEnqueueNativeKernel;
decltype(::piEnqueueEventsWait) *piEnqueueEventsWait;
decltype(::piEnqueueEventsWaitWithBarrier) *piEnqueueEventsWaitWithBarrier;
decltype(::piEnqueueMemBufferRead) *piEnqueueMemBufferRead;
decltype(::piEnqueueMemBufferReadRect) *piEnqueueMemBufferReadRect;
decltype(::piEnqueueMemBufferWrite) *piEnqueueMemBufferWrite;
decltype(::piEnqueueMemBufferWriteRect) *piEnqueueMemBufferWriteRect;
decltype(::piEnqueueMemBufferCopy) *piEnqueueMemBufferCopy;
decltype(::piEnqueueMemBufferCopyRect) *piEnqueueMemBufferCopyRect;
decltype(::piEnqueueMemBufferFill) *piEnqueueMemBufferFill;
decltype(::piEnqueueMemImageRead) *piEnqueueMemImageRead;
decltype(::piEnqueueMemImageWrite) *piEnqueueMemImageWrite;
decltype(::piEnqueueMemImageCopy) *piEnqueueMemImageCopy;
decltype(::piEnqueueMemImageFill) *piEnqueueMemImageFill;
decltype(::piEnqueueMemBufferMap) *piEnqueueMemBufferMap;
decltype(::piEnqueueMemUnmap) *piEnqueueMemUnmap;

decltype(::piextUSMHostAlloc) *piextUSMHostAlloc;
decltype(::piextUSMDeviceAlloc) *piextUSMDeviceAlloc;
decltype(::piextUSMSharedAlloc) *piextUSMSharedAlloc;
decltype(::piextUSMFree) *piextUSMFree;
decltype(::piextUSMEnqueueMemset) *piextUSMEnqueueMemset;
decltype(::piextUSMEnqueueMemcpy) *piextUSMEnqueueMemcpy;
decltype(::piextUSMEnqueuePrefetch) *piextUSMEnqueuePrefetch;
decltype(::piextUSMEnqueueMemAdvise) *piextUSMEnqueueMemAdvise;
decltype(::piextUSMGetMemAllocInfo) *piextUSMGetMemAllocInfo;

decltype(::piextKernelSetArgMemObj) *piextKernelSetArgMemObj;
decltype(::piextKernelSetArgSampler) *piextKernelSetArgSampler;
# 1531 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.h" 2 3
 } PiFunctionTable;
};


}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/exception.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stl.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stl.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 1 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/utility" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/utility" 3
# 69 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/utility" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_relops.h" 1 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
# 85 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }


  }

}
# 70 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/utility" 2 3








namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;
# 108 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/utility" 3
  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };



  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    struct __is_in_place_type_impl : false_type
    { };

  template<typename _Tp>
    struct __is_in_place_type_impl<in_place_type_t<_Tp>> : true_type
    { };

  template<typename _Tp>
    struct __is_in_place_type
      : public __is_in_place_type_impl<_Tp>
    { };


  template<typename _Tp>
    constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }

  template<typename _Tp>
    void as_const(const _Tp&&) = delete;




}
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/array" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/array" 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      constexpr iterator
      begin() noexcept
      { return iterator(data()); }

      constexpr const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      constexpr iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      constexpr const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      constexpr reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      constexpr reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      constexpr const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      constexpr const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      constexpr reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      constexpr reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      constexpr reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      constexpr pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      constexpr const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, typename... _Up>
    array(_Tp, _Up...)
      -> array<enable_if_t<(is_same_v<_Tp, _Up> && ...), _Tp>,
        1 + sizeof...(_Up)>;



  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uses_allocator.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  inline constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;


  template <typename _Tp, typename _Alloc>
    inline constexpr bool uses_allocator_v =
      uses_allocator<_Tp, _Alloc>::value;


  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),
          __ptr, std::forward<_Args>(__args)...);
    }


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/invoke.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<typename... _UTypes>
    tuple(_UTypes...) -> tuple<_UTypes...>;
  template<typename _T1, typename _T2>
    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template<typename _Alloc, typename _T1, typename _T2>
    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;



  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };


  template <typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;






  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  inline constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




  template <typename _Fn, typename _Tuple, size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)
    {
      return std::__invoke(std::forward<_Fn>(__f),
      std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }

  template <typename _Fn, typename _Tuple>
    constexpr decltype(auto)
    apply(_Fn&& __f, _Tuple&& __t)
    {
      using _Indices = make_index_sequence<tuple_size_v<decay_t<_Tuple>>>;
      return std::__apply_impl(std::forward<_Fn>(__f),
          std::forward<_Tuple>(__t),
          _Indices{});
    }



  template <typename _Tp, typename _Tuple, size_t... _Idx>
    constexpr _Tp
    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)
    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }

  template <typename _Tp, typename _Tuple>
    constexpr _Tp
    make_from_tuple(_Tuple&& __t)
    {
      return __make_from_tuple_impl<_Tp>(
        std::forward<_Tuple>(__t),
 make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{});
    }





}
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/refwrap.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/refwrap.h" 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)
      noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const
      noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const
      noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile
      noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile
      noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile noexcept (_NE)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes
    , bool _NE>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile noexcept (_NE)>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg1
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg1<_Tp,
         __void_t<typename _Tp::argument_type>>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg2
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg2<_Tp,
         __void_t<typename _Tp::first_argument_type,
           typename _Tp::second_argument_type>>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res(_T1) noexcept (_NE)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res(_T1, _T2) noexcept (_NE)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res(*)(_T1) noexcept (_NE)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) noexcept (_NE)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)() noexcept (_NE)>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) noexcept (_NE)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)() const noexcept (_NE)>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const noexcept (_NE)>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile noexcept (_NE)>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile noexcept (_NE)>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile noexcept (_NE)>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile noexcept (_NE)>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }




}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };







  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { ::new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      template<typename _Func,
        typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 432 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      function(const function& __x);
# 441 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      function(function&& __x) noexcept : _Function_base()
      {
 __x.swap(*this);
      }
# 462 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 479 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 497 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      function&
      operator=(function&& __x) noexcept
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 511 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 539 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 565 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      void swap(function& __x) noexcept
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 582 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 595 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      _Res operator()(_ArgTypes... __args) const;
# 608 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      const type_info& target_type() const noexcept;
# 621 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
      template<typename _Functor> _Functor* target() noexcept;

      template<typename _Functor> const _Functor* target() const noexcept;



    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };


  template<typename>
    struct __function_guide_helper
    { };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) & noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) const noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) const & noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename... _ArgTypes>
    function(_Res(*)(_ArgTypes...)) -> function<_Res(_ArgTypes...)>;

  template<typename _Functor, typename _Signature = typename
    __function_guide_helper<decltype(&_Functor::operator())>::type>
    function(_Functor) -> function<_Signature>;



  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 const function* __const_this = this;
 const _Functor* __func = __const_this->template target<_Functor>();
 return const_cast<_Functor*>(__func);
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return nullptr;
      }
# 762 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 780 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 801 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
    { __x.swap(__y); }


}
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/unordered_map" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/unordered_map" 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/unordered_map" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/aligned_buffer.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {



      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };






  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };

}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/unordered_map" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;



namespace __detail
{







  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    {
      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
      return __distance_fw(__first, __last, _Tag());
    }


  template <typename _Key, typename _Hash>
    struct __is_noexcept_hash : std::__bool_constant<
 noexcept(declval<const _Hash&>()(declval<const _Key&>()))>
    { };

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __value_alloc_type = typename __hashtable_alloc::__value_alloc_type;
      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
 : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       __value_alloc_type __a(_M_h._M_node_allocator());
       __value_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __value_alloc_traits::construct(__a, __node->_M_valptr(),
        std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    __node->~__node_type();
    __node_alloc_traits::deallocate(_M_h._M_node_allocator(),
        __node, 1);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
 : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
# 213 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 229 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base : _Hash_node_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
    {
      std::size_t _M_hash_code;

      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    noexcept
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    using __has_load_factor = std::true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };


  struct _Mask_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num & (__den - 1); }
  };


  constexpr
  inline std::size_t
  __clp2(std::size_t __n) noexcept
  {

    std::uint_fast64_t __x = __n;




    __x = __x - 1;
    __x = __x | (__x >> 1);
    __x = __x | (__x >> 2);
    __x = __x | (__x >> 4);
    __x = __x | (__x >> 8);
    __x = __x | (__x >>16);

    __x = __x | (__x >>32);

    return __x + 1;
  }



  struct _Power2_rehash_policy
  {
    using __has_load_factor = std::true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }



    std::size_t
    _M_next_bkt(std::size_t __n) noexcept
    {
      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == __n)
 __res <<= 1;

      if (__res == 0)
 __res = __max_bkt;

      if (__res == __max_bkt)



 _M_next_resize = std::size_t(-1);
      else
 _M_next_resize
   = __builtin_ceil(__res * (long double)_M_max_load_factor);

      return __res;
    }


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const noexcept
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) noexcept
    {
      if (__n_elt + __n_ins >= _M_next_resize)
 {
   long double __min_bkts = (__n_elt + __n_ins)
     / (long double)_M_max_load_factor;
   if (__min_bkts >= __n_bkt)
     return std::make_pair(true,
       _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,
      __n_bkt * _S_growth_factor)));

   _M_next_resize
     = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);
   return std::make_pair(false, 0);
 }
      else
 return std::make_pair(false, 0);
    }

    typedef std::size_t _State;

    _State
    _M_state() const noexcept
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state) noexcept
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };
# 652 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::tuple<const key_type&>(__k),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::forward_as_tuple(std::move(__k)),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    -> const mapped_type&
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&);

    public:
      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
      }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen);
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __unique_keys());
      }







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      __ireturn_type
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys(),
    std::forward<_Pair>(__v));
 }
   };

  template<typename _Policy>
    using __has_load_factor = typename _Policy::__has_load_factor;







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    typename =
      __detected_or_t<std::false_type, __has_load_factor, _RehashPolicy>>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits,
        std::false_type>
    {
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits,
   std::true_type>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_RehashPolicy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__builtin_ceil(__n / max_load_factor()));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _Tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return static_cast<const _Tp&>(__eboh); }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1157 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
      { return _M_ranged_hash()(__k, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
         (std::size_t)0)) )
      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_ranged_hash(), __x._M_ranged_hash());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }

      _Hash&
      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
    && noexcept(declval<const _H2&>()((__hash_code)0,
          (std::size_t)0)) )
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;


      _Hash_code_base() = default;
      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _M_h2()(__p->_M_hash_code, __n); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };





  template <typename _Key, typename _Value, typename _ExtractKey,
     typename _Equal, typename _HashCodeType,
     bool __cache_hash_code>
  struct _Equal_helper;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }
  };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
    { return __eq(__k, __extract(__n->_M_v())); }
  };



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != -1)
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
        _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 _M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() == __y._M_curr(); }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() != __y._M_curr(); }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __p,
        std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __p,
       std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
 : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1750 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
    using _EqualHelper = _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
     __hash_code, __hash_cached::value>;

  protected:
    _Hashtable_base() = default;
    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
         __k, __c, __n);
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_M_eq(), __x._M_eq());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_S_cget(*this); }

    _Equal&
    _M_eq() { return _EqualEBO::_S_get(*this); }
  };






  struct _Equality_base
  {
  protected:
    template<typename _Uiterator>
      static bool
      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
  };


  template<typename _Uiterator>
    bool
    _Equality_base::
    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
        _Uiterator __first2)
    {
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;

      _Uiterator __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));

      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
 {
   _Uiterator __tmp = __first1;
   while (__tmp != __it1 && !bool(*__tmp == *__it1))
     ++__tmp;


   if (__tmp != __it1)
     continue;

   std::ptrdiff_t __n2 = 0;
   for (__tmp = __first2; __tmp != __last2; ++__tmp)
     if (*__tmp == *__it1)
       ++__n2;

   if (!__n2)
     return false;

   std::ptrdiff_t __n1 = 0;
   for (__tmp = __it1; __tmp != __last1; ++__tmp)
     if (*__tmp == *__it1)
       ++__n1;

   if (__n1 != __n2)
     return false;
 }
      return true;
    }
# 1899 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   const auto __ity = __other.find(_ExtractKey()(*__itx));
   if (__ity == __other.end() || !bool(*__ity == *__itx))
     return false;
 }
      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    : public _Equality_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
   const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));

   if (std::distance(__xrange.first, __xrange.second)
       != std::distance(__yrange.first, __yrange.second))
     return false;

   if (!_S_is_permutation(__xrange.first, __xrange.second,
     __yrange.first))
     return false;

   __itx = __xrange.second;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_type = typename __node_type::value_type;
      using __value_alloc_type =
 __alloc_rebind<__node_alloc_type, __value_type>;
      using __value_alloc_traits = std::allocator_traits<__value_alloc_type>;

      using __node_base = __detail::_Hash_node_base;
      using __bucket_type = __node_base*;
      using __bucket_alloc_type =
 __alloc_rebind<__node_alloc_type, __bucket_type>;
      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
   : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_S_get(*this); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_S_cget(*this); }

      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);

      void
      _M_deallocate_node(__node_type* __n);


      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(std::size_t __n);

      void
      _M_deallocate_buckets(__bucket_type*, std::size_t __n);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      typename _Hashtable_alloc<_NodeAlloc>::__node_type*
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_type* __n = std::__addressof(*__nptr);
 try
   {
     __value_alloc_type __a(_M_node_allocator());
     ::new ((void*)__n) __node_type;
     __value_alloc_traits::construct(__a, __n->_M_valptr(),
         std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __value_alloc_type __a(_M_node_allocator());
      __value_alloc_traits::destroy(__a, __n->_M_valptr());
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)
    {
      __bucket_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
      __bucket_type* __p = std::__addressof(*__ptr);
      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
       std::size_t __n)
    {
      typedef typename __bucket_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __bucket_alloc_type __alloc(_M_node_allocator());
      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);
    }



}
}
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/node_handle.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/node_handle.h" 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/optional" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/optional" 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/optional" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/enable_special_members.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/enable_special_members.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct _Enable_default_constructor_tag
  {
    explicit constexpr _Enable_default_constructor_tag() = default;
  };






template<bool _Switch, typename _Tag = void>
  struct _Enable_default_constructor
  {
    constexpr _Enable_default_constructor() noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };







template<bool _Switch, typename _Tag = void>
  struct _Enable_destructor { };






template<bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_copy_move { };
# 93 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/enable_special_members.h" 3
template<bool _Default, bool _Destructor,
         bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_special_members
  : private _Enable_default_constructor<_Default, _Tag>,
    private _Enable_destructor<_Destructor, _Tag>,
    private _Enable_copy_move<_Copy, _CopyAssignment,
                              _Move, _MoveAssignment,
                              _Tag>
  { };



template<typename _Tag>
  struct _Enable_default_constructor<false, _Tag>
  {
    constexpr _Enable_default_constructor() noexcept = delete;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };

template<typename _Tag>
  struct _Enable_destructor<false, _Tag>
  { ~_Enable_destructor() noexcept = delete; };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };


}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/optional" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 56 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/optional" 3
  template<typename _Tp>
    class optional;


  struct nullopt_t
  {





    enum class _Construct { _Token };


    explicit constexpr nullopt_t(_Construct) { }
  };


  inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };






  class bad_optional_access : public exception
  {
  public:
    bad_optional_access() { }
    virtual const char* what() const noexcept override
    {return "bad optional access";}

    virtual ~bad_optional_access() noexcept = default;
  };

  void
  __throw_bad_optional_access()
  __attribute__((__noreturn__));


  inline void
  __throw_bad_optional_access()
  { (throw (bad_optional_access())); }



  template <typename _Tp,
     bool =
       is_trivially_copy_constructible<_Tp>::value
       && is_trivially_move_constructible<_Tp>::value,
     bool =
       is_trivially_destructible<_Tp>::value>
    struct _Optional_payload
    {
      constexpr _Optional_payload()
 : _M_empty() {}

      template<typename... _Args>
      constexpr _Optional_payload(in_place_t, _Args&&... __args)
 : _M_payload(std::forward<_Args>(__args)...),
   _M_engaged(true)
      {}

      template<typename _Up, typename... _Args>
      constexpr _Optional_payload(std::initializer_list<_Up> __il,
      _Args&&... __args)
 : _M_payload(__il, std::forward<_Args>(__args)...),
   _M_engaged(true) {}

      template <class _Up> struct __ctor_tag {};

      constexpr _Optional_payload(__ctor_tag<bool>,
      const _Tp& __other)
 : _M_payload(__other),
   _M_engaged(true)
      {}

      constexpr _Optional_payload(__ctor_tag<void>)
 : _M_empty()
      {}

      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)
 : _M_payload(std::move(__other)),
   _M_engaged(true)
      {}

      constexpr _Optional_payload(bool __engaged,
      const _Optional_payload& __other)
 : _Optional_payload(__engaged ?
       _Optional_payload(__ctor_tag<bool>{},
           __other._M_payload) :
       _Optional_payload(__ctor_tag<void>{}))
      {}

      constexpr _Optional_payload(bool __engaged,
      _Optional_payload&& __other)
 : _Optional_payload(__engaged
       ? _Optional_payload(__ctor_tag<bool>{},
      std::move(__other._M_payload))
       : _Optional_payload(__ctor_tag<void>{}))
      {}

      using _Stored_type = remove_const_t<_Tp>;
      struct _Empty_byte { };
      union {
          _Empty_byte _M_empty;
          _Stored_type _M_payload;
      };
      bool _M_engaged = false;
    };


  template <typename _Tp>
    struct _Optional_payload<_Tp, false, false>
    {
      constexpr _Optional_payload()
 : _M_empty() {}

      template <typename... _Args>
      constexpr _Optional_payload(in_place_t, _Args&&... __args)
 : _M_payload(std::forward<_Args>(__args)...),
   _M_engaged(true) {}

      template<typename _Up, typename... _Args>
      constexpr _Optional_payload(std::initializer_list<_Up> __il,
      _Args&&... __args)
 : _M_payload(__il, std::forward<_Args>(__args)...),
   _M_engaged(true) {}
      constexpr
      _Optional_payload(bool __engaged, const _Optional_payload& __other)
 : _Optional_payload(__other)
      {}

      constexpr
      _Optional_payload(bool __engaged, _Optional_payload&& __other)
 : _Optional_payload(std::move(__other))
      {}

      constexpr _Optional_payload(const _Optional_payload& __other)
      {
 if (__other._M_engaged)
   this->_M_construct(__other._M_payload);
      }

      constexpr _Optional_payload(_Optional_payload&& __other)
      {
 if (__other._M_engaged)
   this->_M_construct(std::move(__other._M_payload));
      }

      using _Stored_type = remove_const_t<_Tp>;
      struct _Empty_byte { };
      union {
          _Empty_byte _M_empty;
          _Stored_type _M_payload;
      };
      bool _M_engaged = false;

      ~_Optional_payload()
      {
        if (_M_engaged)
          _M_payload.~_Stored_type();
      }

      template<typename... _Args>
        void
        _M_construct(_Args&&... __args)
        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())
        {
          ::new ((void *) std::__addressof(this->_M_payload))
            _Stored_type(std::forward<_Args>(__args)...);
          this->_M_engaged = true;
        }
    };


  template <typename _Tp>
    struct _Optional_payload<_Tp, false, true>
    {
      constexpr _Optional_payload()
 : _M_empty() {}

      template <typename... _Args>
      constexpr _Optional_payload(in_place_t, _Args&&... __args)
 : _M_payload(std::forward<_Args>(__args)...),
   _M_engaged(true) {}

      template<typename _Up, typename... _Args>
      constexpr _Optional_payload(std::initializer_list<_Up> __il,
      _Args&&... __args)
 : _M_payload(__il, std::forward<_Args>(__args)...),
   _M_engaged(true) {}
      constexpr
      _Optional_payload(bool __engaged, const _Optional_payload& __other)
 : _Optional_payload(__other)
      {}

      constexpr
      _Optional_payload(bool __engaged, _Optional_payload&& __other)
 : _Optional_payload(std::move(__other))
      {}

      constexpr _Optional_payload(const _Optional_payload& __other)
      {
 if (__other._M_engaged)
   this->_M_construct(__other._M_payload);
      }

      constexpr _Optional_payload(_Optional_payload&& __other)
      {
 if (__other._M_engaged)
   this->_M_construct(std::move(__other._M_payload));
      }

      using _Stored_type = remove_const_t<_Tp>;
      struct _Empty_byte { };
      union {
          _Empty_byte _M_empty;
          _Stored_type _M_payload;
      };
      bool _M_engaged = false;

      template<typename... _Args>
        void
        _M_construct(_Args&&... __args)
        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())
        {
          ::new ((void *) std::__addressof(this->_M_payload))
            _Stored_type(std::forward<_Args>(__args)...);
          this->_M_engaged = true;
        }
    };
# 301 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/optional" 3
  template<typename _Tp>
    class _Optional_base
    {
    private:



      using _Stored_type = remove_const_t<_Tp>;

    public:


      constexpr _Optional_base() noexcept
      { }

      constexpr _Optional_base(nullopt_t) noexcept
      { }


      template<typename... _Args,
        enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
       std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
           initializer_list<_Up>&,
           _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t,
                                          initializer_list<_Up> __il,
                                          _Args&&... __args)
        : _M_payload(in_place,
       __il, std::forward<_Args>(__args)...)
        { }


      constexpr _Optional_base(const _Optional_base& __other)
 : _M_payload(__other._M_payload._M_engaged,
       __other._M_payload)
      { }

      constexpr _Optional_base(_Optional_base&& __other)
      noexcept(is_nothrow_move_constructible<_Tp>())
 : _M_payload(__other._M_payload._M_engaged,
       std::move(__other._M_payload))
      { }


      _Optional_base&
      operator=(const _Optional_base& __other)
      {
        if (this->_M_payload._M_engaged && __other._M_payload._M_engaged)
          this->_M_get() = __other._M_get();
        else
   {
     if (__other._M_payload._M_engaged)
       this->_M_construct(__other._M_get());
     else
       this->_M_reset();
   }

        return *this;
      }

      _Optional_base&
      operator=(_Optional_base&& __other)
      noexcept(__and_<is_nothrow_move_constructible<_Tp>,
        is_nothrow_move_assignable<_Tp>>())
      {
 if (this->_M_payload._M_engaged && __other._M_payload._M_engaged)
   this->_M_get() = std::move(__other._M_get());
 else
   {
     if (__other._M_payload._M_engaged)
       this->_M_construct(std::move(__other._M_get()));
     else
       this->_M_reset();
   }
 return *this;
      }


    protected:
      constexpr bool _M_is_engaged() const noexcept
      { return this->_M_payload._M_engaged; }


      constexpr _Tp&
      _M_get() noexcept
      { return this->_M_payload._M_payload; }

      constexpr const _Tp&
      _M_get() const noexcept
      { return this->_M_payload._M_payload; }



      template<typename... _Args>
        void
        _M_construct(_Args&&... __args)
        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())
        {
          ::new (std::__addressof(this->_M_payload._M_payload))
            _Stored_type(std::forward<_Args>(__args)...);
          this->_M_payload._M_engaged = true;
        }

      void
      _M_destruct()
      {
        this->_M_payload._M_engaged = false;
        this->_M_payload._M_payload.~_Stored_type();
      }


      void
      _M_reset()
      {
        if (this->_M_payload._M_engaged)
          this->_M_destruct();
      }

    private:
      _Optional_payload<_Tp> _M_payload;
    };

  template<typename _Tp>
  class optional;

  template<typename _Tp, typename _Up>
    using __converts_from_optional =
      __or_<is_constructible<_Tp, const optional<_Up>&>,
     is_constructible<_Tp, optional<_Up>&>,
     is_constructible<_Tp, const optional<_Up>&&>,
     is_constructible<_Tp, optional<_Up>&&>,
     is_convertible<const optional<_Up>&, _Tp>,
     is_convertible<optional<_Up>&, _Tp>,
     is_convertible<const optional<_Up>&&, _Tp>,
     is_convertible<optional<_Up>&&, _Tp>>;

  template<typename _Tp, typename _Up>
    using __assigns_from_optional =
      __or_<is_assignable<_Tp&, const optional<_Up>&>,
     is_assignable<_Tp&, optional<_Up>&>,
     is_assignable<_Tp&, const optional<_Up>&&>,
     is_assignable<_Tp&, optional<_Up>&&>>;




  template<typename _Tp>
    class optional
    : private _Optional_base<_Tp>,
      private _Enable_copy_move<

        is_copy_constructible<_Tp>::value,

        __and_<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>::value,

        is_move_constructible<_Tp>::value,

        __and_<is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value,

        optional<_Tp>>
    {
      static_assert(__and_<__not_<is_same<remove_cv_t<_Tp>, nullopt_t>>,
      __not_<is_same<remove_cv_t<_Tp>, in_place_t>>,
      __not_<is_reference<_Tp>>>(),
                    "Invalid instantiation of optional<T>");

    private:
      using _Base = _Optional_base<_Tp>;

    public:
      using value_type = _Tp;

      constexpr optional() = default;

      constexpr optional(nullopt_t) noexcept
 : _Base(nullopt) { }


      template <typename _Up = _Tp,
                enable_if_t<__and_<
         __not_<is_same<optional<_Tp>, decay_t<_Up>>>,
         __not_<is_same<in_place_t, decay_t<_Up>>>,
         is_constructible<_Tp, _Up&&>,
         is_convertible<_Up&&, _Tp>
         >::value, bool> = true>
      constexpr optional(_Up&& __t)
        : _Base(std::in_place, std::forward<_Up>(__t)) { }

      template <typename _Up = _Tp,
                enable_if_t<__and_<
         __not_<is_same<optional<_Tp>, decay_t<_Up>>>,
         __not_<is_same<in_place_t, decay_t<_Up>>>,
         is_constructible<_Tp, _Up&&>,
         __not_<is_convertible<_Up&&, _Tp>>
         >::value, bool> = false>
      explicit constexpr optional(_Up&& __t)
        : _Base(std::in_place, std::forward<_Up>(__t)) { }

      template <typename _Up,
                enable_if_t<__and_<
       __not_<is_same<_Tp, _Up>>,
       is_constructible<_Tp, const _Up&>,
       is_convertible<const _Up&, _Tp>,
       __not_<__converts_from_optional<_Tp, _Up>>
       >::value, bool> = true>
      constexpr optional(const optional<_Up>& __t)
      {
 if (__t)
   emplace(*__t);
      }

      template <typename _Up,
                 enable_if_t<__and_<
          __not_<is_same<_Tp, _Up>>,
          is_constructible<_Tp, const _Up&>,
          __not_<is_convertible<const _Up&, _Tp>>,
          __not_<__converts_from_optional<_Tp, _Up>>
          >::value, bool> = false>
      explicit constexpr optional(const optional<_Up>& __t)
      {
 if (__t)
   emplace(*__t);
      }

      template <typename _Up,
                enable_if_t<__and_<
         __not_<is_same<_Tp, _Up>>,
         is_constructible<_Tp, _Up&&>,
         is_convertible<_Up&&, _Tp>,
         __not_<__converts_from_optional<_Tp, _Up>>
         >::value, bool> = true>
      constexpr optional(optional<_Up>&& __t)
      {
 if (__t)
   emplace(std::move(*__t));
      }

      template <typename _Up,
                enable_if_t<__and_<
       __not_<is_same<_Tp, _Up>>,
       is_constructible<_Tp, _Up&&>,
       __not_<is_convertible<_Up&&, _Tp>>,
       __not_<__converts_from_optional<_Tp, _Up>>
       >::value, bool> = false>
      explicit constexpr optional(optional<_Up>&& __t)
      {
 if (__t)
   emplace(std::move(*__t));
      }

      template<typename... _Args,
        enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
      explicit constexpr optional(in_place_t, _Args&&... __args)
        : _Base(std::in_place, std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
           initializer_list<_Up>&,
           _Args&&...>, bool> = false>
      explicit constexpr optional(in_place_t,
      initializer_list<_Up> __il,
      _Args&&... __args)
        : _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }


      optional&
      operator=(nullopt_t) noexcept
      {
        this->_M_reset();
        return *this;
      }

      template<typename _Up = _Tp>
        enable_if_t<__and_<
        __not_<is_same<optional<_Tp>, decay_t<_Up>>>,
        is_constructible<_Tp, _Up>,
        __not_<__and_<is_scalar<_Tp>,
        is_same<_Tp, decay_t<_Up>>>>,
        is_assignable<_Tp&, _Up>>::value,
      optional&>
        operator=(_Up&& __u)
        {
          if (this->_M_is_engaged())
            this->_M_get() = std::forward<_Up>(__u);
          else
            this->_M_construct(std::forward<_Up>(__u));

          return *this;
        }

      template<typename _Up>
 enable_if_t<__and_<
        __not_<is_same<_Tp, _Up>>,
        is_constructible<_Tp, const _Up&>,
        is_assignable<_Tp&, _Up>,
        __not_<__converts_from_optional<_Tp, _Up>>,
        __not_<__assigns_from_optional<_Tp, _Up>>
        >::value,
      optional&>
        operator=(const optional<_Up>& __u)
        {
          if (__u)
            {
              if (this->_M_is_engaged())
                this->_M_get() = *__u;
              else
                this->_M_construct(*__u);
            }
          else
            {
              this->_M_reset();
            }
          return *this;
        }

      template<typename _Up>
 enable_if_t<__and_<
        __not_<is_same<_Tp, _Up>>,
        is_constructible<_Tp, _Up>,
        is_assignable<_Tp&, _Up>,
        __not_<__converts_from_optional<_Tp, _Up>>,
        __not_<__assigns_from_optional<_Tp, _Up>>
        >::value,
      optional&>
        operator=(optional<_Up>&& __u)
        {
          if (__u)
            {
              if (this->_M_is_engaged())
                this->_M_get() = std::move(*__u);
              else
                this->_M_construct(std::move(*__u));
            }
          else
            {
              this->_M_reset();
            }

          return *this;
        }

      template<typename... _Args>
 enable_if_t<is_constructible<_Tp, _Args&&...>::value, _Tp&>
 emplace(_Args&&... __args)
 {
   this->_M_reset();
   this->_M_construct(std::forward<_Args>(__args)...);
   return this->_M_get();
 }

      template<typename _Up, typename... _Args>
 enable_if_t<is_constructible<_Tp, initializer_list<_Up>&,
         _Args&&...>::value, _Tp&>
 emplace(initializer_list<_Up> __il, _Args&&... __args)
 {
   this->_M_reset();
   this->_M_construct(__il, std::forward<_Args>(__args)...);
   return this->_M_get();
 }




      void
      swap(optional& __other)
      noexcept(is_nothrow_move_constructible<_Tp>()
               && is_nothrow_swappable_v<_Tp>)
      {
        using std::swap;

        if (this->_M_is_engaged() && __other._M_is_engaged())
          swap(this->_M_get(), __other._M_get());
        else if (this->_M_is_engaged())
   {
     __other._M_construct(std::move(this->_M_get()));
     this->_M_destruct();
   }
        else if (__other._M_is_engaged())
   {
     this->_M_construct(std::move(__other._M_get()));
     __other._M_destruct();
   }
      }


      constexpr const _Tp*
      operator->() const
      { return std::__addressof(this->_M_get()); }

      _Tp*
      operator->()
      { return std::__addressof(this->_M_get()); }

      constexpr const _Tp&
      operator*() const&
      { return this->_M_get(); }

      constexpr _Tp&
      operator*()&
      { return this->_M_get(); }

      constexpr _Tp&&
      operator*()&&
      { return std::move(this->_M_get()); }

      constexpr const _Tp&&
      operator*() const&&
      { return std::move(this->_M_get()); }

      constexpr explicit operator bool() const noexcept
      { return this->_M_is_engaged(); }

      constexpr bool has_value() const noexcept
      { return this->_M_is_engaged(); }

      constexpr const _Tp&
      value() const&
      {
 return this->_M_is_engaged()
   ? this->_M_get()
   : (__throw_bad_optional_access(),
      this->_M_get());
      }

      constexpr _Tp&
      value()&
      {
 return this->_M_is_engaged()
   ? this->_M_get()
   : (__throw_bad_optional_access(),
      this->_M_get());
      }

      constexpr _Tp&&
      value()&&
      {
 return this->_M_is_engaged()
   ? std::move(this->_M_get())
   : (__throw_bad_optional_access(),
      std::move(this->_M_get()));
      }

      constexpr const _Tp&&
      value() const&&
      {
 return this->_M_is_engaged()
   ? std::move(this->_M_get())
   : (__throw_bad_optional_access(),
      std::move(this->_M_get()));
      }

      template<typename _Up>
 constexpr _Tp
 value_or(_Up&& __u) const&
 {
   static_assert(__and_<is_copy_constructible<_Tp>,
          is_convertible<_Up&&, _Tp>>(),
   "Cannot return value");

   return this->_M_is_engaged()
     ? this->_M_get()
     : static_cast<_Tp>(std::forward<_Up>(__u));
 }

      template<typename _Up>
 _Tp
 value_or(_Up&& __u) &&
 {
   static_assert(__and_<is_move_constructible<_Tp>,
          is_convertible<_Up&&, _Tp>>(),
   "Cannot return value" );

   return this->_M_is_engaged()
     ? std::move(this->_M_get())
     : static_cast<_Tp>(std::forward<_Up>(__u));
 }
      void reset() noexcept { this->_M_reset(); }
    };

  template<typename _Tp>
    using __optional_relop_t =
    enable_if_t<is_convertible<_Tp, bool>::value, bool>;


  template<typename _Tp, typename _Up>
    constexpr auto
    operator==(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Up>())>
    {
      return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)
      && (!__lhs || *__lhs == *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator!=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Up>())>
    {
      return static_cast<bool>(__lhs) != static_cast<bool>(__rhs)
 || (static_cast<bool>(__lhs) && *__lhs != *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Up>())>
    {
      return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Up>())>
    {
      return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Up>())>
    {
      return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Up>())>
    {
      return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
    }


  template<typename _Tp>
    constexpr bool
    operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return !__lhs; }

  template<typename _Tp>
    constexpr bool
    operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return !__rhs; }

  template<typename _Tp>
    constexpr bool
    operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return static_cast<bool>(__lhs); }

  template<typename _Tp>
    constexpr bool
    operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return static_cast<bool>(__rhs); }

  template<typename _Tp>
    constexpr bool
    operator<(const optional<_Tp>& , nullopt_t) noexcept
    { return false; }

  template<typename _Tp>
    constexpr bool
    operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return static_cast<bool>(__rhs); }

  template<typename _Tp>
    constexpr bool
    operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return static_cast<bool>(__lhs); }

  template<typename _Tp>
    constexpr bool
    operator>(nullopt_t, const optional<_Tp>& ) noexcept
    { return false; }

  template<typename _Tp>
    constexpr bool
    operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return !__lhs; }

  template<typename _Tp>
    constexpr bool
    operator<=(nullopt_t, const optional<_Tp>& ) noexcept
    { return true; }

  template<typename _Tp>
    constexpr bool
    operator>=(const optional<_Tp>& , nullopt_t) noexcept
    { return true; }

  template<typename _Tp>
    constexpr bool
    operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return !__rhs; }


  template<typename _Tp, typename _Up>
    constexpr auto
    operator==(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Up>())>
    { return __lhs && *__lhs == __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator==(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() == declval<_Tp>())>
    { return __rhs && __lhs == *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator!=(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Up>())>
    { return !__lhs || *__lhs != __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator!=(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() != declval<_Tp>())>
    { return !__rhs || __lhs != *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Up>())>
    { return !__lhs || *__lhs < __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() < declval<_Tp>())>
    { return __rhs && __lhs < *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Up>())>
    { return __lhs && *__lhs > __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() > declval<_Tp>())>
    { return !__rhs || __lhs > *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<=(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Up>())>
    { return !__lhs || *__lhs <= __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<=(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() <= declval<_Tp>())>
    { return __rhs && __lhs <= *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>=(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Up>())>
    { return __lhs && *__lhs >= __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>=(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() >= declval<_Tp>())>
    { return !__rhs || __lhs >= *__rhs; }





  template<typename _Tp>
    inline enable_if_t<is_move_constructible_v<_Tp> && is_swappable_v<_Tp>>
    swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }

  template<typename _Tp>
    enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)>
    swap(optional<_Tp>&, optional<_Tp>&) = delete;

  template<typename _Tp>
    constexpr optional<decay_t<_Tp>>
    make_optional(_Tp&& __t)
    { return optional<decay_t<_Tp>> { std::forward<_Tp>(__t) }; }

  template<typename _Tp, typename ..._Args>
    constexpr optional<_Tp>
    make_optional(_Args&&... __args)
    { return optional<_Tp> { in_place, std::forward<_Args>(__args)... }; }

  template<typename _Tp, typename _Up, typename ..._Args>
    constexpr optional<_Tp>
    make_optional(initializer_list<_Up> __il, _Args&&... __args)
    { return optional<_Tp> { in_place, __il, std::forward<_Args>(__args)... }; }



  template<typename _Tp, typename _Up = remove_const_t<_Tp>,
           bool = __poison_hash<_Up>::__enable_hash_call>
    struct __optional_hash_call_base
    {
      size_t
      operator()(const optional<_Tp>& __t) const
      noexcept(noexcept(hash<_Up>{}(*__t)))
      {


        constexpr size_t __magic_disengaged_hash = static_cast<size_t>(-3333);
        return __t ? hash<_Up>{}(*__t) : __magic_disengaged_hash;
      }
    };

  template<typename _Tp, typename _Up>
    struct __optional_hash_call_base<_Tp, _Up, false> {};

  template<typename _Tp>
    struct hash<optional<_Tp>>
    : private __poison_hash<remove_const_t<_Tp>>,
      public __optional_hash_call_base<_Tp>
    {
      using result_type = size_t;
      using argument_type = optional<_Tp>;
    };




  template <typename _Tp> optional(_Tp) -> optional<_Tp>;



}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/node_handle.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Val, typename _NodeAlloc>
    class _Node_handle_common
    {
      using _AllocTraits = allocator_traits<_NodeAlloc>;

    public:
      using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;

      allocator_type
      get_allocator() const noexcept
      {
                                 ;
 return allocator_type(*_M_alloc);
      }

      explicit operator bool() const noexcept { return _M_ptr != nullptr; }

      bool empty() const noexcept { return _M_ptr == nullptr; }

    protected:
      constexpr _Node_handle_common() noexcept : _M_ptr(), _M_alloc() {}

      ~_Node_handle_common() { _M_destroy(); }

      _Node_handle_common(_Node_handle_common&& __nh) noexcept
      : _M_ptr(__nh._M_ptr), _M_alloc(std::move(__nh._M_alloc))
      {
 __nh._M_ptr = nullptr;
 __nh._M_alloc = nullopt;
      }

      _Node_handle_common&
      operator=(_Node_handle_common&& __nh) noexcept
      {
 _M_destroy();
 _M_ptr = __nh._M_ptr;
 if constexpr (is_move_assignable_v<_NodeAlloc>)
   {
     if (_AllocTraits::propagate_on_container_move_assignment::value
  || !this->_M_alloc)
       this->_M_alloc = std::move(__nh._M_alloc);
     else
                                                        ;
   }
 else
                             ;
 __nh._M_ptr = nullptr;
 __nh._M_alloc = nullopt;
 return *this;
      }

      _Node_handle_common(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _M_ptr(__ptr), _M_alloc(__alloc) { }

      void
      _M_swap(_Node_handle_common& __nh) noexcept
      {
 using std::swap;
 swap(_M_ptr, __nh._M_ptr);
 if (_AllocTraits::propagate_on_container_swap::value
     || !_M_alloc || !__nh._M_alloc)
   _M_alloc.swap(__nh._M_alloc);
 else
                                              ;
      }

    private:
      void
      _M_destroy() noexcept
      {
 if (_M_ptr != nullptr)
   {
     allocator_type __alloc(*_M_alloc);
     allocator_traits<allocator_type>::destroy(__alloc,
            _M_ptr->_M_valptr());
     _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);
   }
      }

    protected:
      typename _AllocTraits::pointer _M_ptr;
    private:
      optional<_NodeAlloc> _M_alloc;

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;
    };


  template<typename _Key, typename _Value, typename _NodeAlloc>
    class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using key_type = _Key;
      using mapped_type = typename _Value::second_type;

      key_type&
      key() const noexcept
      {
                                 ;
 return *_M_pkey;
      }

      mapped_type&
      mapped() const noexcept
      {
                                 ;
 return *_M_pmapped;
      }

      void
      swap(_Node_handle& __nh) noexcept
      {
 this->_M_swap(__nh);
 using std::swap;
 swap(_M_pkey, __nh._M_pkey);
 swap(_M_pmapped, __nh._M_pmapped);
      }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)
      {
 if (__ptr)
   {
     auto& __key = const_cast<_Key&>(__ptr->_M_valptr()->first);
     _M_pkey = _S_pointer_to(__key);
     _M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);
   }
 else
   {
     _M_pkey = nullptr;
     _M_pmapped = nullptr;
   }
      }

      template<typename _Tp>
 using __pointer
   = __ptr_rebind<typename _AllocTraits::pointer,
    remove_reference_t<_Tp>>;

      __pointer<_Key> _M_pkey = nullptr;
      __pointer<typename _Value::second_type> _M_pmapped = nullptr;

      template<typename _Tp>
 __pointer<_Tp>
 _S_pointer_to(_Tp& __obj)
 { return pointer_traits<__pointer<_Tp>>::pointer_to(__obj); }

      const key_type&
      _M_key() const noexcept { return key(); }

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _H1, typename _H2, typename _Hash,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Value, typename _NodeAlloc>
    class _Node_handle<_Value, _Value, _NodeAlloc>
    : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using value_type = _Value;

      value_type&
      value() const noexcept
      {
                                 ;
 return *this->_M_ptr->_M_valptr();
      }

      void
      swap(_Node_handle& __nh) noexcept
      { this->_M_swap(__nh); }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) { }

      const value_type&
      _M_key() const noexcept { return value(); }

      template<typename _Key, typename _Val, typename _KeyOfValue,
        typename _Compare, typename _Alloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _H1, typename _H2, typename _Hash,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Iterator, typename _NodeHandle>
    struct _Node_insert_return
    {
      _Iterator position = _Iterator();
      bool inserted = false;
      _NodeHandle node;
    };


}
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __detail::__is_noexcept_hash<_Tp, _Hash>>>;
# 169 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 __alloc_rebind<_Alloc,
         __detail::_Hash_node<_Value,
         _Traits::__hash_cached::value>>>
    {
      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __bucket_type = typename __hashtable_alloc::__bucket_type;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_type =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;


      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
        ._M_bucket_index((const __node_type*)nullptr,
           (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");






      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa>
 friend struct __detail::_Insert;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;


      using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;
      using insert_return_type = _Node_insert_return<iterator, node_type>;


    private:
      __bucket_type* _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __bucket_type _M_single_bucket = nullptr;

      bool
      _M_uses_single_bucket(__bucket_type* __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __bucket_type*
      _M_allocate_buckets(size_type __n)
      {
 if (__builtin_expect(__n == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__n);
      }

      void
      _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __n);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }

      template<typename _NodeGenerator>
 void
 _M_assign(const _Hashtable&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, std::true_type);

      void
      _M_move_assign(_Hashtable&&, std::false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
 : __hashtable_base(__exk, __h1, __h2, __h, __eq),
   __hashtable_alloc(__node_alloc_type(__a))
      { }

    public:

      _Hashtable() = default;
      _Hashtable(size_type __bucket_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bucket_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&&) noexcept;

      _Hashtable(const _Hashtable&, const allocator_type&);

      _Hashtable(_Hashtable&&, const allocator_type&);


      explicit
      _Hashtable(const allocator_type& __a)
 : __hashtable_alloc(__node_alloc_type(__a))
      { }

      explicit
      _Hashtable(size_type __n,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __n = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __n = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_H1>::value
        && is_nothrow_move_assignable<_Equal>::value)
      {
        constexpr bool __move_storage =
   __node_alloc_traits::_S_propagate_on_move_assign()
   || __node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_type __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();
 this->_M_insert_range(__l.begin(), __l.end(), __roan);
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__and_<__is_nothrow_swappable<_H1>,
                   __is_nothrow_swappable<_Equal>>::value);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __n) const
      { return std::distance(begin(__n), end(__n)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __n)
      {
 return local_iterator(*this, _M_bucket_begin(__n),
         __n, _M_bucket_count);
      }

      local_iterator
      end(size_type __n)
      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }

      const_local_iterator
      begin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy& __pol)
      { _M_rehash_policy = __pol; }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code __code,
       __node_type* __n);



      iterator
      _M_insert_multi_node(__node_type* __hint,
      __hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(std::true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(std::false_type __uk, _Args&&... __args)
 { return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)
 { return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::false_type, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, std::true_type);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    std::false_type __uk)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uk);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, std::true_type __uk)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, std::false_type);

      size_type
      _M_erase(std::true_type, const key_type&);

      size_type
      _M_erase(std::false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys(),
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;


      void rehash(size_type __n);






      insert_return_type
      _M_reinsert_node(node_type&& __nh)
      {
 insert_return_type __ret;
 if (__nh.empty())
   __ret.position = end();
 else
   {
                                                              ;

     const key_type& __k = __nh._M_key();
     __hash_code __code = this->_M_hash_code(__k);
     size_type __bkt = _M_bucket_index(__k, __code);
     if (__node_type* __n = _M_find_node(__bkt, __k, __code))
       {
  __ret.node = std::move(__nh);
  __ret.position = iterator(__n);
  __ret.inserted = false;
       }
     else
       {
  __ret.position
    = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);
  __nh._M_ptr = nullptr;
  __ret.inserted = true;
       }
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)
      {
 iterator __ret;
 if (__nh.empty())
   __ret = end();
 else
   {
                                                              ;

     auto __code = this->_M_hash_code(__nh._M_key());
     auto __node = std::exchange(__nh._M_ptr, nullptr);

     __ret = _M_insert_multi_node(__hint._M_cur, __code, __node);
   }
 return __ret;
      }


      node_type
      extract(const_iterator __pos)
      {
 __node_type* __n = __pos._M_cur;
 size_t __bkt = _M_bucket_index(__n);




 __node_base* __prev_n = _M_get_previous_node(__bkt, __n);

 if (__prev_n == _M_buckets[__bkt])
   _M_remove_bucket_begin(__bkt, __n->_M_next(),
      __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
 else if (__n->_M_nxt)
   {
     size_type __next_bkt = _M_bucket_index(__n->_M_next());
     if (__next_bkt != __bkt)
       _M_buckets[__next_bkt] = __prev_n;
   }

 __prev_n->_M_nxt = __n->_M_nxt;
 __n->_M_nxt = nullptr;
 --_M_element_count;
 return { __n, this->_M_node_allocator() };
      }


      node_type
      extract(const _Key& __k)
      {
 node_type __nh;
 auto __pos = find(__k);
 if (__pos != end())
   __nh = extract(const_iterator(__pos));
 return __nh;
      }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_unique(_Compatible_Hashtable& __src) noexcept
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
                                                             ;

   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     {
       auto __pos = __i++;
       const key_type& __k = this->_M_extract()(__pos._M_cur->_M_v());
       __hash_code __code = this->_M_hash_code(__k);
       size_type __bkt = _M_bucket_index(__k, __code);
       if (_M_find_node(__bkt, __k, __code) == nullptr)
  {
    auto __nh = __src.extract(__pos);
    _M_insert_unique_node(__bkt, __code, __nh._M_ptr);
    __nh._M_ptr = nullptr;
  }
     }
 }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_multi(_Compatible_Hashtable& __src) noexcept
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
                                                             ;

   this->reserve(size() + __src.size());
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     _M_reinsert_node_multi(cend(), __src.extract(__i++));
 }


    private:

      void _M_rehash_aux(size_type __n, std::true_type);


      void _M_rehash_aux(size_type __n, std::false_type);



      void _M_rehash(size_type __n, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    -> __node_type*
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bucket_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
    {
      auto __bkt = _M_rehash_policy._M_next_bkt(__bucket_hint);
      if (__bkt > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt);
   _M_bucket_count = __bkt;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bucket_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
 : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bucket_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 for (; __f != __l; ++__f)
   this->insert(*__f);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       try
  {
    _M_assign(__ht,
       [this](const __node_type* __n)
       { return this->_M_allocate_node(__n->_M_v()); });
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      __bucket_type* __former_buckets = nullptr;
      std::size_t __former_bucket_count = _M_bucket_count;
      const __rehash_state& __former_state = _M_rehash_policy._M_state();

      if (_M_bucket_count != __ht._M_bucket_count)
 {
   __former_buckets = _M_buckets;
   _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
   _M_bucket_count = __ht._M_bucket_count;
 }
      else
 __builtin_memset(_M_buckets, 0,
    _M_bucket_count * sizeof(__bucket_type));

      try
 {
   __hashtable_base::operator=(__ht);
   _M_element_count = __ht._M_element_count;
   _M_rehash_policy = __ht._M_rehash_policy;
   __reuse_or_alloc_node_type __roan(_M_begin(), *this);
   _M_before_begin._M_nxt = nullptr;
   _M_assign(__ht,
      [&__roan](const __node_type* __n)
      { return __roan(__n->_M_v()); });
   if (__former_buckets)
     _M_deallocate_buckets(__former_buckets, __former_bucket_count);
 }
      catch(...)
 {
   if (__former_buckets)
     {

       _M_deallocate_buckets();
       _M_rehash_policy._M_reset(__former_state);
       _M_buckets = __former_buckets;
       _M_bucket_count = __former_bucket_count;
     }
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__bucket_type));
   throw;
 }
      return *this;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_type* __ht_n = __ht._M_begin();
     __node_type* __this_n = __node_gen(__ht_n);
     this->_M_copy_code(__this_n, __ht_n);
     _M_before_begin._M_nxt = __this_n;
     _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;


     __node_base* __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__ht_n);
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(__this_n, __ht_n);
  size_type __bkt = _M_bucket_index(__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::true_type)
    {
      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }
      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), std::true_type());
      else
 {

   __bucket_type* __former_buckets = nullptr;
   size_type __former_bucket_count = _M_bucket_count;
   const __rehash_state& __former_state = _M_rehash_policy._M_state();

   if (_M_bucket_count != __ht._M_bucket_count)
     {
       __former_buckets = _M_buckets;
       _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
       _M_bucket_count = __ht._M_bucket_count;
     }
   else
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));

   try
     {
       __hashtable_base::operator=(std::move(__ht));
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       __reuse_or_alloc_node_type __roan(_M_begin(), *this);
       _M_before_begin._M_nxt = nullptr;
       _M_assign(__ht,
   [&__roan](__node_type* __n)
   { return __roan(std::move_if_noexcept(__n->_M_v())); });

       if (__former_buckets)
  _M_deallocate_buckets(__former_buckets, __former_bucket_count);
       __ht.clear();
     }
   catch(...)
     {
       if (__former_buckets)
  {
    _M_deallocate_buckets();
    _M_rehash_policy._M_reset(__former_state);
    _M_buckets = __former_buckets;
    _M_bucket_count = __former_bucket_count;
  }
       __builtin_memset(_M_buckets, 0,
          _M_bucket_count * sizeof(__bucket_type));
       throw;
     }
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht) noexcept
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__ht._M_base_alloc())),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;

   _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;


   if (_M_begin())
     _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
   __ht._M_reset();
 }
      else
 {
   _M_assign(__ht,
      [this](__node_type* __n)
      {
        return this->_M_allocate_node(
     std::move_if_noexcept(__n->_M_v()));
      });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__and_<__is_nothrow_swappable<_H1>,
                 __is_nothrow_swappable<_Equal>>::value)
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &__x._M_before_begin;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? const_iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__n);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __n, const key_type& __k,
   __hash_code __code) const
    -> __node_base*
    {
      __node_base* __prev_p = _M_buckets[__n];
      if (!__prev_p)
 return nullptr;

      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    -> __node_base*
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(std::true_type, _Args&&... __args)
      -> pair<iterator, bool>
      {

 __node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);
 const key_type& __k = this->_M_extract()(__node->_M_v());
 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(__k);
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))
   {

     this->_M_deallocate_node(__node);
     return std::make_pair(iterator(__p), false);
   }


 return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
         true);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)
      -> iterator
      {

 __node_type* __node =
   this->_M_allocate_node(std::forward<_Args>(__args)...);

 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     {
       _M_rehash(__do_rehash.second, __saved_state);
       __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);
     }

   this->_M_store_code(__node, __code);


   _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_type* __hint, __hash_code __code,
    __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     _M_rehash(__do_rehash.second, __saved_state);

   this->_M_store_code(__node, __code);
   const key_type& __k = this->_M_extract()(__node->_M_v());
   size_type __bkt = _M_bucket_index(__k, __code);



   __node_base* __prev
     = __builtin_expect(__hint != nullptr, false)
       && this->_M_equals(__k, __code, __hint)
  ? __hint
  : _M_find_before_node(__bkt, __k, __code);
   if (__prev)
     {

       __node->_M_nxt = __prev->_M_nxt;
       __prev->_M_nxt = __node;
       if (__builtin_expect(__prev == __hint, false))


        if (__node->_M_nxt
            && !this->_M_equals(__k, __code, __node->_M_next()))
          {
            size_type __next_bkt = _M_bucket_index(__node->_M_next());
            if (__next_bkt != __bkt)
              _M_buckets[__next_bkt] = __node;
          }
     }
   else




     _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, std::true_type)
      -> pair<iterator, bool>
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 __node_type* __n = _M_find_node(__bkt, __k, __code);
 if (__n)
   return std::make_pair(iterator(__n), false);

 __n = __node_gen(std::forward<_Arg>(__v));
 return std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen, std::false_type)
      -> iterator
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 __node_type* __node = __node_gen(std::forward<_Arg>(__v));

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::true_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::false_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __n)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::size_t __buckets
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __n);
      __buckets = _M_rehash_policy._M_next_bkt(__buckets);

      if (__buckets != _M_bucket_count)
 _M_rehash(__buckets, __saved_state);
      else

 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __n, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__n, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);

      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __n);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }


  template<typename, typename, typename> class _Hash_merge_helper { };



}
# 48 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/unordered_map" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    class unordered_multimap;
# 97 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;
      using insert_return_type = typename _Hashtable::insert_return_type;





      unordered_map() = default;
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 170 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
      : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
      : _M_h(std::move(__umap._M_h), __a)
      { }
# 225 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a)
      { }

      unordered_map(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
   : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_map(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 287 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 384 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 415 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }



      node_type
      extract(const_iterator __pos)
      {
                                 ;
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      insert_return_type
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)); }


      iterator
      insert(const_iterator, node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)).position; }
# 467 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template <typename... _Args>
        pair<iterator, bool>
        try_emplace(const key_type& __k, _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(__k),
                            std::forward_as_tuple(
                              std::forward<_Args>(__args)...))
                .first;
              return {__i, true};
            }
          return {__i, false};
        }


      template <typename... _Args>
        pair<iterator, bool>
        try_emplace(key_type&& __k, _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(std::move(__k)),
                            std::forward_as_tuple(
                              std::forward<_Args>(__args)...))
                .first;
              return {__i, true};
            }
          return {__i, false};
        }
# 530 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template <typename... _Args>
        iterator
        try_emplace(const_iterator __hint, const key_type& __k,
                    _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            __i = emplace_hint(__hint, std::piecewise_construct,
                               std::forward_as_tuple(__k),
                               std::forward_as_tuple(
                                 std::forward<_Args>(__args)...));
          return __i;
        }


      template <typename... _Args>
        iterator
        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            __i = emplace_hint(__hint, std::piecewise_construct,
                               std::forward_as_tuple(std::move(__k)),
                               std::forward_as_tuple(
                                 std::forward<_Args>(__args)...));
          return __i;
        }
# 577 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }



      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 616 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 641 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 653 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 680 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template <typename _Obj>
        pair<iterator, bool>
        insert_or_assign(const key_type& __k, _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(__k),
                            std::forward_as_tuple(std::forward<_Obj>(__obj)))
                .first;
              return {__i, true};
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return {__i, false};
        }


      template <typename _Obj>
        pair<iterator, bool>
        insert_or_assign(key_type&& __k, _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(std::move(__k)),
                            std::forward_as_tuple(std::forward<_Obj>(__obj)))
                .first;
              return {__i, true};
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return {__i, false};
        }
# 741 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template <typename _Obj>
        iterator
        insert_or_assign(const_iterator __hint, const key_type& __k,
                         _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              return emplace_hint(__hint, std::piecewise_construct,
                                  std::forward_as_tuple(__k),
                                  std::forward_as_tuple(
                                    std::forward<_Obj>(__obj)));
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return __i;
        }


      template <typename _Obj>
        iterator
        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              return emplace_hint(__hint, std::piecewise_construct,
                                  std::forward_as_tuple(std::move(__k)),
                                  std::forward_as_tuple(
                                    std::forward<_Obj>(__obj)));
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return __i;
        }
# 790 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 812 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 830 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 854 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class _Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 918 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 936 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 949 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 971 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 988 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1044 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1059 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1070 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1107 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1118 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
     const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };
# 1152 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;





      unordered_multimap() = default;
# 1203 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 1224 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
      : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
      : _M_h(std::move(__ummap._M_h), __a)
      { }
# 1279 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 1341 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1433 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1460 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1475 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 1509 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 1534 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1547 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }



      node_type
      extract(const_iterator __pos)
      {
                                 ;
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      iterator
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }


      iterator
      insert(const_iterator __hint, node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
# 1590 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 1611 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1630 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1654 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class _Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1720 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1745 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1801 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1816 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1827 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1864 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1875 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }






  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,
    typename _Alloc, typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_map = std::unordered_map<_Tp...>;
      template<typename... _Tp>
 using unordered_multimap = std::unordered_multimap<_Tp...>;

      friend unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }

      static auto&
      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }
    };


  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,
    typename _Alloc, typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_map = std::unordered_map<_Tp...>;
      template<typename... _Tp>
 using unordered_multimap = std::unordered_multimap<_Tp...>;

      friend unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }

      static auto&
      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }
    };



}
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/unordered_map" 2 3
# 61 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_construct.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


  template <typename _Tp>
    inline void
    destroy_at(_Tp* __location)
    {
      std::_Destroy(__location);
    }

  template <typename _ForwardIterator>
    inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 1 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 179 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 242 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 378 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 810 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }






  template <typename _ForwardIterator>
    inline void
    uninitialized_default_construct(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      __uninitialized_default_novalue(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_novalue_n(__first, __count);
    }

  template <typename _ForwardIterator>
    inline void
    uninitialized_value_construct(_ForwardIterator __first,
      _ForwardIterator __last)
    {
      return __uninitialized_default(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_n(__first, __count);
    }

  template <typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_move(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      return std::uninitialized_copy
 (std::make_move_iterator(__first),
  std::make_move_iterator(__last), __result);
    }

  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    uninitialized_move_n(_InputIterator __first, _Size __count,
    _ForwardIterator __result)
    {
      auto __res = std::__uninitialized_copy_n_pair
 (std::make_move_iterator(__first),
  __count, __result);
      return {__res.first.base(), __res.second};
    }



}
# 64 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 1 3
# 68 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 215 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 227 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 282 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 295 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 326 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 344 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 383 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 409 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 433 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 446 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 460 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 481 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 500 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 517 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 545 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 688 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 708 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 740 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 779 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 794 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
                                  ;
 return *(this->_M_impl._M_start + __n);
      }
# 812 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
                                  ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
# 843 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 861 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
                              ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
                              ;
 return *begin();
      }





      reference
      back() noexcept
      {
                              ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
                              ;
 return *(end() - 1);
      }
# 919 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 938 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>

 reference



 emplace_back(_Args&&... __args);
# 974 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
                              ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 995 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1011 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1041 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1058 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1083 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1125 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1177 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1204 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1228 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1281 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
 {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1364 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1451 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
 pointer
 _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }
# 1586 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
    };
# 1599 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1616 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 65 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_start = _M_impl._M_finish = _Bit_iterator();
     _M_impl._M_end_of_storage = _Bit_pointer();
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{
# 542 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
# 613 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 679 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 775 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x) noexcept
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
# 991 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_bvector.h" 3
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>

      reference



      emplace_back(_Args&&... __args)
      {
 push_back(bool(__args...));

 return back();

      }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      if (__n)
 {
   _Bit_pointer __q = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
   this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
 }
      else
 {
   this->_M_impl._M_end_of_storage = _Bit_pointer();
   this->_M_impl._M_start = iterator(0, 0);
 }
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/vector.tcc" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>

      typename vector<_Tp, _Alloc>::reference



      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);

 return back();

      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));

      ++this->_M_impl._M_finish;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);





      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (this->_M_impl._M_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

   ++__new_finish;

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__position.base(), this->_M_impl._M_finish,
      __new_finish, _M_get_Tp_allocator());
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }
      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      _M_deallocate(this->_M_impl._M_start,
      this->_M_impl._M_end_of_storage
      - this->_M_impl._M_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __destroy_from = pointer();
       try
  {
    std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
    __destroy_from = __new_start + __size;
    std::__uninitialized_move_if_noexcept_a(
        this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (__destroy_from)
      std::_Destroy(__destroy_from, __destroy_from + __n,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/vector" 2 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/algorithmfwd.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/algorithmfwd.h" 3








namespace std __attribute__ ((__visibility__ ("default")))
{
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);


  template<typename _Tp>
    constexpr
    const _Tp&
    clamp(const _Tp&, const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    clamp(const _Tp&, const _Tp&, const _Tp&, _Compare);


  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 565 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 594 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 1 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                     ;
                                                  ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 187 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                                  ;
                                                               ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 269 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                         ;
                                                     ;
                                                     ;
                                              ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 302 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                                  ;
                                                         ;
                                                           ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 358 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 384 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                                  ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 420 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;
                                              ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 447 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                                  ;
                                                           ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 475 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 503 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {



                                                     ;
                                                                  ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 527 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 540 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {



                                                     ;
                                                                  ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_tempbuf.h" 1 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 83 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uniform_int_dist.h" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uniform_int_dist.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace __detail
  {


    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };

  }
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uniform_int_dist.h" 3
  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
                                 ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 267 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 351 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {




                                                     ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 601 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {






                                                     ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 668 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 700 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 734 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 797 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {





      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 825 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {
# 840 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 894 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 927 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 993 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1023 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {






                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {




      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1178 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1205 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1432 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1469 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1546 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1649 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1735 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1755 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                     ;
                                                     ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1784 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1809 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                     ;
                                                                  ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2021 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2075 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2105 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2176 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {






                                                                  ;
                                                                  ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2212 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {







                    ;

                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2245 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {




                                                                  ;
                                                                  ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2278 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {





                    ;

                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2572 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {





                                                  ;
                                                 ;
                                                     ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2613 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {






                                                               ;
                                                              ;
                                                                  ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result));


    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2785 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2824 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
# 2838 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2868 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
# 2884 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2903 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2952 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;
                                                     ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2984 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;
                                                                  ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3052 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;
                                                     ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3084 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;
                                                                  ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3134 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3168 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3207 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3221 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3250 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3274 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3299 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {



      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3320 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3400 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3428 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3540 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3571 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3664 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
                                                       ;
                                                       ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3691 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
                                                       ;
                                                       ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3717 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
    {
                                      ;
      return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
    }
# 3735 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
    {
                                           ;
      return __comp(__val, __lo) ? __lo : __comp(__hi, __val) ? __hi : __val;
    }
# 3767 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3789 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {



                                                     ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
# 3876 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3897 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3921 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3952 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3992 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4024 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4049 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4074 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4097 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4137 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4176 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4211 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4244 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4269 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Searcher>
    inline _ForwardIterator
    search(_ForwardIterator __first, _ForwardIterator __last,
    const _Searcher& __searcher)
    { return __searcher(__first, __last).first; }
# 4292 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4329 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4362 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4394 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4426 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4457 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 4493 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4533 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4566 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4601 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4641 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4674 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {





                                                       ;
                                                      ;
                                                     ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4712 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {






                                                       ;
                                                      ;
                                                                  ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4748 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {





                                                    ;
                                                   ;
                                                     ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4787 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {






                                                    ;
                                                   ;
                                                                  ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4824 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4854 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;
                                                                  ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4915 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
# 4932 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4965 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
# 4982 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5029 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5063 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;
                                                                  ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5131 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
# 5151 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5180 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
# 5200 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5250 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
# 5268 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5298 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
# 5316 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5370 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
# 5388 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5420 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
# 5438 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5498 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
# 5518 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5548 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
# 5569 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5601 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5626 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5665 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5690 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
           typename _Size, typename _UniformRandomBitGenerator>
    _RandomAccessIterator
    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      __distrib_type __d{};
      _Size __sample_sz = 0;
      while (__first != __last && __sample_sz != __n)
 {
   __out[__sample_sz++] = *__first;
   ++__first;
 }
      for (auto __pop_sz = __sample_sz; __first != __last;
   ++__first, (void) ++__pop_sz)
 {
   const auto __k = __d(__g, __param_type{0, __pop_sz});
   if (__k < __n)
     __out[__k] = *__first;
 }
      return __out + __sample_sz;
    }


  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
           typename _Size, typename _UniformRandomBitGenerator>
    _OutputIterator
    __sample(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag,
      _OutputIterator __out, _Cat,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      using _USize = make_unsigned_t<_Size>;
      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

      __distrib_type __d{};
      _Size __unsampled_sz = std::distance(__first, __last);
      __n = std::min(__n, __unsampled_sz);




      const __uc_type __urngrange = __g.max() - __g.min();
      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))


        {
   while (__n != 0 && __unsampled_sz >= 2)
     {
       const pair<_Size, _Size> __p =
  __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

       --__unsampled_sz;
       if (__p.first < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;

       if (__n == 0) break;

       --__unsampled_sz;
       if (__p.second < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;
     }
        }



      for (; __n != 0; ++__first)
 if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
   {
     *__out++ = *__first;
     --__n;
   }
      return __out;
    }




  template<typename _PopulationIterator, typename _SampleIterator,
           typename _Distance, typename _UniformRandomBitGenerator>
    _SampleIterator
    sample(_PopulationIterator __first, _PopulationIterator __last,
    _SampleIterator __out, _Distance __n,
    _UniformRandomBitGenerator&& __g)
    {
      using __pop_cat = typename
 std::iterator_traits<_PopulationIterator>::iterator_category;
      using __samp_cat = typename
 std::iterator_traits<_SampleIterator>::iterator_category;

      static_assert(
   __or_<is_convertible<__pop_cat, forward_iterator_tag>,
  is_convertible<__samp_cat, random_access_iterator_tag>>::value,
   "output range must use a RandomAccessIterator when input range"
   " does not meet the ForwardIterator requirements");

      static_assert(is_integral<_Distance>::value,
      "sample size must be an integer type");

      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
      return std::
 __sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
   std::forward<_UniformRandomBitGenerator>(__g));
    }




}
# 65 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Callable, typename... _Args>
    inline invoke_result_t<_Callable, _Args...>
    invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Callable, _Args...>)
    {
      return std::__invoke(std::forward<_Callable>(__fn),
      std::forward<_Args>(__args)...);
    }


  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 134 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };


template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };





  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _MemberPointer>
    struct _Mem_fn;

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 219 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 234 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 245 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };


  template <typename _Tp> inline constexpr bool is_bind_expression_v
    = is_bind_expression<_Tp>::value;
  template <typename _Tp> inline constexpr int is_placeholder_v
    = is_placeholder<_Tp>::value;





  template<int _Num> struct _Placeholder { };







  namespace placeholders
  {





    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;

  }
# 314 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
# 342 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::get<_Indexes>(std::move(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return
     ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }

      template<typename _BoundArg, typename _CallArgs>
 using _Mu_type = decltype(
     _Mu<typename remove_cv<_BoundArg>::type>()(
       std::declval<_BoundArg&>(), std::declval<_CallArgs&>()) );

      template<typename _Fn, typename _CallArgs, typename... _BArgs>
 using _Res_type_impl
   = typename result_of< _Fn&(_Mu_type<_BArgs, _CallArgs>&&...) >::type;

      template<typename _CallArgs>
 using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

      template<typename _CallArgs>
 using __dependent = typename
   enable_if<bool(tuple_size<_CallArgs>::value+1), _Functor>::type;

      template<typename _CallArgs, template<class> class __cv_quals>
 using _Res_type_cv = _Res_type_impl<
   typename __cv_quals<__dependent<_CallArgs>>::type,
   _CallArgs,
   typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args,
        typename _Result = _Res_type<tuple<_Args...>>>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
# 572 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>
 [[deprecated("std::bind does not support volatile in C++17")]]
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_cv>>
 [[deprecated("std::bind does not support volatile in C++17")]]
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 using __enable_if_void
   = typename enable_if<is_void<_Res>{}>::type;

      template<typename _Res>
 using __disable_if_void
   = typename enable_if<!is_void<_Res>{}, _Result>::type;


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 [[deprecated("std::bind does not support volatile in C++17")]]
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 [[deprecated("std::bind does not support volatile in C++17")]]
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };






  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }



  template<typename _Fn>
    class _Not_fn
    {
      template<typename _Fn2, typename... _Args>
 using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

      template<typename _Tp>
 static decltype(!std::declval<_Tp>())
 _S_not() noexcept(noexcept(!std::declval<_Tp>()));

    public:
      template<typename _Fn2>
 _Not_fn(_Fn2&& __fn, int)
 : _M_fn(std::forward<_Fn2>(__fn)) { }

      _Not_fn(const _Not_fn& __fn) = default;
      _Not_fn(_Not_fn&& __fn) = default;
      ~_Not_fn() = default;
# 940 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/functional" 3
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &, _Args...>>()) operator()(_Args&&... __args) & noexcept(__is_nothrow_invocable<_Fn &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) { return !std::__invoke(std::forward< _Fn & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>()) operator()(_Args&&... __args) const & noexcept(__is_nothrow_invocable<_Fn const &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) { return !std::__invoke(std::forward< _Fn const & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>()) operator()(_Args&&... __args) && noexcept(__is_nothrow_invocable<_Fn &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn && >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>()) operator()(_Args&&... __args) const && noexcept(__is_nothrow_invocable<_Fn const &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn const && >(_M_fn), std::forward<_Args>(__args)...); }


    private:
      _Fn _M_fn;
    };




  template<typename _Fn>
    inline auto
    not_fn(_Fn&& __fn)
    noexcept(std::is_nothrow_constructible<std::decay_t<_Fn>, _Fn&&>::value)
    {
      return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn), 0};
    }




  template<typename _ForwardIterator1, typename _BinaryPredicate = equal_to<>>
    class default_searcher
    {
    public:
      default_searcher(_ForwardIterator1 __pat_first,
         _ForwardIterator1 __pat_last,
         _BinaryPredicate __pred = _BinaryPredicate())
      : _M_m(__pat_first, __pat_last, std::move(__pred))
      { }

      template<typename _ForwardIterator2>
        pair<_ForwardIterator2, _ForwardIterator2>
 operator()(_ForwardIterator2 __first, _ForwardIterator2 __last) const
 {
   _ForwardIterator2 __first_ret =
     std::search(__first, __last, std::get<0>(_M_m), std::get<1>(_M_m),
   std::get<2>(_M_m));
   auto __ret = std::make_pair(__first_ret, __first_ret);
   if (__ret.first != __last)
     std::advance(__ret.second, std::distance(std::get<0>(_M_m),
           std::get<1>(_M_m)));
   return __ret;
 }

    private:
      tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate> _M_m;
    };

  template<typename _Key, typename _Tp, typename _Hash, typename _Pred>
    struct __boyer_moore_map_base
    {
      template<typename _RAIter>
 __boyer_moore_map_base(_RAIter __pat, size_t __patlen,
          _Hash&& __hf, _Pred&& __pred)
 : _M_bad_char{ __patlen, std::move(__hf), std::move(__pred) }
 {
   if (__patlen > 0)
     for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
       _M_bad_char[__pat[__i]] = __patlen - 1 - __i;
 }

      using __diff_type = _Tp;

      __diff_type
      _M_lookup(_Key __key, __diff_type __not_found) const
      {
 auto __iter = _M_bad_char.find(__key);
 if (__iter == _M_bad_char.end())
   return __not_found;
 return __iter->second;
      }

      _Pred
      _M_pred() const { return _M_bad_char.key_eq(); }

      std::unordered_map<_Key, _Tp, _Hash, _Pred> _M_bad_char;
    };

  template<typename _Tp, size_t _Len, typename _Pred>
    struct __boyer_moore_array_base
    {
      template<typename _RAIter, typename _Unused>
 __boyer_moore_array_base(_RAIter __pat, size_t __patlen,
     _Unused&&, _Pred&& __pred)
 : _M_bad_char{ std::array<_Tp, _Len>{}, std::move(__pred) }
 {
   std::get<0>(_M_bad_char).fill(__patlen);
   if (__patlen > 0)
     for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
       {
  auto __ch = __pat[__i];
  using _UCh = make_unsigned_t<decltype(__ch)>;
  auto __uch = static_cast<_UCh>(__ch);
  std::get<0>(_M_bad_char)[__uch] = __patlen - 1 - __i;
       }
 }

      using __diff_type = _Tp;

      template<typename _Key>
 __diff_type
 _M_lookup(_Key __key, __diff_type __not_found) const
 {
   auto __ukey = static_cast<make_unsigned_t<_Key>>(__key);
   if (__ukey >= _Len)
     return __not_found;
   return std::get<0>(_M_bad_char)[__ukey];
 }

      const _Pred&
      _M_pred() const { return std::get<1>(_M_bad_char); }

      tuple<std::array<_Tp, _Len>, _Pred> _M_bad_char;
    };

  template<typename _Pred>
    struct __is_std_equal_to : false_type { };

  template<>
    struct __is_std_equal_to<equal_to<void>> : true_type { };



  template<typename _RAIter, typename _Hash, typename _Pred,
           typename _Val = typename iterator_traits<_RAIter>::value_type,
    typename _Diff = typename iterator_traits<_RAIter>::difference_type>
    using __boyer_moore_base_t
      = conditional_t<sizeof(_Val) == 1 && is_integral<_Val>::value
        && __is_std_equal_to<_Pred>::value,
        __boyer_moore_array_base<_Diff, 256, _Pred>,
        __boyer_moore_map_base<_Val, _Diff, _Hash, _Pred>>;

  template<typename _RAIter, typename _Hash
      = hash<typename iterator_traits<_RAIter>::value_type>,
    typename _BinaryPredicate = equal_to<>>
    class boyer_moore_searcher
    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>
    {
      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
      using typename _Base::__diff_type;

    public:
      boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,
      _Hash __hf = _Hash(),
      _BinaryPredicate __pred = _BinaryPredicate());

      template<typename _RandomAccessIterator2>
        pair<_RandomAccessIterator2, _RandomAccessIterator2>
 operator()(_RandomAccessIterator2 __first,
     _RandomAccessIterator2 __last) const;

    private:
      bool
      _M_is_prefix(_RAIter __word, __diff_type __len,
     __diff_type __pos)
      {
 const auto& __pred = this->_M_pred();
 __diff_type __suffixlen = __len - __pos;
 for (__diff_type __i = 0; __i < __suffixlen; ++__i)
   if (!__pred(__word[__i], __word[__pos + __i]))
     return false;
 return true;
      }

      __diff_type
      _M_suffix_length(_RAIter __word, __diff_type __len,
         __diff_type __pos)
      {
 const auto& __pred = this->_M_pred();
 __diff_type __i = 0;
 while (__pred(__word[__pos - __i], __word[__len - 1 - __i])
        && __i < __pos)
   {
     ++__i;
   }
 return __i;
      }

      template<typename _Tp>
 __diff_type
 _M_bad_char_shift(_Tp __c) const
 { return this->_M_lookup(__c, _M_pat_end - _M_pat); }

      _RAIter _M_pat;
      _RAIter _M_pat_end;
      std::vector<__diff_type> _M_good_suffix;
    };

  template<typename _RAIter, typename _Hash
      = hash<typename iterator_traits<_RAIter>::value_type>,
    typename _BinaryPredicate = equal_to<>>
    class boyer_moore_horspool_searcher
    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>
    {
      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
      using typename _Base::__diff_type;

    public:
      boyer_moore_horspool_searcher(_RAIter __pat,
        _RAIter __pat_end,
        _Hash __hf = _Hash(),
        _BinaryPredicate __pred
        = _BinaryPredicate())
      : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
 _M_pat(__pat), _M_pat_end(__pat_end)
      { }

      template<typename _RandomAccessIterator2>
        pair<_RandomAccessIterator2, _RandomAccessIterator2>
 operator()(_RandomAccessIterator2 __first,
     _RandomAccessIterator2 __last) const
 {
   const auto& __pred = this->_M_pred();
   auto __patlen = _M_pat_end - _M_pat;
   if (__patlen == 0)
     return std::make_pair(__first, __first);
   auto __len = __last - __first;
   while (__len >= __patlen)
     {
       for (auto __scan = __patlen - 1;
     __pred(__first[__scan], _M_pat[__scan]); --__scan)
  if (__scan == 0)
    return std::make_pair(__first, __first + __patlen);
       auto __shift = _M_bad_char_shift(__first[__patlen - 1]);
       __len -= __shift;
       __first += __shift;
     }
   return std::make_pair(__last, __last);
 }

    private:
      template<typename _Tp>
 __diff_type
 _M_bad_char_shift(_Tp __c) const
 { return this->_M_lookup(__c, _M_pat_end - _M_pat); }

      _RAIter _M_pat;
      _RAIter _M_pat_end;
    };

  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>
    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::
    boyer_moore_searcher(_RAIter __pat, _RAIter __pat_end,
    _Hash __hf, _BinaryPredicate __pred)
    : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
      _M_pat(__pat), _M_pat_end(__pat_end), _M_good_suffix(__pat_end - __pat)
    {
      auto __patlen = __pat_end - __pat;
      if (__patlen == 0)
 return;
      __diff_type __last_prefix = __patlen - 1;
      for (__diff_type __p = __patlen - 1; __p >= 0; --__p)
 {
   if (_M_is_prefix(__pat, __patlen, __p + 1))
     __last_prefix = __p + 1;
   _M_good_suffix[__p] = __last_prefix + (__patlen - 1 - __p);
 }
      for (__diff_type __p = 0; __p < __patlen - 1; ++__p)
 {
   auto __slen = _M_suffix_length(__pat, __patlen, __p);
   auto __pos = __patlen - 1 - __slen;
   if (!__pred(__pat[__p - __slen], __pat[__pos]))
     _M_good_suffix[__pos] = __patlen - 1 - __p + __slen;
 }
    }

  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>
  template<typename _RandomAccessIterator2>
    pair<_RandomAccessIterator2, _RandomAccessIterator2>
    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::
    operator()(_RandomAccessIterator2 __first,
        _RandomAccessIterator2 __last) const
    {
      auto __patlen = _M_pat_end - _M_pat;
      if (__patlen == 0)
 return std::make_pair(__first, __first);
      const auto& __pred = this->_M_pred();
      __diff_type __i = __patlen - 1;
      auto __stringlen = __last - __first;
      while (__i < __stringlen)
 {
   __diff_type __j = __patlen - 1;
   while (__j >= 0 && __pred(__first[__i], _M_pat[__j]))
     {
       --__i;
       --__j;
     }
   if (__j < 0)
     {
       const auto __match = __first + __i + 1;
       return std::make_pair(__match, __match + __patlen);
     }
   __i += std::max(_M_bad_char_shift(__first[__i]),
     _M_good_suffix[__j]);
 }
      return std::make_pair(__last, __last);
    }





}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stl.hpp" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 1 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }




      raw_storage_iterator&
      operator=(_Tp&& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), std::move(__element));
 return *this;
      }


      raw_storage_iterator&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator
      operator++(int)
      {
 raw_storage_iterator __tmp = *this;
 ++_M_iter;
 return __tmp;
      }



      _OutputIterator base() const { return _M_iter; }
    };


}
# 68 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 2 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/concurrence.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/concurrence.h" 3
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 147 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 202 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 280 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 75 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 2 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 51 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 101 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };

  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <class _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
        >;




      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 207 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 219 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 275 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 290 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
                                     ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
                                             ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(_M_t._M_ptr(), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _UPtr = unique_ptr<_Up, _Ep>,
        typename _UP_pointer = typename _UPtr::pointer,
        typename _UP_element_type = typename _UPtr::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<_UP_pointer, _UP_element_type*>,
          is_convertible<_UP_element_type(*)[], element_type(*)[]>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 457 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 475 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 491 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      template <typename _Up = _Dp,
  typename = _DeleterConstraint<_Up>>
 constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }

      template<typename _Up, typename _Ep, typename = _Require<
        __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 535 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 550 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
                                     ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 pointer __ptr = __p;
 using std::swap;
 swap(_M_t._M_ptr(), __ptr);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
    private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
# 81 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 1 3
# 52 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 1 3
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocated_ptr.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return _S_raw_ptr(_M_ptr); }

    private:
      static value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }

      template<typename _Ptr>
 static auto
 _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))
 { return _S_raw_ptr(__ptr.operator->()); }

      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 56 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename> class auto_ptr;






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const* what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

                                                              ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
                                                                 ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
  __atomic_thread_fence (4);
       }


                                                                   ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                                                                      ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

                                                               ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
                                                                  ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


  __atomic_thread_fence (4);
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, std::move(__d), _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, std::move(__d), __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag { };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;

      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }


      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {

 if (__ti == typeid(_Sp_make_shared_tag))
   return const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());

 return nullptr;
      }

    private:
      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  struct __sp_array_delete
  {
    template<typename _Yp>
      void operator()(_Yp* __p) const { delete[] __p; }
  };

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr>
 __shared_count(_Ptr __p, false_type)
 : __shared_count(__p)
 { }

      template<typename _Ptr>
 __shared_count(_Ptr __p, true_type)
 : __shared_count(__p, __sp_array_delete{}, allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
         _Args&&... __args)
 : _M_pi(0)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   ::new (__mem) _Sp_cp_type(std::move(__a),
        std::forward<_Args>(__args)...);
   _M_pi = __mem;
   __guard = nullptr;
 }



      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {


   if (__r.get() == nullptr)
     return;

   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }







  template<typename _Yp_ptr, typename _Tp_ptr>
    struct __sp_compatible_with
    : false_type
    { };

  template<typename _Yp, typename _Tp>
    struct __sp_compatible_with<_Yp*, _Tp*>
    : is_convertible<_Yp*, _Tp*>::type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
    : true_type
    { };


  template<typename _Up, size_t _Nm, typename _Yp, typename = void>
    struct __sp_is_constructible_arrN
    : false_type
    { };

  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type
    { };


  template<typename _Up, typename _Yp, typename = void>
    struct __sp_is_constructible_arr
    : false_type
    { };

  template<typename _Up, typename _Yp>
    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
    : is_convertible<_Yp(*)[], _Up(*)[]>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible;


  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible<_Up[_Nm], _Yp>
    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type
    { };


  template<typename _Up, typename _Yp>
    struct __sp_is_constructible<_Up[], _Yp>
    : __sp_is_constructible_arr<_Up, _Yp>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible
    : is_convertible<_Yp*, _Tp*>::type
    { };



  template<typename _Tp, _Lock_policy _Lp,
    bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
    class __shared_ptr_access
    {
    public:
      using element_type = _Tp;

      element_type&
      operator*() const noexcept
      {
                                      ;
 return *_M_get();
      }

      element_type*
      operator->() const noexcept
      {
                                              ;
 return _M_get();
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, false, true>
    {
    public:
      using element_type = _Tp;

      element_type*
      operator->() const noexcept
      {
 auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();
                                           ;
 return __ptr;
      }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, true, false>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;
# 1019 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 3
      element_type&
      operator[](ptrdiff_t __i) const
      {
                                      ;
                                                                  ;
 return _M_get()[__i];
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    : public __shared_ptr_access<_Tp, _Lp>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;

    private:

      template<typename _Yp>
 using _SafeConv
   = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;


      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __shared_ptr&>;


      template<typename _Yp, typename _Del, typename _Res = void,
        typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
 using _UniqCompatible = typename enable_if<__and_<
   __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>
   >::value, _Res>::type;


      template<typename _Yp, typename _Del>
 using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;

    public:


      using weak_type = __weak_ptr<_Tp, _Lp>;


      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Yp, typename = _SafeConv<_Yp>>
 explicit
 __shared_ptr(_Yp* __p)
 : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 {
   static_assert( !is_void<_Yp>::value, "incomplete type" );
   static_assert( sizeof(_Yp) > 0, "incomplete type" );
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, std::move(__d))
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
 { }

      template<typename _Yp>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Yp, typename = _Compatible<_Yp>>
 explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {


   _M_ptr = __r._M_ptr;
 }


      template<typename _Yp, typename _Del,
        typename = _UniqCompatible<_Yp, _Del>>
 __shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = _S_raw_ptr(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }
# 1185 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(auto_ptr<_Yp>&& __r);


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


      template<typename _Yp>
 _Assignable<_Yp>
 operator=(auto_ptr<_Yp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Yp>
 _Assignable<_Yp>
 operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Yp, typename _Del>
 _UniqAssignable<_Yp, _Del>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Yp>
 _SafeConv<_Yp>
 reset(_Yp* __p)
 {

                                              ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Yp, typename _Deleter>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d)
 { __shared_ptr(__p, std::move(__d)).swap(*this); }

      template<typename _Yp, typename _Deleter, typename _Alloc>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      element_type*
      get() const noexcept
      { return _M_ptr; }

      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }

      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
       _Args&&... __args)
 : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
 {


   void* __p = _M_refcount._M_get_deleter(typeid(__tag));
   _M_ptr = static_cast<_Tp*>(__p);
   _M_enable_shared_from_this_with(_M_ptr);
 }
# 1337 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 3
      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:

      template<typename _Yp>
 using __esft_base_t = decltype(__enable_shared_from_this_base(
       std::declval<const __shared_count<_Lp>&>(),
       std::declval<_Yp*>()));


      template<typename _Yp, typename = void>
 struct __has_esft_base
 : false_type { };

      template<typename _Yp>
 struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
 : __not_<is_array<_Tp>> { };

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp* __p) noexcept
 {
   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
     __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
 }

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<!__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp*) noexcept
 { }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1>
 static _Tp1*
 _S_raw_ptr(_Tp1* __ptr)
 { return __ptr; }

      template<typename _Tp1>
 static auto
 _S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))
 { return std::__addressof(*__ptr); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      element_type* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Up, _Lp>& __b) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept
      {
 typedef typename _Sp::element_type element_type;
 return std::less<element_type*>()(__lhs.get(), __rhs.get());
      }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1543 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }


  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    reinterpret_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __weak_ptr&>;

    public:
      using element_type = typename remove_extent<_Tp>::type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
# 1625 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 if (use_count() == 0)
   {
     _M_ptr = __ptr;
     _M_refcount = __refcount;
   }
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      element_type* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }
    };

  template<>
    struct _Sp_owner_less<void, void>
    {
      template<typename _Tp, typename _Up>
 auto
 operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept
 -> decltype(__lhs.owner_before(__rhs))
 { return __lhs.owner_before(__rhs); }

      using is_transparent = void;
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }


      __weak_ptr<_Tp, _Lp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      __weak_ptr<const _Tp, _Lp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      friend const __enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<_Lp>&,
         const __enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      {
 return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(
     __s.get());
      }
    };


}
# 53 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 64 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }


  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 92 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename... _Args>
 using _Constructible = typename enable_if<
   is_constructible<__shared_ptr<_Tp>, _Args...>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&
 >::type;

    public:

      using element_type = typename __shared_ptr<_Tp>::element_type;



      using weak_type = weak_ptr<_Tp>;





      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Yp, typename = _Constructible<_Yp*>>
 explicit
 shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
# 144 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter,
        typename = _Constructible<_Yp*, _Deleter>>
 shared_ptr(_Yp* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 162 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 181 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _Constructible<_Yp*, _Deleter, _Alloc>>
 shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 201 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 223 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 234 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
 shared_ptr(shared_ptr<_Yp>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 264 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 explicit shared_ptr(const weak_ptr<_Yp>& __r)
 : __shared_ptr<_Tp>(__r) { }


      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
 shared_ptr(auto_ptr<_Yp>&& __r);




      template<typename _Yp, typename _Del,
        typename = _Constructible<unique_ptr<_Yp, _Del>>>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 294 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


      template<typename _Yp>
 _Assignable<auto_ptr<_Yp>>
 operator=(auto_ptr<_Yp>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Yp>
 _Assignable<shared_ptr<_Yp>>
 operator=(shared_ptr<_Yp>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Yp, typename _Del>
 _Assignable<unique_ptr<_Yp, _Del>>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
     _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
 { }

      template<typename _Yp, typename _Alloc, typename... _Args>
 friend shared_ptr<_Yp>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };


  template<typename _Tp>
    shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
  template<typename _Tp, typename _Del>
    shared_ptr(unique_ptr<_Tp, _Del>) -> shared_ptr<_Tp>;



  template<typename _Tp, typename _Up>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }

  template<typename _Tp, typename _Up>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      using _Up_elt = typename shared_ptr<_Up>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp, typename _Up>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, typename _Up>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp, typename _Up>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
    { };


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }

  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }

  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }







  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Arg>
 using _Constructible = typename enable_if<
   is_constructible<__weak_ptr<_Tp>, _Arg>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
 >::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 weak_ptr(const shared_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 weak_ptr(const weak_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
 weak_ptr(weak_ptr<_Yp>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<const weak_ptr<_Yp>&>
 operator=(const weak_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<weak_ptr<_Yp>>
 operator=(weak_ptr<_Yp>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };


  template<typename _Tp>
    weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;



  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp = void>
    struct owner_less;


  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }



      weak_ptr<_Tp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      weak_ptr<const _Tp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }


      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
         const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 686 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }
# 701 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      {
 return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());
      }
    };




}
# 82 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_base.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_base.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_lockfree_defines.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_lockfree_defines.h" 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_base.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_base.h" 3
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;

  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(__m | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(__m & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | (__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(__m); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(__m); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }



  template<typename _IntTp>
    struct __atomic_base;




  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
# 148 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b = __m & __memory_order_mask;
                                                   ;
                                                   ;
                                                   ;

      __atomic_clear (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b = __m & __memory_order_mask;
                                                   ;
                                                   ;
                                                   ;

      __atomic_clear (&_M_i, __m);
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
# 237 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/atomic_base.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, __m);
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, __m); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;

                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, __m);
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }
    };




}
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };







  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
# 96 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
# 132 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
# 169 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
# 218 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }





}
# 83 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));
# 86 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 112 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 124 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 135 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 152 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 170 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 180 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
                              ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                              ;
 return _M_ptr;
      }
# 210 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 224 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 239 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 264 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1, typename>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {

      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__tmp);
    }

  template<typename _Tp>
  template<typename _Tp1, typename>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }



}
# 85 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 2 3








namespace std __attribute__ ((__visibility__ ("default")))
{
# 113 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/memory" 3
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{
  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if ((__size + __diff) > __space)
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}



enum class pointer_safety { relaxed, preferred, strict };

inline void
declare_reachable(void*) { }

template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }

inline void
declare_no_pointers(char*, size_t) { }

inline void
undeclare_no_pointers(char*, size_t) { }

inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }


}
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stl.hpp" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ratio" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ratio" 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ratio" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ratio" 3
  template<intmax_t _Pn>
    struct __static_sign
    : integral_constant<intmax_t, (_Pn < 0) ? -1 : 1>
    { };

  template<intmax_t _Pn>
    struct __static_abs
    : integral_constant<intmax_t, _Pn * __static_sign<_Pn>::value>
    { };

  template<intmax_t _Pn, intmax_t _Qn>
    struct __static_gcd
    : __static_gcd<_Qn, (_Pn % _Qn)>
    { };

  template<intmax_t _Pn>
    struct __static_gcd<_Pn, 0>
    : integral_constant<intmax_t, __static_abs<_Pn>::value>
    { };

  template<intmax_t _Qn>
    struct __static_gcd<0, _Qn>
    : integral_constant<intmax_t, __static_abs<_Qn>::value>
    { };







  template<intmax_t _Pn, intmax_t _Qn>
    struct __safe_multiply
    {
    private:
      static const uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);

      static const uintmax_t __a0 = __static_abs<_Pn>::value % __c;
      static const uintmax_t __a1 = __static_abs<_Pn>::value / __c;
      static const uintmax_t __b0 = __static_abs<_Qn>::value % __c;
      static const uintmax_t __b1 = __static_abs<_Qn>::value / __c;

      static_assert(__a1 == 0 || __b1 == 0,
      "overflow in multiplication");
      static_assert(__a0 * __b1 + __b0 * __a1 < (__c >> 1),
      "overflow in multiplication");
      static_assert(__b0 * __a0 <= 9223372036854775807L,
      "overflow in multiplication");
      static_assert((__a0 * __b1 + __b0 * __a1) * __c
      <= 9223372036854775807L - __b0 * __a0,
      "overflow in multiplication");

    public:
      static const intmax_t value = _Pn * _Qn;
    };



  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_less
    : integral_constant<bool, (__hi1 < __hi2
          || (__hi1 == __hi2 && __lo1 < __lo2))>
    { };

  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_add
    {
      static constexpr uintmax_t __lo = __lo1 + __lo2;
      static constexpr uintmax_t __hi = (__hi1 + __hi2 +
      (__lo1 + __lo2 < __lo1));
    };


  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_sub
    {
      static_assert(!__big_less<__hi1, __lo1, __hi2, __lo2>::value,
      "Internal library error");
      static constexpr uintmax_t __lo = __lo1 - __lo2;
      static constexpr uintmax_t __hi = (__hi1 - __hi2 -
      (__lo1 < __lo2));
    };


  template<uintmax_t __x, uintmax_t __y>
    struct __big_mul
    {
    private:
      static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
      static constexpr uintmax_t __x0 = __x % __c;
      static constexpr uintmax_t __x1 = __x / __c;
      static constexpr uintmax_t __y0 = __y % __c;
      static constexpr uintmax_t __y1 = __y / __c;
      static constexpr uintmax_t __x0y0 = __x0 * __y0;
      static constexpr uintmax_t __x0y1 = __x0 * __y1;
      static constexpr uintmax_t __x1y0 = __x1 * __y0;
      static constexpr uintmax_t __x1y1 = __x1 * __y1;
      static constexpr uintmax_t __mix = __x0y1 + __x1y0;
      static constexpr uintmax_t __mix_lo = __mix * __c;
      static constexpr uintmax_t __mix_hi
      = __mix / __c + ((__mix < __x0y1) ? __c : 0);
      typedef __big_add<__mix_hi, __mix_lo, __x1y1, __x0y0> _Res;
    public:
      static constexpr uintmax_t __hi = _Res::__hi;
      static constexpr uintmax_t __lo = _Res::__lo;
    };



  template<uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
    struct __big_div_impl
    {
    private:
      static_assert(__d >= (uintmax_t(1) << (sizeof(intmax_t) * 8 - 1)),
      "Internal library error");
      static_assert(__n1 < __d, "Internal library error");
      static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
      static constexpr uintmax_t __d1 = __d / __c;
      static constexpr uintmax_t __d0 = __d % __c;

      static constexpr uintmax_t __q1x = __n1 / __d1;
      static constexpr uintmax_t __r1x = __n1 % __d1;
      static constexpr uintmax_t __m = __q1x * __d0;
      static constexpr uintmax_t __r1y = __r1x * __c + __n0 / __c;
      static constexpr uintmax_t __r1z = __r1y + __d;
      static constexpr uintmax_t __r1
      = ((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m))
  ? (__r1z + __d) : __r1z : __r1y) - __m;
      static constexpr uintmax_t __q1
      = __q1x - ((__r1y < __m)
   ? ((__r1z >= __d) && (__r1z < __m)) ? 2 : 1 : 0);
      static constexpr uintmax_t __q0x = __r1 / __d1;
      static constexpr uintmax_t __r0x = __r1 % __d1;
      static constexpr uintmax_t __n = __q0x * __d0;
      static constexpr uintmax_t __r0y = __r0x * __c + __n0 % __c;
      static constexpr uintmax_t __r0z = __r0y + __d;
      static constexpr uintmax_t __r0
      = ((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n))
  ? (__r0z + __d) : __r0z : __r0y) - __n;
      static constexpr uintmax_t __q0
      = __q0x - ((__r0y < __n) ? ((__r0z >= __d)
      && (__r0z < __n)) ? 2 : 1 : 0);

    public:
      static constexpr uintmax_t __quot = __q1 * __c + __q0;
      static constexpr uintmax_t __rem = __r0;

    private:
      typedef __big_mul<__quot, __d> _Prod;
      typedef __big_add<_Prod::__hi, _Prod::__lo, 0, __rem> _Sum;
      static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
      "Internal library error");
  };

  template<uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
    struct __big_div
    {
    private:
      static_assert(__d != 0, "Internal library error");
      static_assert(sizeof (uintmax_t) == sizeof (unsigned long long),
      "This library calls __builtin_clzll on uintmax_t, which "
      "is unsafe on your platform. Please complain to "
      "http://gcc.gnu.org/bugzilla/");
      static constexpr int __shift = __builtin_clzll(__d);
      static constexpr int __coshift_ = sizeof(uintmax_t) * 8 - __shift;
      static constexpr int __coshift = (__shift != 0) ? __coshift_ : 0;
      static constexpr uintmax_t __c1 = uintmax_t(1) << __shift;
      static constexpr uintmax_t __c2 = uintmax_t(1) << __coshift;
      static constexpr uintmax_t __new_d = __d * __c1;
      static constexpr uintmax_t __new_n0 = __n0 * __c1;
      static constexpr uintmax_t __n1_shifted = (__n1 % __d) * __c1;
      static constexpr uintmax_t __n0_top = (__shift != 0) ? (__n0 / __c2) : 0;
      static constexpr uintmax_t __new_n1 = __n1_shifted + __n0_top;
      typedef __big_div_impl<__new_n1, __new_n0, __new_d> _Res;

    public:
      static constexpr uintmax_t __quot_hi = __n1 / __d;
      static constexpr uintmax_t __quot_lo = _Res::__quot;
      static constexpr uintmax_t __rem = _Res::__rem / __c1;

    private:
      typedef __big_mul<__quot_lo, __d> _P0;
      typedef __big_mul<__quot_hi, __d> _P1;
      typedef __big_add<_P0::__hi, _P0::__lo, _P1::__lo, __rem> _Sum;

      static_assert(_P1::__hi == 0, "Internal library error");
      static_assert(_Sum::__hi >= _P0::__hi, "Internal library error");

      static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
      "Internal library error");
      static_assert(__rem < __d, "Internal library error");
    };
# 262 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ratio" 3
  template<intmax_t _Num, intmax_t _Den = 1>
    struct ratio
    {
      static_assert(_Den != 0, "denominator cannot be zero");
      static_assert(_Num >= -9223372036854775807L && _Den >= -9223372036854775807L,
      "out of range");


      static constexpr intmax_t num =
        _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

      static constexpr intmax_t den =
        __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

      typedef ratio<num, den> type;
    };

  template<intmax_t _Num, intmax_t _Den>
    constexpr intmax_t ratio<_Num, _Den>::num;

  template<intmax_t _Num, intmax_t _Den>
    constexpr intmax_t ratio<_Num, _Den>::den;

  template<typename _R1, typename _R2>
    struct __ratio_multiply
    {
    private:
      static const intmax_t __gcd1 =
        __static_gcd<_R1::num, _R2::den>::value;
      static const intmax_t __gcd2 =
        __static_gcd<_R2::num, _R1::den>::value;

    public:
      typedef ratio<
        __safe_multiply<(_R1::num / __gcd1),
                        (_R2::num / __gcd2)>::value,
        __safe_multiply<(_R1::den / __gcd2),
                        (_R2::den / __gcd1)>::value> type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_multiply<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_multiply<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;

  template<typename _R1, typename _R2>
    struct __ratio_divide
    {
      static_assert(_R2::num != 0, "division by 0");

      typedef typename __ratio_multiply<
        _R1,
        ratio<_R2::den, _R2::num>>::type type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_divide<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_divide<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_divide = typename __ratio_divide<_R1, _R2>::type;


  template<typename _R1, typename _R2>
    struct ratio_equal
    : integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den>
    { };


  template<typename _R1, typename _R2>
    struct ratio_not_equal
    : integral_constant<bool, !ratio_equal<_R1, _R2>::value>
    { };


  template<typename _R1, typename _R2,
           typename _Left = __big_mul<_R1::num,_R2::den>,
           typename _Right = __big_mul<_R2::num,_R1::den> >
    struct __ratio_less_impl_1
    : integral_constant<bool, __big_less<_Left::__hi, _Left::__lo,
           _Right::__hi, _Right::__lo>::value>
    { };

  template<typename _R1, typename _R2,
    bool = (_R1::num == 0 || _R2::num == 0
     || (__static_sign<_R1::num>::value
         != __static_sign<_R2::num>::value)),
    bool = (__static_sign<_R1::num>::value == -1
     && __static_sign<_R2::num>::value == -1)>
    struct __ratio_less_impl
    : __ratio_less_impl_1<_R1, _R2>::type
    { };

  template<typename _R1, typename _R2>
    struct __ratio_less_impl<_R1, _R2, true, false>
    : integral_constant<bool, _R1::num < _R2::num>
    { };

  template<typename _R1, typename _R2>
    struct __ratio_less_impl<_R1, _R2, false, true>
    : __ratio_less_impl_1<ratio<-_R2::num, _R2::den>,
           ratio<-_R1::num, _R1::den> >::type
    { };


  template<typename _R1, typename _R2>
    struct ratio_less
    : __ratio_less_impl<_R1, _R2>::type
    { };


  template<typename _R1, typename _R2>
    struct ratio_less_equal
    : integral_constant<bool, !ratio_less<_R2, _R1>::value>
    { };


  template<typename _R1, typename _R2>
    struct ratio_greater
    : integral_constant<bool, ratio_less<_R2, _R1>::value>
    { };


  template<typename _R1, typename _R2>
    struct ratio_greater_equal
    : integral_constant<bool, !ratio_less<_R1, _R2>::value>
    { };


  template <typename _R1, typename _R2>
    inline constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_less_equal_v =
      ratio_less_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_greater_equal_v
    = ratio_greater_equal<_R1, _R2>::value;


  template<typename _R1, typename _R2,
      bool = (_R1::num >= 0),
      bool = (_R2::num >= 0),
      bool = ratio_less<ratio<__static_abs<_R1::num>::value, _R1::den>,
        ratio<__static_abs<_R2::num>::value, _R2::den> >::value>
    struct __ratio_add_impl
    {
    private:
      typedef typename __ratio_add_impl<
        ratio<-_R1::num, _R1::den>,
        ratio<-_R2::num, _R2::den> >::type __t;
    public:
      typedef ratio<-__t::num, __t::den> type;
    };


  template<typename _R1, typename _R2, bool __b>
    struct __ratio_add_impl<_R1, _R2, true, true, __b>
    {
    private:
      static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
      static constexpr uintmax_t __d2 = _R2::den / __g;
      typedef __big_mul<_R1::den, __d2> __d;
      typedef __big_mul<_R1::num, _R2::den / __g> __x;
      typedef __big_mul<_R2::num, _R1::den / __g> __y;
      typedef __big_add<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
      static_assert(__n::__hi >= __x::__hi, "Internal library error");
      typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
      static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
      typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
      static_assert(__n_final::__rem == 0, "Internal library error");
      static_assert(__n_final::__quot_hi == 0 &&
        __n_final::__quot_lo <= 9223372036854775807L, "overflow in addition");
      typedef __big_mul<_R1::den / __g2, __d2> __d_final;
      static_assert(__d_final::__hi == 0 &&
        __d_final::__lo <= 9223372036854775807L, "overflow in addition");
    public:
      typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
    };

  template<typename _R1, typename _R2>
    struct __ratio_add_impl<_R1, _R2, false, true, true>
    : __ratio_add_impl<_R2, _R1>
    { };


  template<typename _R1, typename _R2>
    struct __ratio_add_impl<_R1, _R2, true, false, false>
    {
    private:
      static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
      static constexpr uintmax_t __d2 = _R2::den / __g;
      typedef __big_mul<_R1::den, __d2> __d;
      typedef __big_mul<_R1::num, _R2::den / __g> __x;
      typedef __big_mul<-_R2::num, _R1::den / __g> __y;
      typedef __big_sub<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
      typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
      static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
      typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
      static_assert(__n_final::__rem == 0, "Internal library error");
      static_assert(__n_final::__quot_hi == 0 &&
        __n_final::__quot_lo <= 9223372036854775807L, "overflow in addition");
      typedef __big_mul<_R1::den / __g2, __d2> __d_final;
      static_assert(__d_final::__hi == 0 &&
        __d_final::__lo <= 9223372036854775807L, "overflow in addition");
    public:
      typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
    };

  template<typename _R1, typename _R2>
    struct __ratio_add
    {
      typedef typename __ratio_add_impl<_R1, _R2>::type type;
      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_add<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_add<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_add = typename __ratio_add<_R1, _R2>::type;

  template<typename _R1, typename _R2>
    struct __ratio_subtract
    {
      typedef typename __ratio_add<
        _R1,
        ratio<-_R2::num, _R2::den>>::type type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_subtract<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_subtract<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;


  typedef ratio<1, 1000000000000000000> atto;
  typedef ratio<1, 1000000000000000> femto;
  typedef ratio<1, 1000000000000> pico;
  typedef ratio<1, 1000000000> nano;
  typedef ratio<1, 1000000> micro;
  typedef ratio<1, 1000> milli;
  typedef ratio<1, 100> centi;
  typedef ratio<1, 10> deci;
  typedef ratio< 10, 1> deca;
  typedef ratio< 100, 1> hecto;
  typedef ratio< 1000, 1> kilo;
  typedef ratio< 1000000, 1> mega;
  typedef ratio< 1000000000, 1> giga;
  typedef ratio< 1000000000000, 1> tera;
  typedef ratio< 1000000000000000, 1> peta;
  typedef ratio< 1000000000000000000, 1> exa;



}
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ctime" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ctime" 3
# 58 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/parse_numbers.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/parse_numbers.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __parse_int
{
  template<unsigned _Base, char _Dig>
    struct _Digit;

  template<unsigned _Base>
    struct _Digit<_Base, '0'> : integral_constant<unsigned, 0>
    {
      using __valid = true_type;
    };

  template<unsigned _Base>
    struct _Digit<_Base, '1'> : integral_constant<unsigned, 1>
    {
      using __valid = true_type;
    };

  template<unsigned _Base, unsigned _Val>
    struct _Digit_impl : integral_constant<unsigned, _Val>
    {
      static_assert(_Base > _Val, "invalid digit");
      using __valid = true_type;
    };

  template<unsigned _Base>
    struct _Digit<_Base, '2'> : _Digit_impl<_Base, 2>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '3'> : _Digit_impl<_Base, 3>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '4'> : _Digit_impl<_Base, 4>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '5'> : _Digit_impl<_Base, 5>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '6'> : _Digit_impl<_Base, 6>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '7'> : _Digit_impl<_Base, 7>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '8'> : _Digit_impl<_Base, 8>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '9'> : _Digit_impl<_Base, 9>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'a'> : _Digit_impl<_Base, 0xa>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'A'> : _Digit_impl<_Base, 0xa>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'b'> : _Digit_impl<_Base, 0xb>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'B'> : _Digit_impl<_Base, 0xb>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'c'> : _Digit_impl<_Base, 0xc>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'C'> : _Digit_impl<_Base, 0xc>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'd'> : _Digit_impl<_Base, 0xd>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'D'> : _Digit_impl<_Base, 0xd>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'e'> : _Digit_impl<_Base, 0xe>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'E'> : _Digit_impl<_Base, 0xe>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'f'> : _Digit_impl<_Base, 0xf>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'F'> : _Digit_impl<_Base, 0xf>
    { };


  template<unsigned _Base>
    struct _Digit<_Base, '\''> : integral_constant<unsigned, 0>
    {
      using __valid = false_type;
    };



  template<unsigned long long _Val>
    using __ull_constant = integral_constant<unsigned long long, _Val>;

  template<unsigned _Base, char _Dig, char... _Digs>
    struct _Power_help
    {
      using __next = typename _Power_help<_Base, _Digs...>::type;
      using __valid_digit = typename _Digit<_Base, _Dig>::__valid;
      using type
 = __ull_constant<__next::value * (__valid_digit{} ? _Base : 1ULL)>;
    };

  template<unsigned _Base, char _Dig>
    struct _Power_help<_Base, _Dig>
    {
      using __valid_digit = typename _Digit<_Base, _Dig>::__valid;
      using type = __ull_constant<__valid_digit::value>;
    };

  template<unsigned _Base, char... _Digs>
    struct _Power : _Power_help<_Base, _Digs...>::type
    { };

  template<unsigned _Base>
    struct _Power<_Base> : __ull_constant<0>
    { };



  template<unsigned _Base, unsigned long long _Pow, char _Dig, char... _Digs>
    struct _Number_help
    {
      using __digit = _Digit<_Base, _Dig>;
      using __valid_digit = typename __digit::__valid;
      using __next = _Number_help<_Base,
      __valid_digit::value ? _Pow / _Base : _Pow,
      _Digs...>;
      using type = __ull_constant<_Pow * __digit::value + __next::type::value>;
      static_assert((type::value / _Pow) == __digit::value,
      "integer literal does not fit in unsigned long long");
    };


  template<unsigned _Base, unsigned long long _Pow, char _Dig, char..._Digs>
    struct _Number_help<_Base, _Pow, '\'', _Dig, _Digs...>
    : _Number_help<_Base, _Pow, _Dig, _Digs...>
    { };


  template<unsigned _Base, unsigned long long _Pow, char _Dig>
    struct _Number_help<_Base, _Pow, _Dig>
    {

      using type = __ull_constant<_Digit<_Base, _Dig>::value>;
    };

  template<unsigned _Base, char... _Digs>
    struct _Number
    : _Number_help<_Base, _Power<_Base, _Digs...>::value, _Digs...>::type
    { };

  template<unsigned _Base>
    struct _Number<_Base>
    : __ull_constant<0>
    { };



  template<char... _Digs>
    struct _Parse_int;

  template<char... _Digs>
    struct _Parse_int<'0', 'b', _Digs...>
    : _Number<2U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', 'B', _Digs...>
    : _Number<2U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', 'x', _Digs...>
    : _Number<16U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', 'X', _Digs...>
    : _Number<16U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', _Digs...>
    : _Number<8U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int
    : _Number<10U, _Digs...>::type
    { };

}


namespace __select_int
{
  template<unsigned long long _Val, typename... _Ints>
    struct _Select_int_base;

  template<unsigned long long _Val, typename _IntType, typename... _Ints>
    struct _Select_int_base<_Val, _IntType, _Ints...>
    : conditional_t<(_Val <= std::numeric_limits<_IntType>::max()),
      integral_constant<_IntType, _Val>,
      _Select_int_base<_Val, _Ints...>>
    { };

  template<unsigned long long _Val>
    struct _Select_int_base<_Val>
    { };

  template<char... _Digs>
    using _Select_int = typename _Select_int_base<
 __parse_int::_Parse_int<_Digs...>::value,
 unsigned char,
 unsigned short,
 unsigned int,
 unsigned long,
 unsigned long long
      >::type;

}


}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 3
  namespace chrono
  {


    template<typename _Rep, typename _Period = ratio<1>>
      struct duration;

    template<typename _Clock, typename _Dur = typename _Clock::duration>
      struct time_point;


  }





  template<typename _CT, typename _Period1, typename _Period2>
    struct __duration_common_type_wrapper
    {
    private:
      typedef __static_gcd<_Period1::num, _Period2::num> __gcd_num;
      typedef __static_gcd<_Period1::den, _Period2::den> __gcd_den;
      typedef typename _CT::type __cr;
      typedef ratio<__gcd_num::value,
        (_Period1::den / __gcd_den::value) * _Period2::den> __r;
    public:
      typedef __success_type<chrono::duration<__cr, __r>> type;
    };

  template<typename _Period1, typename _Period2>
    struct __duration_common_type_wrapper<__failure_type, _Period1, _Period2>
    { typedef __failure_type type; };

  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>
    struct common_type<chrono::duration<_Rep1, _Period1>,
             chrono::duration<_Rep2, _Period2>>
    : public __duration_common_type_wrapper<typename __member_type_wrapper<
             common_type<_Rep1, _Rep2>>::type, _Period1, _Period2>::type
    { };



  template<typename _CT, typename _Clock>
    struct __timepoint_common_type_wrapper
    {
      typedef __success_type<chrono::time_point<_Clock, typename _CT::type>>
        type;
    };

  template<typename _Clock>
    struct __timepoint_common_type_wrapper<__failure_type, _Clock>
    { typedef __failure_type type; };

  template<typename _Clock, typename _Duration1, typename _Duration2>
    struct common_type<chrono::time_point<_Clock, _Duration1>,
             chrono::time_point<_Clock, _Duration2>>
    : public __timepoint_common_type_wrapper<typename __member_type_wrapper<
             common_type<_Duration1, _Duration2>>::type, _Clock>::type
    { };



  namespace chrono
  {



    template<typename _ToDur, typename _CF, typename _CR,
      bool _NumIsOne = false, bool _DenIsOne = false>
      struct __duration_cast_impl
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())
       * static_cast<_CR>(_CF::num)
       / static_cast<_CR>(_CF::den)));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(__d.count()));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(
       static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(
       static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
   }
      };

    template<typename _Tp>
      struct __is_duration
      : std::false_type
      { };

    template<typename _Rep, typename _Period>
      struct __is_duration<duration<_Rep, _Period>>
      : std::true_type
      { };


    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr typename enable_if<__is_duration<_ToDur>::value,
       _ToDur>::type
      duration_cast(const duration<_Rep, _Period>& __d)
      {
 typedef typename _ToDur::period __to_period;
 typedef typename _ToDur::rep __to_rep;
 typedef ratio_divide<_Period, __to_period> __cf;
 typedef typename common_type<__to_rep, _Rep, intmax_t>::type
          __cr;
 typedef __duration_cast_impl<_ToDur, __cf, __cr,
          __cf::num == 1, __cf::den == 1> __dc;
 return __dc::__cast(__d);
      }


    template<typename _Rep>
      struct treat_as_floating_point
      : is_floating_point<_Rep>
      { };


    template <typename _Rep>
      inline constexpr bool treat_as_floating_point_v =
        treat_as_floating_point<_Rep>::value;





    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr enable_if_t<__is_duration<_ToDur>::value, _ToDur>
      floor(const duration<_Rep, _Period>& __d)
      {
 auto __to = chrono::duration_cast<_ToDur>(__d);
 if (__to > __d)
   return __to - _ToDur{1};
 return __to;
      }

    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr enable_if_t<__is_duration<_ToDur>::value, _ToDur>
      ceil(const duration<_Rep, _Period>& __d)
      {
 auto __to = chrono::duration_cast<_ToDur>(__d);
 if (__to < __d)
   return __to + _ToDur{1};
 return __to;
      }

    template <typename _ToDur, typename _Rep, typename _Period>
      constexpr enable_if_t<
 __and_<__is_duration<_ToDur>,
        __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
 _ToDur>
      round(const duration<_Rep, _Period>& __d)
      {
 _ToDur __t0 = chrono::floor<_ToDur>(__d);
 _ToDur __t1 = __t0 + _ToDur{1};
 auto __diff0 = __d - __t0;
 auto __diff1 = __t1 - __d;
 if (__diff0 == __diff1)
 {
     if (__t0.count() & 1)
  return __t1;
     return __t0;
 }
 else if (__diff0 < __diff1)
     return __t0;
 return __t1;
      }

    template<typename _Rep, typename _Period>
      constexpr
      enable_if_t<numeric_limits<_Rep>::is_signed, duration<_Rep, _Period>>
      abs(duration<_Rep, _Period> __d)
      {
 if (__d >= __d.zero())
   return __d;
 return -__d;
      }



    template<typename _Rep>
      struct duration_values
      {
 static constexpr _Rep
 zero()
 { return _Rep(0); }

 static constexpr _Rep
 max()
 { return numeric_limits<_Rep>::max(); }

 static constexpr _Rep
 min()
 { return numeric_limits<_Rep>::lowest(); }
      };

    template<typename _Tp>
      struct __is_ratio
      : std::false_type
      { };

    template<intmax_t _Num, intmax_t _Den>
      struct __is_ratio<ratio<_Num, _Den>>
      : std::true_type
      { };


    template<typename _Rep, typename _Period>
      struct duration
      {
 typedef _Rep rep;
 typedef _Period period;

 static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
 static_assert(__is_ratio<_Period>::value,
        "period must be a specialization of ratio");
 static_assert(_Period::num > 0, "period must be positive");


 constexpr duration() = default;




 duration(const duration&) = default;



 template<typename _Rep2, typename = typename
        enable_if<is_convertible<const _Rep2&, rep>::value
    && (treat_as_floating_point<rep>::value
        || !treat_as_floating_point<_Rep2>::value)>::type>
   constexpr explicit duration(const _Rep2& __rep)
   : __r(static_cast<rep>(__rep)) { }

 template<typename _Rep2, typename _Period2, typename = typename
        enable_if<treat_as_floating_point<rep>::value
    || (ratio_divide<_Period2, period>::den == 1
        && !treat_as_floating_point<_Rep2>::value)>::type>
   constexpr duration(const duration<_Rep2, _Period2>& __d)
   : __r(duration_cast<duration>(__d).count()) { }

 ~duration() = default;
 duration& operator=(const duration&) = default;


 constexpr rep
 count() const
 { return __r; }


 constexpr duration
 operator+() const
 { return *this; }

 constexpr duration
 operator-() const
 { return duration(-__r); }

 constexpr duration&
 operator++()
 {
   ++__r;
   return *this;
 }

 constexpr duration
 operator++(int)
 { return duration(__r++); }

 constexpr duration&
 operator--()
 {
   --__r;
   return *this;
 }

 constexpr duration
 operator--(int)
 { return duration(__r--); }

 constexpr duration&
 operator+=(const duration& __d)
 {
   __r += __d.count();
   return *this;
 }

 constexpr duration&
 operator-=(const duration& __d)
 {
   __r -= __d.count();
   return *this;
 }

 constexpr duration&
 operator*=(const rep& __rhs)
 {
   __r *= __rhs;
   return *this;
 }

 constexpr duration&
 operator/=(const rep& __rhs)
 {
   __r /= __rhs;
   return *this;
 }


 template<typename _Rep2 = rep>
   constexpr
   typename enable_if<!treat_as_floating_point<_Rep2>::value,
        duration&>::type
   operator%=(const rep& __rhs)
   {
     __r %= __rhs;
     return *this;
   }

 template<typename _Rep2 = rep>
   constexpr
   typename enable_if<!treat_as_floating_point<_Rep2>::value,
        duration&>::type
   operator%=(const duration& __d)
   {
     __r %= __d.count();
     return *this;
   }


 static constexpr duration
 zero()
 { return duration(duration_values<rep>::zero()); }

 static constexpr duration
 min()
 { return duration(duration_values<rep>::min()); }

 static constexpr duration
 max()
 { return duration(duration_values<rep>::max()); }

      private:
 rep __r;
      };

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator+(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() + __cd(__rhs).count());
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator-(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() - __cd(__rhs).count());
      }





    template<typename _Rep1, typename _Rep2, bool =
      is_convertible<const _Rep2&,
       typename common_type<_Rep1, _Rep2>::type>::value>
      struct __common_rep_type { };

    template<typename _Rep1, typename _Rep2>
      struct __common_rep_type<_Rep1, _Rep2, true>
      { typedef typename common_type<_Rep1, _Rep2>::type type; };

    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr
      duration<typename __common_rep_type<_Rep1, _Rep2>::type, _Period>
      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() * __s);
      }

    template<typename _Rep1, typename _Rep2, typename _Period>
      constexpr
      duration<typename __common_rep_type<_Rep2, _Rep1>::type, _Period>
      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
      { return __d * __s; }

    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr duration<typename __common_rep_type<_Rep1, typename
 enable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>
      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() / __s);
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<_Rep1, _Rep2>::type
      operator/(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__lhs).count() / __cd(__rhs).count();
      }


    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr duration<typename __common_rep_type<_Rep1, typename
 enable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>
      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() % __s);
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator%(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() % __cd(__rhs).count());
      }


    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator==(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __ct;
 return __ct(__lhs).count() == __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator<(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __ct;
 return __ct(__lhs).count() < __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator!=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs == __rhs); }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator<=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator>(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator>=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs < __rhs); }


    typedef duration<int64_t, nano> nanoseconds;


    typedef duration<int64_t, micro> microseconds;


    typedef duration<int64_t, milli> milliseconds;


    typedef duration<int64_t> seconds;


    typedef duration<int64_t, ratio< 60>> minutes;


    typedef duration<int64_t, ratio<3600>> hours;


    template<typename _Clock, typename _Dur>
      struct time_point
      {
 typedef _Clock clock;
 typedef _Dur duration;
 typedef typename duration::rep rep;
 typedef typename duration::period period;

 constexpr time_point() : __d(duration::zero())
 { }

 constexpr explicit time_point(const duration& __dur)
 : __d(__dur)
 { }


 template<typename _Dur2,
   typename = _Require<is_convertible<_Dur2, _Dur>>>
   constexpr time_point(const time_point<clock, _Dur2>& __t)
   : __d(__t.time_since_epoch())
   { }


 constexpr duration
 time_since_epoch() const
 { return __d; }


 constexpr time_point&
 operator+=(const duration& __dur)
 {
   __d += __dur;
   return *this;
 }

 constexpr time_point&
 operator-=(const duration& __dur)
 {
   __d -= __dur;
   return *this;
 }


 static constexpr time_point
 min()
 { return time_point(duration::min()); }

 static constexpr time_point
 max()
 { return time_point(duration::max()); }

      private:
 duration __d;
      };


    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr typename enable_if<__is_duration<_ToDur>::value,
       time_point<_Clock, _ToDur>>::type
      time_point_cast(const time_point<_Clock, _Dur>& __t)
      {
 typedef time_point<_Clock, _ToDur> __time_point;
 return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
      }


    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr
      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
      floor(const time_point<_Clock, _Dur>& __tp)
      {
 return time_point<_Clock, _ToDur>{
     chrono::floor<_ToDur>(__tp.time_since_epoch())};
      }

    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr
      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
      ceil(const time_point<_Clock, _Dur>& __tp)
      {
 return time_point<_Clock, _ToDur>{
     chrono::ceil<_ToDur>(__tp.time_since_epoch())};
      }

    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr enable_if_t<
 __and_<__is_duration<_ToDur>,
        __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
 time_point<_Clock, _ToDur>>
      round(const time_point<_Clock, _Dur>& __tp)
      {
 return time_point<_Clock, _ToDur>{
     chrono::round<_ToDur>(__tp.time_since_epoch())};
      }


    template<typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
 typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator+(const time_point<_Clock, _Dur1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<_Dur1,__dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__lhs.time_since_epoch() + __rhs);
      }

    template<typename _Rep1, typename _Period1,
      typename _Clock, typename _Dur2>
      constexpr time_point<_Clock,
 typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
      operator+(const duration<_Rep1, _Period1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef typename common_type<__dur1,_Dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__rhs.time_since_epoch() + __lhs);
      }

    template<typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
 typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator-(const time_point<_Clock, _Dur1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<_Dur1,__dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__lhs.time_since_epoch() -__rhs);
      }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr typename common_type<_Dur1, _Dur2>::type
      operator-(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator==(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator!=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs == __rhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() < __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs < __rhs); }
# 811 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 3
    inline namespace _V2 {






    struct system_clock
    {
      typedef chrono::nanoseconds duration;
      typedef duration::rep rep;
      typedef duration::period period;
      typedef chrono::time_point<system_clock, duration> time_point;

      static_assert(system_clock::duration::min()
      < system_clock::duration::zero(),
      "a clock's minimum duration cannot be less than its epoch");

      static constexpr bool is_steady = false;

      static time_point
      now() noexcept;


      static std::time_t
      to_time_t(const time_point& __t) noexcept
      {
 return std::time_t(duration_cast<chrono::seconds>
      (__t.time_since_epoch()).count());
      }

      static time_point
      from_time_t(std::time_t __t) noexcept
      {
 typedef chrono::time_point<system_clock, seconds> __from;
 return time_point_cast<system_clock::duration>
        (__from(chrono::seconds(__t)));
      }
    };







    struct steady_clock
    {
      typedef chrono::nanoseconds duration;
      typedef duration::rep rep;
      typedef duration::period period;
      typedef chrono::time_point<steady_clock, duration> time_point;

      static constexpr bool is_steady = true;

      static time_point
      now() noexcept;
    };
# 878 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/chrono" 3
    using high_resolution_clock = system_clock;

    }


  }





  inline namespace literals
  {
  inline namespace chrono_literals
  {


    template<typename _Rep, unsigned long long _Val>
      struct _Checked_integral_constant
      : integral_constant<_Rep, static_cast<_Rep>(_Val)>
      {
 static_assert(_Checked_integral_constant::value >= 0
        && _Checked_integral_constant::value == _Val,
        "literal value cannot be represented by duration type");
      };

    template<typename _Dur, char... _Digits>
      constexpr _Dur __check_overflow()
      {
 using _Val = __parse_int::_Parse_int<_Digits...>;
 using _Rep = typename _Dur::rep;


 using _CheckedVal = _Checked_integral_constant<_Rep, _Val::value>;
 return _Dur{_CheckedVal::value};
      }

    constexpr chrono::duration<long double, ratio<3600,1>>
    operator""h(long double __hours)
    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }

    template <char... _Digits>
      constexpr chrono::hours
      operator""h()
      { return __check_overflow<chrono::hours, _Digits...>(); }

    constexpr chrono::duration<long double, ratio<60,1>>
    operator""min(long double __mins)
    { return chrono::duration<long double, ratio<60,1>>{__mins}; }

    template <char... _Digits>
      constexpr chrono::minutes
      operator""min()
      { return __check_overflow<chrono::minutes, _Digits...>(); }

    constexpr chrono::duration<long double>
    operator""s(long double __secs)
    { return chrono::duration<long double>{__secs}; }

    template <char... _Digits>
      constexpr chrono::seconds
      operator""s()
      { return __check_overflow<chrono::seconds, _Digits...>(); }

    constexpr chrono::duration<long double, milli>
    operator""ms(long double __msecs)
    { return chrono::duration<long double, milli>{__msecs}; }

    template <char... _Digits>
      constexpr chrono::milliseconds
      operator""ms()
      { return __check_overflow<chrono::milliseconds, _Digits...>(); }

    constexpr chrono::duration<long double, micro>
    operator""us(long double __usecs)
    { return chrono::duration<long double, micro>{__usecs}; }

    template <char... _Digits>
      constexpr chrono::microseconds
      operator""us()
      { return __check_overflow<chrono::microseconds, _Digits...>(); }

    constexpr chrono::duration<long double, nano>
    operator""ns(long double __nsecs)
    { return chrono::duration<long double, nano>{__nsecs}; }

    template <char... _Digits>
      constexpr chrono::nanoseconds
      operator""ns()
      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }


  }
  }

  namespace chrono
  {


  using namespace literals::chrono_literals;


  }




}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_mutex.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_mutex.h" 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_mutex.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_mutex.h" 3
  class __mutex_base
  {
  protected:
    typedef __gthread_mutex_t __native_type;


    __native_type _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };

    constexpr __mutex_base() noexcept = default;
# 81 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_mutex.h" 3
    __mutex_base(const __mutex_base&) = delete;
    __mutex_base& operator=(const __mutex_base&) = delete;
  };


  class mutex : private __mutex_base
  {
  public:
    typedef __native_type* native_handle_type;


    constexpr

    mutex() noexcept = default;
    ~mutex() = default;

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_mutex_trylock(&_M_mutex);
    }

    void
    unlock()
    {

      __gthread_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }
  };




  struct defer_lock_t { explicit defer_lock_t() = default; };


  struct try_to_lock_t { explicit try_to_lock_t() = default; };



  struct adopt_lock_t { explicit adopt_lock_t() = default; };


  inline constexpr defer_lock_t defer_lock { };


  inline constexpr try_to_lock_t try_to_lock { };


  inline constexpr adopt_lock_t adopt_lock { };






  template<typename _Mutex>
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }

      lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m)
      { }

      ~lock_guard()
      { _M_device.unlock(); }

      lock_guard(const lock_guard&) = delete;
      lock_guard& operator=(const lock_guard&) = delete;

    private:
      mutex_type& _M_device;
    };
# 184 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/std_mutex.h" 3
  template<typename _Mutex>
    class unique_lock
    {
    public:
      typedef _Mutex mutex_type;

      unique_lock() noexcept
      : _M_device(0), _M_owns(false)
      { }

      explicit unique_lock(mutex_type& __m)
      : _M_device(std::__addressof(__m)), _M_owns(false)
      {
 lock();
 _M_owns = true;
      }

      unique_lock(mutex_type& __m, defer_lock_t) noexcept
      : _M_device(std::__addressof(__m)), _M_owns(false)
      { }

      unique_lock(mutex_type& __m, try_to_lock_t)
      : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())
      { }

      unique_lock(mutex_type& __m, adopt_lock_t) noexcept
      : _M_device(std::__addressof(__m)), _M_owns(true)
      {

      }

      template<typename _Clock, typename _Duration>
 unique_lock(mutex_type& __m,
      const chrono::time_point<_Clock, _Duration>& __atime)
 : _M_device(std::__addressof(__m)),
   _M_owns(_M_device->try_lock_until(__atime))
 { }

      template<typename _Rep, typename _Period>
 unique_lock(mutex_type& __m,
      const chrono::duration<_Rep, _Period>& __rtime)
 : _M_device(std::__addressof(__m)),
   _M_owns(_M_device->try_lock_for(__rtime))
 { }

      ~unique_lock()
      {
 if (_M_owns)
   unlock();
      }

      unique_lock(const unique_lock&) = delete;
      unique_lock& operator=(const unique_lock&) = delete;

      unique_lock(unique_lock&& __u) noexcept
      : _M_device(__u._M_device), _M_owns(__u._M_owns)
      {
 __u._M_device = 0;
 __u._M_owns = false;
      }

      unique_lock& operator=(unique_lock&& __u) noexcept
      {
 if(_M_owns)
   unlock();

 unique_lock(std::move(__u)).swap(*this);

 __u._M_device = 0;
 __u._M_owns = false;

 return *this;
      }

      void
      lock()
      {
 if (!_M_device)
   __throw_system_error(int(errc::operation_not_permitted));
 else if (_M_owns)
   __throw_system_error(int(errc::resource_deadlock_would_occur));
 else
   {
     _M_device->lock();
     _M_owns = true;
   }
      }

      bool
      try_lock()
      {
 if (!_M_device)
   __throw_system_error(int(errc::operation_not_permitted));
 else if (_M_owns)
   __throw_system_error(int(errc::resource_deadlock_would_occur));
 else
   {
     _M_owns = _M_device->try_lock();
     return _M_owns;
   }
      }

      template<typename _Clock, typename _Duration>
 bool
 try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
 {
   if (!_M_device)
     __throw_system_error(int(errc::operation_not_permitted));
   else if (_M_owns)
     __throw_system_error(int(errc::resource_deadlock_would_occur));
   else
     {
       _M_owns = _M_device->try_lock_until(__atime);
       return _M_owns;
     }
 }

      template<typename _Rep, typename _Period>
 bool
 try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
 {
   if (!_M_device)
     __throw_system_error(int(errc::operation_not_permitted));
   else if (_M_owns)
     __throw_system_error(int(errc::resource_deadlock_would_occur));
   else
     {
       _M_owns = _M_device->try_lock_for(__rtime);
       return _M_owns;
     }
  }

      void
      unlock()
      {
 if (!_M_owns)
   __throw_system_error(int(errc::operation_not_permitted));
 else if (_M_device)
   {
     _M_device->unlock();
     _M_owns = false;
   }
      }

      void
      swap(unique_lock& __u) noexcept
      {
 std::swap(_M_device, __u._M_device);
 std::swap(_M_owns, __u._M_owns);
      }

      mutex_type*
      release() noexcept
      {
 mutex_type* __ret = _M_device;
 _M_device = 0;
 _M_owns = false;
 return __ret;
      }

      bool
      owns_lock() const noexcept
      { return _M_owns; }

      explicit operator bool() const noexcept
      { return owns_lock(); }

      mutex_type*
      mutex() const noexcept
      { return _M_device; }

    private:
      mutex_type* _M_device;
      bool _M_owns;
    };


  template<typename _Mutex>
    inline void
    swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
    { __x.swap(__y); }



}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 2 3
# 54 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 66 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  class __recursive_mutex_base
  {
  protected:
    typedef __gthread_recursive_mutex_t __native_type;

    __recursive_mutex_base(const __recursive_mutex_base&) = delete;
    __recursive_mutex_base& operator=(const __recursive_mutex_base&) = delete;


    __native_type _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };

    __recursive_mutex_base() = default;
# 90 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  };


  class recursive_mutex : private __recursive_mutex_base
  {
  public:
    typedef __native_type* native_handle_type;

    recursive_mutex() = default;
    ~recursive_mutex() = default;

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_recursive_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_recursive_mutex_trylock(&_M_mutex);
    }

    void
    unlock()
    {

      __gthread_recursive_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }
  };


  template<typename _Derived>
    class __timed_mutex_impl
    {
    protected:
      typedef chrono::high_resolution_clock __clock_t;

      template<typename _Rep, typename _Period>
 bool
 _M_try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
 {
   using chrono::steady_clock;
   auto __rt = chrono::duration_cast<steady_clock::duration>(__rtime);
   if (ratio_greater<steady_clock::period, _Period>())
     ++__rt;
   return _M_try_lock_until(steady_clock::now() + __rt);
 }

      template<typename _Duration>
 bool
 _M_try_lock_until(const chrono::time_point<__clock_t,
         _Duration>& __atime)
 {
   auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
   auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

   __gthread_time_t __ts = {
     static_cast<std::time_t>(__s.time_since_epoch().count()),
     static_cast<long>(__ns.count())
   };

   return static_cast<_Derived*>(this)->_M_timedlock(__ts);
 }

      template<typename _Clock, typename _Duration>
 bool
 _M_try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
 {
   auto __rtime = __atime - _Clock::now();
   return _M_try_lock_until(__clock_t::now() + __rtime);
 }
    };


  class timed_mutex
  : private __mutex_base, public __timed_mutex_impl<timed_mutex>
  {
  public:
    typedef __native_type* native_handle_type;

    timed_mutex() = default;
    ~timed_mutex() = default;

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_mutex_trylock(&_M_mutex);
    }

    template <class _Rep, class _Period>
      bool
      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
      { return _M_try_lock_for(__rtime); }

    template <class _Clock, class _Duration>
      bool
      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
      { return _M_try_lock_until(__atime); }

    void
    unlock()
    {

      __gthread_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }

    private:
      friend class __timed_mutex_impl<timed_mutex>;

      bool
      _M_timedlock(const __gthread_time_t& __ts)
      { return !__gthread_mutex_timedlock(&_M_mutex, &__ts); }
  };


  class recursive_timed_mutex
  : private __recursive_mutex_base,
    public __timed_mutex_impl<recursive_timed_mutex>
  {
  public:
    typedef __native_type* native_handle_type;

    recursive_timed_mutex() = default;
    ~recursive_timed_mutex() = default;

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_recursive_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_recursive_mutex_trylock(&_M_mutex);
    }

    template <class _Rep, class _Period>
      bool
      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
      { return _M_try_lock_for(__rtime); }

    template <class _Clock, class _Duration>
      bool
      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
      { return _M_try_lock_until(__atime); }

    void
    unlock()
    {

      __gthread_recursive_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }

    private:
      friend class __timed_mutex_impl<recursive_timed_mutex>;

      bool
      _M_timedlock(const __gthread_time_t& __ts)
      { return !__gthread_recursive_mutex_timedlock(&_M_mutex, &__ts); }
  };
# 467 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  template<typename _Lock>
    inline unique_lock<_Lock>
    __try_to_lock(_Lock& __l)
    { return unique_lock<_Lock>{__l, try_to_lock}; }

  template<int _Idx, bool _Continue = true>
    struct __try_lock_impl
    {
      template<typename... _Lock>
 static void
 __do_try_lock(tuple<_Lock&...>& __locks, int& __idx)
 {
          __idx = _Idx;
          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));
          if (__lock.owns_lock())
            {
       constexpr bool __cont = _Idx + 2 < sizeof...(_Lock);
       using __try_locker = __try_lock_impl<_Idx + 1, __cont>;
       __try_locker::__do_try_lock(__locks, __idx);
              if (__idx == -1)
                __lock.release();
            }
 }
    };

  template<int _Idx>
    struct __try_lock_impl<_Idx, false>
    {
      template<typename... _Lock>
 static void
 __do_try_lock(tuple<_Lock&...>& __locks, int& __idx)
 {
          __idx = _Idx;
          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));
          if (__lock.owns_lock())
            {
              __idx = -1;
              __lock.release();
            }
 }
    };
# 519 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  template<typename _Lock1, typename _Lock2, typename... _Lock3>
    int
    try_lock(_Lock1& __l1, _Lock2& __l2, _Lock3&... __l3)
    {
      int __idx;
      auto __locks = std::tie(__l1, __l2, __l3...);
      __try_lock_impl<0>::__do_try_lock(__locks, __idx);
      return __idx;
    }
# 540 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  template<typename _L1, typename _L2, typename... _L3>
    void
    lock(_L1& __l1, _L2& __l2, _L3&... __l3)
    {
      while (true)
        {
          using __try_locker = __try_lock_impl<0, sizeof...(_L3) != 0>;
          unique_lock<_L1> __first(__l1);
          int __idx;
          auto __locks = std::tie(__l2, __l3...);
          __try_locker::__do_try_lock(__locks, __idx);
          if (__idx == -1)
            {
              __first.release();
              return;
            }
        }
    }
# 566 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  template<typename... _MutexTypes>
    class scoped_lock
    {
    public:
      explicit scoped_lock(_MutexTypes&... __m) : _M_devices(std::tie(__m...))
      { std::lock(__m...); }

      explicit scoped_lock(adopt_lock_t, _MutexTypes&... __m) noexcept
      : _M_devices(std::tie(__m...))
      { }

      ~scoped_lock()
      {
 std::apply([](_MutexTypes&... __m) {
   char __i[] __attribute__((__unused__)) = { (__m.unlock(), 0)... };
 }, _M_devices);
      }

      scoped_lock(const scoped_lock&) = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;

    private:
      tuple<_MutexTypes&...> _M_devices;
    };

  template<>
    class scoped_lock<>
    {
    public:
      explicit scoped_lock() = default;
      explicit scoped_lock(adopt_lock_t) noexcept { }
      ~scoped_lock() = default;

      scoped_lock(const scoped_lock&) = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;
    };

  template<typename _Mutex>
    class scoped_lock<_Mutex>
    {
    public:
      using mutex_type = _Mutex;

      explicit scoped_lock(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }

      explicit scoped_lock(adopt_lock_t, mutex_type& __m) noexcept
      : _M_device(__m)
      { }

      ~scoped_lock()
      { _M_device.unlock(); }

      scoped_lock(const scoped_lock&) = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;

    private:
      mutex_type& _M_device;
    };




  struct once_flag
  {
  private:
    typedef __gthread_once_t __native_type;
    __native_type _M_once = 0;

  public:

    constexpr once_flag() noexcept = default;


    once_flag(const once_flag&) = delete;

    once_flag& operator=(const once_flag&) = delete;

    template<typename _Callable, typename... _Args>
      friend void
      call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);
  };


  extern __thread void* __once_callable;
  extern __thread void (*__once_call)();
# 662 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
  extern "C" void __once_proxy(void);


  template<typename _Callable, typename... _Args>
    void
    call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)
    {


      auto __callable = [&] {
   std::__invoke(std::forward<_Callable>(__f),
   std::forward<_Args>(__args)...);
      };

      __once_callable = std::__addressof(__callable);
      __once_call = []{ (*(decltype(__callable)*)__once_callable)(); };






      int __e = __gthread_once(&__once._M_once, &__once_proxy);
# 697 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/mutex" 3
      if (__e)
 __throw_system_error(__e);
    }




}
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stl.hpp" 2 3



inline namespace cl {
namespace sycl {

 template < class T, class Alloc = std::allocator<T> >
 using vector_class = std::vector<T, Alloc>;

 using string_class = std::string;

 template <class Sig>
 using function_class = std::function<Sig>;

 using mutex_class = std::mutex;

 template <class T, class Deleter = std::default_delete<T>>
 using unique_ptr_class = std::unique_ptr<T, Deleter>;

 template <class T>
 using shared_ptr_class = std::shared_ptr<T>;

 template <class T>
 using weak_ptr_class = std::weak_ptr<T>;

 template <class T>
 using hash_class = std::hash<T>;

 using exception_ptr_class = std::exception_ptr;

 template <typename T, typename... ArgsT>
 unique_ptr_class<T> make_unique_ptr(ArgsT &&... Args) {
   return unique_ptr_class<T>(new T(std::forward<ArgsT>(Args)...));
 }
}
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/exception.hpp" 2 3



inline namespace cl {
namespace sycl {


class context;




class __attribute__((visibility("default"))) exception : public std::exception {
public:
  exception() = default;

  const char *what() const noexcept final override;

  bool has_context() const;

  context get_context() const;

  cl_int get_cl_code() const;

private:
  string_class MMsg;
  cl_int MCLErr;
  shared_ptr_class<context> MContext;

protected:
  exception(const char *Msg, const cl_int CLErr,
            shared_ptr_class<context> Context = nullptr)
      : exception(string_class(Msg), CLErr, Context) {}

  exception(const string_class &Msg, const cl_int CLErr,
            shared_ptr_class<context> Context = nullptr)
      : MMsg(Msg + " " + detail::codeToString(CLErr)), MCLErr(CLErr),
        MContext(Context) {}
};

class runtime_error : public exception {
public:
  runtime_error() = default;

  runtime_error(const char *Msg, cl_int Err)
      : runtime_error(string_class(Msg), Err) {}

  runtime_error(const string_class &Msg, cl_int Err) : exception(Msg, Err) {}
};
class kernel_error : public runtime_error {
  using runtime_error::runtime_error;
};
class accessor_error : public runtime_error {
  using runtime_error::runtime_error;
};
class nd_range_error : public runtime_error {
  using runtime_error::runtime_error;
};
class event_error : public runtime_error {
  using runtime_error::runtime_error;
};
class invalid_parameter_error : public runtime_error {
  using runtime_error::runtime_error;
};
class device_error : public exception {
public:
  device_error() = default;

  device_error(const char *Msg, cl_int Err)
      : device_error(string_class(Msg), Err) {}

  device_error(const string_class &Msg, cl_int Err) : exception(Msg, Err) {}
};
class compile_program_error : public device_error {
  using device_error::device_error;
};
class link_program_error : public device_error {
  using device_error::device_error;
};
class invalid_object_error : public device_error {
  using device_error::device_error;
};
class memory_allocation_error : public device_error {
  using device_error::device_error;
};
class platform_error : public device_error {
  using device_error::device_error;
};
class profiling_error : public device_error {
  using device_error::device_error;
};
class feature_not_supported : public device_error {
  using device_error::device_error;
};

}
}
# 122 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 2 3
# 147 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {
# 163 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/common.hpp" 3
template <class Obj> decltype(Obj::impl) getSyclObjImpl(const Obj &SyclObject) {
  return SyclObject.impl;
}




template <class T>
typename std::add_pointer<typename decltype(T::impl)::element_type>::type
getRawSyclObjImpl(const T &SyclObject) {
  return SyclObject.impl.get();
}





template <class T> T createSyclObjFromImpl(decltype(T::impl) ImplObj) {
  return T(ImplObj);
}



template <int N, template <int> class T> struct InitializedVal {
  template <int Val> static T<N> get();
};


template <template <int> class T> struct InitializedVal<1, T> {
  template <int Val> static T<1> get() { return T<1>{Val}; }
};


template <template <int> class T> struct InitializedVal<2, T> {
  template <int Val> static T<2> get() { return T<2>{Val, Val}; }
};


template <template <int> class T> struct InitializedVal<3, T> {
  template <int Val> static T<3> get() { return T<3>{Val, Val, Val}; }
};


template <int NDIMS, int DIM, template <int> class LoopBoundTy, typename FuncTy,
          template <int> class LoopIndexTy>
struct NDLoopIterateImpl {
  NDLoopIterateImpl(const LoopIndexTy<NDIMS> &LowerBound,
                    const LoopBoundTy<NDIMS> &Stride,
                    const LoopBoundTy<NDIMS> &UpperBound, FuncTy f,
                    LoopIndexTy<NDIMS> &Index) {
    constexpr size_t AdjIdx = NDIMS - 1 - DIM;
    for (Index[AdjIdx] = LowerBound[AdjIdx]; Index[AdjIdx] < UpperBound[AdjIdx];
         Index[AdjIdx] += Stride[AdjIdx]) {

      NDLoopIterateImpl<NDIMS, DIM - 1, LoopBoundTy, FuncTy, LoopIndexTy>{
          LowerBound, Stride, UpperBound, f, Index};
    }
  }
};


template <int NDIMS, template <int> class LoopBoundTy, typename FuncTy,
          template <int> class LoopIndexTy>
struct NDLoopIterateImpl<NDIMS, 0, LoopBoundTy, FuncTy, LoopIndexTy> {
  NDLoopIterateImpl(const LoopIndexTy<NDIMS> &LowerBound,
                    const LoopBoundTy<NDIMS> &Stride,
                    const LoopBoundTy<NDIMS> &UpperBound, FuncTy f,
                    LoopIndexTy<NDIMS> &Index) {

    constexpr size_t AdjIdx = NDIMS - 1;
    for (Index[AdjIdx] = LowerBound[AdjIdx]; Index[AdjIdx] < UpperBound[AdjIdx];
         Index[AdjIdx] += Stride[AdjIdx]) {

      f(Index);
    }
  }
};







template <int NDIMS> struct NDLoop {



  template <template <int> class LoopBoundTy, typename FuncTy,
            template <int> class LoopIndexTy = LoopBoundTy>
  static __attribute__((always_inline)) void iterate(const LoopBoundTy<NDIMS> &UpperBound,
                                    FuncTy f) {
    const LoopIndexTy<NDIMS> LowerBound =
        InitializedVal<NDIMS, LoopIndexTy>::template get<0>();
    const LoopBoundTy<NDIMS> Stride =
        InitializedVal<NDIMS, LoopBoundTy>::template get<1>();
    LoopIndexTy<NDIMS> Index =
        InitializedVal<NDIMS, LoopIndexTy>::template get<0>();

    NDLoopIterateImpl<NDIMS, NDIMS - 1, LoopBoundTy, FuncTy, LoopIndexTy>{
        LowerBound, Stride, UpperBound, f, Index};
  }




  template <template <int> class LoopBoundTy, typename FuncTy,
            template <int> class LoopIndexTy = LoopBoundTy>
  static __attribute__((always_inline)) void iterate(const LoopIndexTy<NDIMS> &LowerBound,
                                    const LoopBoundTy<NDIMS> &Stride,
                                    const LoopBoundTy<NDIMS> &UpperBound,
                                    FuncTy f) {
    LoopIndexTy<NDIMS> Index;
    NDLoopIterateImpl<NDIMS, NDIMS - 1, LoopBoundTy, FuncTy, LoopIndexTy>{
        LowerBound, Stride, UpperBound, f, Index};
  }
};

constexpr size_t getNextPowerOfTwoHelper(size_t Var, size_t Offset) {
  return Offset != 64
             ? getNextPowerOfTwoHelper(Var | (Var >> Offset), Offset * 2)
             : Var;
}


constexpr size_t getNextPowerOfTwo(size_t Var) {
  return getNextPowerOfTwoHelper(Var - 1, 1) + 1;
}


template <int Dims, template <int> class T, template <int> class U>
size_t getLinearIndex(const T<Dims> &Index, const U<Dims> &Range) {
  size_t LinearIndex = 0;
  for (int I = 0; I < Dims; ++I)
    LinearIndex = LinearIndex * Range[I] + Index[I];
  return LinearIndex;
}




using KernelSetId = size_t;


constexpr KernelSetId SpvFileKSId = 0;
constexpr KernelSetId LastKSId = SpvFileKSId;

template <typename T> struct InlineVariableHelper {
  static constexpr T value{};
};

template <typename T> constexpr T InlineVariableHelper<T>::value;
}
}
}
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 2 3


inline namespace cl {
namespace sycl {
namespace access {

enum class target {
  global_buffer = 2014,
  constant_buffer,
  local,
  image,
  host_buffer,
  host_image,
  image_array
};

enum class mode {
  read = 1024,
  write,
  read_write,
  discard_write,
  discard_read_write,
  atomic
};

enum class fence_space {
  local_space,
  global_space,
  global_and_local
};

enum class placeholder { false_t, true_t };

enum class address_space : int {
  private_space = 0,
  global_space,
  constant_space,
  local_space,
  global_device_space,
  global_host_space
};

}

using access::target;
using access_mode = access::mode;

template <access_mode mode> struct mode_tag_t {
  explicit mode_tag_t() = default;
};

template <access_mode mode, target trgt> struct mode_target_tag_t {
  explicit mode_target_tag_t() = default;
};



inline constexpr mode_tag_t<access_mode::read> read_only{};
inline constexpr mode_tag_t<access_mode::read_write> read_write{};
inline constexpr mode_tag_t<access_mode::write> write_only{};
inline constexpr mode_target_tag_t<access_mode::read, target::constant_buffer>
    read_constant{};
# 91 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 3
namespace detail {

constexpr bool isTargetHostAccess(access::target T) {
  return T == access::target::host_buffer || T == access::target::host_image;
}

constexpr bool modeNeedsOldData(access::mode m) {
  return m == access::mode::read || m == access::mode::write ||
         m == access::mode::read_write || m == access::mode::atomic;
}

constexpr bool modeWritesNewData(access::mode m) {
  return m != access::mode::read;
}
# 127 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 3
template <access::target accessTarget> struct TargetToAS {
  constexpr static access::address_space AS =
      access::address_space::global_space;
};
# 139 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 3
template <> struct TargetToAS<access::target::local> {
  constexpr static access::address_space AS =
      access::address_space::local_space;
};

template <> struct TargetToAS<access::target::constant_buffer> {
  constexpr static access::address_space AS =
      access::address_space::constant_space;
};

template <typename ElementType, access::address_space addressSpace>
struct PtrValueType;

template <typename ElementType>
struct PtrValueType<ElementType, access::address_space::private_space> {
  using type = ElementType;
};

template <typename ElementType>
struct PtrValueType<ElementType, access::address_space::global_space> {
  using type = ElementType;
};

template <typename ElementType>
struct PtrValueType<ElementType, access::address_space::global_device_space> {
  using type = ElementType;
};

template <typename ElementType>
struct PtrValueType<ElementType, access::address_space::global_host_space> {
  using type = ElementType;
};

template <typename ElementType>
struct PtrValueType<ElementType, access::address_space::constant_space> {
# 182 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 3
  using type = ElementType;

};

template <typename ElementType>
struct PtrValueType<ElementType, access::address_space::local_space> {
  using type = ElementType;
};

template <class T>
struct remove_AS {
  typedef T type;
};
# 235 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/access/access.hpp" 3
}

}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/__spirv/spirv_vars.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/backend_types.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/backend_types.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/basic_file.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/basic_file.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++io.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++io.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdio" 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/x86_64-linux-gnu/c++/7.5.0/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* __lock = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 71 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 147 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      { this->close(); }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 296 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 306 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 323 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 355 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 375 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 421 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 454 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 481 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 494 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 510 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 533 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 565 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 594 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 614 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 632 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 655 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 682 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 696 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 714 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 737 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 769 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 798 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 819 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 838 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 861 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 889 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 901 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }

      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 939 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 971 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1000 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1021 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1040 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/fstream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/fstream.tcc" 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     _M_file.close();
     throw;
   }
 catch(...)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
    if (overflow() == traits_type::eof())
      return __ret;
    _M_set_buffer(-1);
    _M_writing = false;
  }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
     && __testin)
   {

     const streamsize __avail = this->egptr() - this->gptr();
     if (__avail != 0)
       {
        traits_type::copy(__s, this->gptr(), __avail);
         __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail,
     this->egptr());
        __ret += __avail;
        __n -= __avail;
       }



     streamsize __len;
     for (;;)
       {
         __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
           __n);
         if (__len == -1)
    __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

         if (__len == 0)
    break;

         __n -= __len;
         __ret += __len;
         if (__n == 0)
    break;

         __s += __len;
       }

     if (__n == 0)
       {

         _M_reading = true;
       }
     else if (__len == 0)
       {



         _M_set_buffer(-1);
         _M_reading = false;
       }
   }
      else
   __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
     && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 787 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1082 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fstream" 2 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/backend_types.hpp" 2 3




inline namespace cl {
namespace sycl {

enum class backend : char { host, opencl, level_zero, cuda };

template <backend name, typename SYCLObjectT> struct interop;

inline std::ostream &operator<<(std::ostream &Out, backend be) {
  switch (be) {
  case backend::host:
    Out << std::string("host");
    break;
  case backend::opencl:
    Out << std::string("opencl");
    break;
  case backend::level_zero:
    Out << std::string("level_zero");
    break;
  case backend::cuda:
    Out << std::string("cuda");
  }
  return Out;
}

}
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/os_util.hpp" 1 3
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/os_util.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdlib.h" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/os_util.hpp" 2 3
# 40 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/os_util.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {



using OSModuleHandle = intptr_t;


class __attribute__((visibility("default"))) OSUtil {
public:

  static OSModuleHandle getOSModuleHandle(const void *VirtAddr);


  static std::string getCurrentDSODir();


  static std::string getDirName(const char *Path);



  static constexpr OSModuleHandle ExeModuleHandle = -1;



  static constexpr OSModuleHandle DummyModuleHandle = -2;




  static constexpr const char *DirSep = "/";



  static size_t getOSMemSize();



  static void *alignedAlloc(size_t Alignment, size_t NumBytes);


  static void alignedFree(void *Ptr);
};

}
}
}
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cassert" 1 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cassert" 2 3
# 23 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 165 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 189 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 242 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 356 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 379 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 415 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 433 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 484 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 523 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 559 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 577 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 628 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 667 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 702 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 718 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 769 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/sstream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 827 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/sstream" 2 3
# 25 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 2 3
# 35 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 3
inline namespace cl {
namespace sycl {

class context;

namespace detail {

enum class PiApiKind {


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.def" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.def" 3
piPlatformsGet,
piPlatformGetInfo,
piextPlatformGetNativeHandle,
piextPlatformCreateWithNativeHandle,

piDevicesGet,
piDeviceGetInfo,
piDevicePartition,
piDeviceRetain,
piDeviceRelease,
piextDeviceSelectBinary,
piextGetDeviceFunctionPointer,
piextDeviceGetNativeHandle,
piextDeviceCreateWithNativeHandle,

piContextCreate,
piContextGetInfo,
piContextRetain,
piContextRelease,
piextContextSetExtendedDeleter,
piextContextGetNativeHandle,
piextContextCreateWithNativeHandle,

piQueueCreate,
piQueueGetInfo,
piQueueFinish,
piQueueRetain,
piQueueRelease,
piextQueueGetNativeHandle,
piextQueueCreateWithNativeHandle,

piMemBufferCreate,
piMemImageCreate,
piMemGetInfo,
piMemImageGetInfo,
piMemRetain,
piMemRelease,
piMemBufferPartition,
piextMemGetNativeHandle,
piextMemCreateWithNativeHandle,

piProgramCreate,
piclProgramCreateWithSource,
piProgramCreateWithBinary,
piProgramGetInfo,
piProgramCompile,
piProgramBuild,
piProgramLink,
piProgramGetBuildInfo,
piProgramRetain,
piProgramRelease,
piextProgramSetSpecializationConstant,
piextProgramGetNativeHandle,
piextProgramCreateWithNativeHandle,

piKernelCreate,
piKernelSetArg,
piKernelGetInfo,
piKernelGetGroupInfo,
piKernelGetSubGroupInfo,
piKernelRetain,
piKernelRelease,
piextKernelSetArgPointer,
piKernelSetExecInfo,

piEventCreate,
piEventGetInfo,
piEventGetProfilingInfo,
piEventsWait,
piEventSetCallback,
piEventSetStatus,
piEventRetain,
piEventRelease,
piextEventGetNativeHandle,
piextEventCreateWithNativeHandle,

piSamplerCreate,
piSamplerGetInfo,
piSamplerRetain,
piSamplerRelease,

piEnqueueKernelLaunch,
piEnqueueNativeKernel,
piEnqueueEventsWait,
piEnqueueEventsWaitWithBarrier,
piEnqueueMemBufferRead,
piEnqueueMemBufferReadRect,
piEnqueueMemBufferWrite,
piEnqueueMemBufferWriteRect,
piEnqueueMemBufferCopy,
piEnqueueMemBufferCopyRect,
piEnqueueMemBufferFill,
piEnqueueMemImageRead,
piEnqueueMemImageWrite,
piEnqueueMemImageCopy,
piEnqueueMemImageFill,
piEnqueueMemBufferMap,
piEnqueueMemUnmap,

piextUSMHostAlloc,
piextUSMDeviceAlloc,
piextUSMSharedAlloc,
piextUSMFree,
piextUSMEnqueueMemset,
piextUSMEnqueueMemcpy,
piextUSMEnqueuePrefetch,
piextUSMEnqueueMemAdvise,
piextUSMGetMemAllocInfo,

piextKernelSetArgMemObj,
piextKernelSetArgSampler,
# 45 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 2 3
};
class plugin;
namespace pi {



enum TraceLevel {
  PI_TRACE_BASIC = 0x1,
  PI_TRACE_CALLS = 0x2,
  PI_TRACE_ALL = -1
};


bool trace(TraceLevel level);
# 71 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 3
[[noreturn]] __attribute__((visibility("default"))) void die(const char *Message);

__attribute__((visibility("default"))) void assertion(bool Condition, const char *Message = nullptr);

template <typename T>
void handleUnknownParamName(const char *functionName, T parameter) {
  std::stringstream stream;
  stream << "Unknown parameter " << parameter << " passed to " << functionName
         << "\n";
  auto str = stream.str();
  auto msg = str.c_str();
  die(msg);
}







using PiPlugin = ::pi_plugin;
using PiResult = ::pi_result;
using PiPlatform = ::pi_platform;
using PiDevice = ::pi_device;
using PiDeviceType = ::pi_device_type;
using PiDeviceInfo = ::pi_device_info;
using PiProgramInfo = ::pi_program_info;
using PiDeviceBinaryType = ::pi_device_binary_type;
using PiContext = ::pi_context;
using PiProgram = ::pi_program;
using PiKernel = ::pi_kernel;
using PiQueue = ::pi_queue;
using PiQueueProperties = ::pi_queue_properties;
using PiMem = ::pi_mem;
using PiMemFlags = ::pi_mem_flags;
using PiEvent = ::pi_event;
using PiSampler = ::pi_sampler;
using PiSamplerInfo = ::pi_sampler_info;
using PiSamplerProperties = ::pi_sampler_properties;
using PiSamplerAddressingMode = ::pi_sampler_addressing_mode;
using PiSamplerFilterMode = ::pi_sampler_filter_mode;
using PiMemImageFormat = ::pi_image_format;
using PiMemImageDesc = ::pi_image_desc;
using PiMemImageInfo = ::pi_image_info;
using PiMemObjectType = ::pi_mem_type;
using PiMemImageChannelOrder = ::pi_image_channel_order;
using PiMemImageChannelType = ::pi_image_channel_type;

__attribute__((visibility("default"))) void contextSetExtendedDeleter(const cl::sycl::context &constext,
                                             pi_context_extended_deleter func,
                                             void *user_data);



void *loadOsLibrary(const std::string &Library);



void *getOsLibraryFuncAddress(void *Library, const std::string &FunctionName);


std::string platformInfoToString(pi_platform_info info);


template <class To, class From> To cast(From value);




extern std::shared_ptr<plugin> GlobalPlugin;


const vector_class<plugin> &initialize();


template <backend BE> const plugin &getPlugin();


template <PiApiKind PiApiOffset> struct PiFuncInfo {};
# 159 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.def" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.def" 3
template <> struct PiFuncInfo<PiApiKind::piPlatformsGet> { using FuncPtrT = decltype(&::piPlatformsGet); inline std::string getFuncName() { return "piPlatformsGet"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piPlatformsGet; } };
template <> struct PiFuncInfo<PiApiKind::piPlatformGetInfo> { using FuncPtrT = decltype(&::piPlatformGetInfo); inline std::string getFuncName() { return "piPlatformGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piPlatformGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piextPlatformGetNativeHandle> { using FuncPtrT = decltype(&::piextPlatformGetNativeHandle); inline std::string getFuncName() { return "piextPlatformGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextPlatformGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextPlatformCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextPlatformCreateWithNativeHandle); inline std::string getFuncName() { return "piextPlatformCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextPlatformCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piDevicesGet> { using FuncPtrT = decltype(&::piDevicesGet); inline std::string getFuncName() { return "piDevicesGet"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piDevicesGet; } };
template <> struct PiFuncInfo<PiApiKind::piDeviceGetInfo> { using FuncPtrT = decltype(&::piDeviceGetInfo); inline std::string getFuncName() { return "piDeviceGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piDeviceGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piDevicePartition> { using FuncPtrT = decltype(&::piDevicePartition); inline std::string getFuncName() { return "piDevicePartition"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piDevicePartition; } };
template <> struct PiFuncInfo<PiApiKind::piDeviceRetain> { using FuncPtrT = decltype(&::piDeviceRetain); inline std::string getFuncName() { return "piDeviceRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piDeviceRetain; } };
template <> struct PiFuncInfo<PiApiKind::piDeviceRelease> { using FuncPtrT = decltype(&::piDeviceRelease); inline std::string getFuncName() { return "piDeviceRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piDeviceRelease; } };
template <> struct PiFuncInfo<PiApiKind::piextDeviceSelectBinary> { using FuncPtrT = decltype(&::piextDeviceSelectBinary); inline std::string getFuncName() { return "piextDeviceSelectBinary"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextDeviceSelectBinary; } };
template <> struct PiFuncInfo<PiApiKind::piextGetDeviceFunctionPointer> { using FuncPtrT = decltype(&::piextGetDeviceFunctionPointer); inline std::string getFuncName() { return "piextGetDeviceFunctionPointer"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextGetDeviceFunctionPointer; } };
template <> struct PiFuncInfo<PiApiKind::piextDeviceGetNativeHandle> { using FuncPtrT = decltype(&::piextDeviceGetNativeHandle); inline std::string getFuncName() { return "piextDeviceGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextDeviceGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextDeviceCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextDeviceCreateWithNativeHandle); inline std::string getFuncName() { return "piextDeviceCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextDeviceCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piContextCreate> { using FuncPtrT = decltype(&::piContextCreate); inline std::string getFuncName() { return "piContextCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piContextCreate; } };
template <> struct PiFuncInfo<PiApiKind::piContextGetInfo> { using FuncPtrT = decltype(&::piContextGetInfo); inline std::string getFuncName() { return "piContextGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piContextGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piContextRetain> { using FuncPtrT = decltype(&::piContextRetain); inline std::string getFuncName() { return "piContextRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piContextRetain; } };
template <> struct PiFuncInfo<PiApiKind::piContextRelease> { using FuncPtrT = decltype(&::piContextRelease); inline std::string getFuncName() { return "piContextRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piContextRelease; } };
template <> struct PiFuncInfo<PiApiKind::piextContextSetExtendedDeleter> { using FuncPtrT = decltype(&::piextContextSetExtendedDeleter); inline std::string getFuncName() { return "piextContextSetExtendedDeleter"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextContextSetExtendedDeleter; } };
template <> struct PiFuncInfo<PiApiKind::piextContextGetNativeHandle> { using FuncPtrT = decltype(&::piextContextGetNativeHandle); inline std::string getFuncName() { return "piextContextGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextContextGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextContextCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextContextCreateWithNativeHandle); inline std::string getFuncName() { return "piextContextCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextContextCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piQueueCreate> { using FuncPtrT = decltype(&::piQueueCreate); inline std::string getFuncName() { return "piQueueCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piQueueCreate; } };
template <> struct PiFuncInfo<PiApiKind::piQueueGetInfo> { using FuncPtrT = decltype(&::piQueueGetInfo); inline std::string getFuncName() { return "piQueueGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piQueueGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piQueueFinish> { using FuncPtrT = decltype(&::piQueueFinish); inline std::string getFuncName() { return "piQueueFinish"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piQueueFinish; } };
template <> struct PiFuncInfo<PiApiKind::piQueueRetain> { using FuncPtrT = decltype(&::piQueueRetain); inline std::string getFuncName() { return "piQueueRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piQueueRetain; } };
template <> struct PiFuncInfo<PiApiKind::piQueueRelease> { using FuncPtrT = decltype(&::piQueueRelease); inline std::string getFuncName() { return "piQueueRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piQueueRelease; } };
template <> struct PiFuncInfo<PiApiKind::piextQueueGetNativeHandle> { using FuncPtrT = decltype(&::piextQueueGetNativeHandle); inline std::string getFuncName() { return "piextQueueGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextQueueGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextQueueCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextQueueCreateWithNativeHandle); inline std::string getFuncName() { return "piextQueueCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextQueueCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piMemBufferCreate> { using FuncPtrT = decltype(&::piMemBufferCreate); inline std::string getFuncName() { return "piMemBufferCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemBufferCreate; } };
template <> struct PiFuncInfo<PiApiKind::piMemImageCreate> { using FuncPtrT = decltype(&::piMemImageCreate); inline std::string getFuncName() { return "piMemImageCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemImageCreate; } };
template <> struct PiFuncInfo<PiApiKind::piMemGetInfo> { using FuncPtrT = decltype(&::piMemGetInfo); inline std::string getFuncName() { return "piMemGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piMemImageGetInfo> { using FuncPtrT = decltype(&::piMemImageGetInfo); inline std::string getFuncName() { return "piMemImageGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemImageGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piMemRetain> { using FuncPtrT = decltype(&::piMemRetain); inline std::string getFuncName() { return "piMemRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemRetain; } };
template <> struct PiFuncInfo<PiApiKind::piMemRelease> { using FuncPtrT = decltype(&::piMemRelease); inline std::string getFuncName() { return "piMemRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemRelease; } };
template <> struct PiFuncInfo<PiApiKind::piMemBufferPartition> { using FuncPtrT = decltype(&::piMemBufferPartition); inline std::string getFuncName() { return "piMemBufferPartition"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piMemBufferPartition; } };
template <> struct PiFuncInfo<PiApiKind::piextMemGetNativeHandle> { using FuncPtrT = decltype(&::piextMemGetNativeHandle); inline std::string getFuncName() { return "piextMemGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextMemGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextMemCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextMemCreateWithNativeHandle); inline std::string getFuncName() { return "piextMemCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextMemCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piProgramCreate> { using FuncPtrT = decltype(&::piProgramCreate); inline std::string getFuncName() { return "piProgramCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramCreate; } };
template <> struct PiFuncInfo<PiApiKind::piclProgramCreateWithSource> { using FuncPtrT = decltype(&::piclProgramCreateWithSource); inline std::string getFuncName() { return "piclProgramCreateWithSource"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piclProgramCreateWithSource; } };
template <> struct PiFuncInfo<PiApiKind::piProgramCreateWithBinary> { using FuncPtrT = decltype(&::piProgramCreateWithBinary); inline std::string getFuncName() { return "piProgramCreateWithBinary"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramCreateWithBinary; } };
template <> struct PiFuncInfo<PiApiKind::piProgramGetInfo> { using FuncPtrT = decltype(&::piProgramGetInfo); inline std::string getFuncName() { return "piProgramGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piProgramCompile> { using FuncPtrT = decltype(&::piProgramCompile); inline std::string getFuncName() { return "piProgramCompile"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramCompile; } };
template <> struct PiFuncInfo<PiApiKind::piProgramBuild> { using FuncPtrT = decltype(&::piProgramBuild); inline std::string getFuncName() { return "piProgramBuild"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramBuild; } };
template <> struct PiFuncInfo<PiApiKind::piProgramLink> { using FuncPtrT = decltype(&::piProgramLink); inline std::string getFuncName() { return "piProgramLink"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramLink; } };
template <> struct PiFuncInfo<PiApiKind::piProgramGetBuildInfo> { using FuncPtrT = decltype(&::piProgramGetBuildInfo); inline std::string getFuncName() { return "piProgramGetBuildInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramGetBuildInfo; } };
template <> struct PiFuncInfo<PiApiKind::piProgramRetain> { using FuncPtrT = decltype(&::piProgramRetain); inline std::string getFuncName() { return "piProgramRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramRetain; } };
template <> struct PiFuncInfo<PiApiKind::piProgramRelease> { using FuncPtrT = decltype(&::piProgramRelease); inline std::string getFuncName() { return "piProgramRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piProgramRelease; } };
template <> struct PiFuncInfo<PiApiKind::piextProgramSetSpecializationConstant> { using FuncPtrT = decltype(&::piextProgramSetSpecializationConstant); inline std::string getFuncName() { return "piextProgramSetSpecializationConstant"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextProgramSetSpecializationConstant; } };
template <> struct PiFuncInfo<PiApiKind::piextProgramGetNativeHandle> { using FuncPtrT = decltype(&::piextProgramGetNativeHandle); inline std::string getFuncName() { return "piextProgramGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextProgramGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextProgramCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextProgramCreateWithNativeHandle); inline std::string getFuncName() { return "piextProgramCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextProgramCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piKernelCreate> { using FuncPtrT = decltype(&::piKernelCreate); inline std::string getFuncName() { return "piKernelCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelCreate; } };
template <> struct PiFuncInfo<PiApiKind::piKernelSetArg> { using FuncPtrT = decltype(&::piKernelSetArg); inline std::string getFuncName() { return "piKernelSetArg"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelSetArg; } };
template <> struct PiFuncInfo<PiApiKind::piKernelGetInfo> { using FuncPtrT = decltype(&::piKernelGetInfo); inline std::string getFuncName() { return "piKernelGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piKernelGetGroupInfo> { using FuncPtrT = decltype(&::piKernelGetGroupInfo); inline std::string getFuncName() { return "piKernelGetGroupInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelGetGroupInfo; } };
template <> struct PiFuncInfo<PiApiKind::piKernelGetSubGroupInfo> { using FuncPtrT = decltype(&::piKernelGetSubGroupInfo); inline std::string getFuncName() { return "piKernelGetSubGroupInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelGetSubGroupInfo; } };
template <> struct PiFuncInfo<PiApiKind::piKernelRetain> { using FuncPtrT = decltype(&::piKernelRetain); inline std::string getFuncName() { return "piKernelRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelRetain; } };
template <> struct PiFuncInfo<PiApiKind::piKernelRelease> { using FuncPtrT = decltype(&::piKernelRelease); inline std::string getFuncName() { return "piKernelRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelRelease; } };
template <> struct PiFuncInfo<PiApiKind::piextKernelSetArgPointer> { using FuncPtrT = decltype(&::piextKernelSetArgPointer); inline std::string getFuncName() { return "piextKernelSetArgPointer"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextKernelSetArgPointer; } };
template <> struct PiFuncInfo<PiApiKind::piKernelSetExecInfo> { using FuncPtrT = decltype(&::piKernelSetExecInfo); inline std::string getFuncName() { return "piKernelSetExecInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piKernelSetExecInfo; } };

template <> struct PiFuncInfo<PiApiKind::piEventCreate> { using FuncPtrT = decltype(&::piEventCreate); inline std::string getFuncName() { return "piEventCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventCreate; } };
template <> struct PiFuncInfo<PiApiKind::piEventGetInfo> { using FuncPtrT = decltype(&::piEventGetInfo); inline std::string getFuncName() { return "piEventGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piEventGetProfilingInfo> { using FuncPtrT = decltype(&::piEventGetProfilingInfo); inline std::string getFuncName() { return "piEventGetProfilingInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventGetProfilingInfo; } };
template <> struct PiFuncInfo<PiApiKind::piEventsWait> { using FuncPtrT = decltype(&::piEventsWait); inline std::string getFuncName() { return "piEventsWait"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventsWait; } };
template <> struct PiFuncInfo<PiApiKind::piEventSetCallback> { using FuncPtrT = decltype(&::piEventSetCallback); inline std::string getFuncName() { return "piEventSetCallback"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventSetCallback; } };
template <> struct PiFuncInfo<PiApiKind::piEventSetStatus> { using FuncPtrT = decltype(&::piEventSetStatus); inline std::string getFuncName() { return "piEventSetStatus"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventSetStatus; } };
template <> struct PiFuncInfo<PiApiKind::piEventRetain> { using FuncPtrT = decltype(&::piEventRetain); inline std::string getFuncName() { return "piEventRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventRetain; } };
template <> struct PiFuncInfo<PiApiKind::piEventRelease> { using FuncPtrT = decltype(&::piEventRelease); inline std::string getFuncName() { return "piEventRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEventRelease; } };
template <> struct PiFuncInfo<PiApiKind::piextEventGetNativeHandle> { using FuncPtrT = decltype(&::piextEventGetNativeHandle); inline std::string getFuncName() { return "piextEventGetNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextEventGetNativeHandle; } };
template <> struct PiFuncInfo<PiApiKind::piextEventCreateWithNativeHandle> { using FuncPtrT = decltype(&::piextEventCreateWithNativeHandle); inline std::string getFuncName() { return "piextEventCreateWithNativeHandle"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextEventCreateWithNativeHandle; } };

template <> struct PiFuncInfo<PiApiKind::piSamplerCreate> { using FuncPtrT = decltype(&::piSamplerCreate); inline std::string getFuncName() { return "piSamplerCreate"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piSamplerCreate; } };
template <> struct PiFuncInfo<PiApiKind::piSamplerGetInfo> { using FuncPtrT = decltype(&::piSamplerGetInfo); inline std::string getFuncName() { return "piSamplerGetInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piSamplerGetInfo; } };
template <> struct PiFuncInfo<PiApiKind::piSamplerRetain> { using FuncPtrT = decltype(&::piSamplerRetain); inline std::string getFuncName() { return "piSamplerRetain"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piSamplerRetain; } };
template <> struct PiFuncInfo<PiApiKind::piSamplerRelease> { using FuncPtrT = decltype(&::piSamplerRelease); inline std::string getFuncName() { return "piSamplerRelease"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piSamplerRelease; } };

template <> struct PiFuncInfo<PiApiKind::piEnqueueKernelLaunch> { using FuncPtrT = decltype(&::piEnqueueKernelLaunch); inline std::string getFuncName() { return "piEnqueueKernelLaunch"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueKernelLaunch; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueNativeKernel> { using FuncPtrT = decltype(&::piEnqueueNativeKernel); inline std::string getFuncName() { return "piEnqueueNativeKernel"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueNativeKernel; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueEventsWait> { using FuncPtrT = decltype(&::piEnqueueEventsWait); inline std::string getFuncName() { return "piEnqueueEventsWait"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueEventsWait; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueEventsWaitWithBarrier> { using FuncPtrT = decltype(&::piEnqueueEventsWaitWithBarrier); inline std::string getFuncName() { return "piEnqueueEventsWaitWithBarrier"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueEventsWaitWithBarrier; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferRead> { using FuncPtrT = decltype(&::piEnqueueMemBufferRead); inline std::string getFuncName() { return "piEnqueueMemBufferRead"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferRead; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferReadRect> { using FuncPtrT = decltype(&::piEnqueueMemBufferReadRect); inline std::string getFuncName() { return "piEnqueueMemBufferReadRect"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferReadRect; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferWrite> { using FuncPtrT = decltype(&::piEnqueueMemBufferWrite); inline std::string getFuncName() { return "piEnqueueMemBufferWrite"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferWrite; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferWriteRect> { using FuncPtrT = decltype(&::piEnqueueMemBufferWriteRect); inline std::string getFuncName() { return "piEnqueueMemBufferWriteRect"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferWriteRect; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferCopy> { using FuncPtrT = decltype(&::piEnqueueMemBufferCopy); inline std::string getFuncName() { return "piEnqueueMemBufferCopy"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferCopy; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferCopyRect> { using FuncPtrT = decltype(&::piEnqueueMemBufferCopyRect); inline std::string getFuncName() { return "piEnqueueMemBufferCopyRect"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferCopyRect; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferFill> { using FuncPtrT = decltype(&::piEnqueueMemBufferFill); inline std::string getFuncName() { return "piEnqueueMemBufferFill"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferFill; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemImageRead> { using FuncPtrT = decltype(&::piEnqueueMemImageRead); inline std::string getFuncName() { return "piEnqueueMemImageRead"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemImageRead; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemImageWrite> { using FuncPtrT = decltype(&::piEnqueueMemImageWrite); inline std::string getFuncName() { return "piEnqueueMemImageWrite"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemImageWrite; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemImageCopy> { using FuncPtrT = decltype(&::piEnqueueMemImageCopy); inline std::string getFuncName() { return "piEnqueueMemImageCopy"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemImageCopy; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemImageFill> { using FuncPtrT = decltype(&::piEnqueueMemImageFill); inline std::string getFuncName() { return "piEnqueueMemImageFill"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemImageFill; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemBufferMap> { using FuncPtrT = decltype(&::piEnqueueMemBufferMap); inline std::string getFuncName() { return "piEnqueueMemBufferMap"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemBufferMap; } };
template <> struct PiFuncInfo<PiApiKind::piEnqueueMemUnmap> { using FuncPtrT = decltype(&::piEnqueueMemUnmap); inline std::string getFuncName() { return "piEnqueueMemUnmap"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piEnqueueMemUnmap; } };

template <> struct PiFuncInfo<PiApiKind::piextUSMHostAlloc> { using FuncPtrT = decltype(&::piextUSMHostAlloc); inline std::string getFuncName() { return "piextUSMHostAlloc"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMHostAlloc; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMDeviceAlloc> { using FuncPtrT = decltype(&::piextUSMDeviceAlloc); inline std::string getFuncName() { return "piextUSMDeviceAlloc"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMDeviceAlloc; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMSharedAlloc> { using FuncPtrT = decltype(&::piextUSMSharedAlloc); inline std::string getFuncName() { return "piextUSMSharedAlloc"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMSharedAlloc; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMFree> { using FuncPtrT = decltype(&::piextUSMFree); inline std::string getFuncName() { return "piextUSMFree"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMFree; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMEnqueueMemset> { using FuncPtrT = decltype(&::piextUSMEnqueueMemset); inline std::string getFuncName() { return "piextUSMEnqueueMemset"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMEnqueueMemset; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMEnqueueMemcpy> { using FuncPtrT = decltype(&::piextUSMEnqueueMemcpy); inline std::string getFuncName() { return "piextUSMEnqueueMemcpy"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMEnqueueMemcpy; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMEnqueuePrefetch> { using FuncPtrT = decltype(&::piextUSMEnqueuePrefetch); inline std::string getFuncName() { return "piextUSMEnqueuePrefetch"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMEnqueuePrefetch; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMEnqueueMemAdvise> { using FuncPtrT = decltype(&::piextUSMEnqueueMemAdvise); inline std::string getFuncName() { return "piextUSMEnqueueMemAdvise"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMEnqueueMemAdvise; } };
template <> struct PiFuncInfo<PiApiKind::piextUSMGetMemAllocInfo> { using FuncPtrT = decltype(&::piextUSMGetMemAllocInfo); inline std::string getFuncName() { return "piextUSMGetMemAllocInfo"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextUSMGetMemAllocInfo; } };

template <> struct PiFuncInfo<PiApiKind::piextKernelSetArgMemObj> { using FuncPtrT = decltype(&::piextKernelSetArgMemObj); inline std::string getFuncName() { return "piextKernelSetArgMemObj"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextKernelSetArgMemObj; } };
template <> struct PiFuncInfo<PiApiKind::piextKernelSetArgSampler> { using FuncPtrT = decltype(&::piextKernelSetArgSampler); inline std::string getFuncName() { return "piextKernelSetArgSampler"; } inline FuncPtrT getFuncPtr(PiPlugin MPlugin) { return MPlugin.PiFunctionTable.piextKernelSetArgSampler; } };
# 160 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp" 2 3





uint64_t emitFunctionBeginTrace(const char *FName);





void emitFunctionEndTrace(uint64_t CorrelationID, const char *FName);




template <typename T> inline void print(T val) {
  std::cout << "<unknown> : " << val << std::endl;
}

template <> inline void print<>(PiPlatform val) {
  std::cout << "pi_platform : " << val << std::endl;
}

template <> inline void print<>(PiEvent val) {
  std::cout << "pi_event : " << val << std::endl;
}

template <> inline void print<>(PiMem val) {
  std::cout << "pi_mem : " << val << std::endl;
}

template <> inline void print<>(PiEvent *val) {
  std::cout << "pi_event * : " << val;
  if (val) {
    std::cout << "[ " << *val << " ... ]";
  }
  std::cout << std::endl;
}

template <> inline void print<>(const PiEvent *val) {
  std::cout << "const pi_event * : " << val;
  if (val) {
    std::cout << "[ " << *val << " ... ]";
  }
  std::cout << std::endl;
}

template <> inline void print<>(PiResult val) {
  std::cout << "pi_result : ";
  if (val == PI_SUCCESS)
    std::cout << "PI_SUCCESS" << std::endl;
  else
    std::cout << val << std::endl;
}


template <> inline void print<>(std::nullptr_t val) { print<void *>(val); }

inline void printArgs(void) {}
template <typename Arg0, typename... Args>
void printArgs(Arg0 arg0, Args... args) {
  std::cout << "       ";
  print(arg0);
  pi::printArgs(std::forward<Args>(args)...);
}

template <typename T>
struct printOut { printOut(T val) {(void)val;} };

template<> struct printOut<PiEvent *> {
  printOut(PiEvent *val) {
  std::cout << std::endl << "       ";
  std::cout << "[out]pi_event * : " << val;
  if (val) {
    std::cout << "[ " << *val << " ... ]";
  }
}};

template<> struct printOut<PiMem *> {
  printOut(PiMem *val) {
  std::cout << std::endl << "       ";
  std::cout << "[out]pi_mem * : " << val;
  if (val) {
    std::cout << "[ " << *val << " ... ]";
  }
}};

template<> struct printOut<void *> {
  printOut(void *val) {
  std::cout << std::endl << "       ";
  std::cout << "[out]void * : " << val;
}};

template<typename T> struct printOut<T **> {
  printOut(T **val) {
  std::cout << std::endl << "       ";
  std::cout << "[out]<unknown> ** : " << val;
  if (val) {
    std::cout << "[ " << *val << " ... ]";
  }
}};

inline void printOuts(void) {}
template <typename Arg0, typename... Args>
void printOuts(Arg0 arg0, Args... args) {
  using T = decltype(arg0);
  printOut<T> a(arg0);
  printOuts(std::forward<Args>(args)...);
}


class ByteArray {
public:
  using ConstIterator = const std::uint8_t *;

  ByteArray(const std::uint8_t *Ptr, std::size_t Size) : Ptr{Ptr}, Size{Size} {}
  const std::uint8_t &operator[](std::size_t Idx) const { return Ptr[Idx]; }
  std::size_t size() const { return Size; }
  ConstIterator begin() const { return Ptr; }
  ConstIterator end() const { return Ptr + Size; }

private:
  const std::uint8_t *Ptr;
  const std::size_t Size;
};


class DeviceBinaryProperty {
public:
  DeviceBinaryProperty(const _pi_device_binary_property_struct *Prop)
      : Prop(Prop) {}

  pi_uint32 asUint32() const;
  ByteArray asByteArray() const;
  const char *asCString() const;

protected:
  friend std::ostream &operator<<(std::ostream &Out,
                                  const DeviceBinaryProperty &P);
  const _pi_device_binary_property_struct *Prop;
};

std::ostream &operator<<(std::ostream &Out, const DeviceBinaryProperty &P);


class DeviceBinaryImage {
public:


  class PropertyRange {
  public:
    using ValTy = std::remove_pointer<pi_device_binary_property>::type;

    class ConstIterator
        : public std::iterator<std::input_iterator_tag,
                               ValTy,
                               ptrdiff_t,
                               const pi_device_binary_property,
                               pi_device_binary_property>
    {
      pi_device_binary_property Cur;

    public:
      ConstIterator(pi_device_binary_property Cur = nullptr) : Cur(Cur) {}
      ConstIterator &operator++() {
        Cur++;
        return *this;
      }
      ConstIterator operator++(int) {
        ConstIterator Ret = *this;
        ++(*this);
        return Ret;
      }
      bool operator==(ConstIterator Other) const { return Cur == Other.Cur; }
      bool operator!=(ConstIterator Other) const { return !(*this == Other); }
      reference operator*() const { return Cur; }
    };
    ConstIterator begin() const { return ConstIterator(Begin); }
    ConstIterator end() const { return ConstIterator(End); }
    friend class DeviceBinaryImage;
    bool isAvailable() const { return !(Begin == nullptr); }

  private:
    PropertyRange() : Begin(nullptr), End(nullptr) {}



    PropertyRange(pi_device_binary Bin, const char *PropSetName)
        : PropertyRange() {
      init(Bin, PropSetName);
    };
    void init(pi_device_binary Bin, const char *PropSetName);
    pi_device_binary_property Begin;
    pi_device_binary_property End;
  };

public:
  DeviceBinaryImage(pi_device_binary Bin) { init(Bin); }
  DeviceBinaryImage() : Bin(nullptr){};

  virtual void print() const;
  virtual void dump(std::ostream &Out) const;

  size_t getSize() const {
    (static_cast <bool> (Bin && "binary image data not set") ? void (0) : __assert_fail ("Bin && \"binary image data not set\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp", 365, __extension__ __PRETTY_FUNCTION__));
    return static_cast<size_t>(Bin->BinaryEnd - Bin->BinaryStart);
  }

  const char *getCompileOptions() const {
    (static_cast <bool> (Bin && "binary image data not set") ? void (0) : __assert_fail ("Bin && \"binary image data not set\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp", 370, __extension__ __PRETTY_FUNCTION__));
    return Bin->CompileOptions;
  }

  const char *getLinkOptions() const {
    (static_cast <bool> (Bin && "binary image data not set") ? void (0) : __assert_fail ("Bin && \"binary image data not set\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp", 375, __extension__ __PRETTY_FUNCTION__));
    return Bin->LinkOptions;
  }


  pi::PiDeviceBinaryType getFormat() const {
    (static_cast <bool> (Bin && "binary image data not set") ? void (0) : __assert_fail ("Bin && \"binary image data not set\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/pi.hpp", 381, __extension__ __PRETTY_FUNCTION__));
    return Format;
  }





  const PropertyRange &getSpecConstants() const { return SpecConstIDMap; }
  const PropertyRange &getDeviceLibReqMask() const { return DeviceLibReqMask; }
  const PropertyRange &getKernelParamOptInfo() const {
    return KernelParamOptInfo;
  }
  virtual ~DeviceBinaryImage() {}

protected:
  void init(pi_device_binary Bin);
  pi_device_binary get() const { return Bin; }

  pi_device_binary Bin;
  pi::PiDeviceBinaryType Format = PI_DEVICE_BINARY_TYPE_NONE;
  DeviceBinaryImage::PropertyRange SpecConstIDMap;
  DeviceBinaryImage::PropertyRange DeviceLibReqMask;
  DeviceBinaryImage::PropertyRange KernelParamOptInfo;
};



PiDeviceBinaryType getBinaryImageFormat(const unsigned char *ImgData,
                                        size_t ImgSize);
}

namespace RT = cl::sycl::detail::pi;






namespace pi {


template <class To, class From> inline To cast(From value) {

  RT::assertion((sizeof(From) == sizeof(To)), "assert: cast failed size check");
  return (To)(value);
}


template <> inline pi::PiProgram cast(cl_program) {
  RT::assertion(false, "pi::cast -> use piextCreateProgramWithNativeHandle");
  return {};
}

template <> inline pi::PiDevice cast(cl_device_id) {
  RT::assertion(false, "pi::cast -> use piextCreateDeviceWithNativeHandle");
  return {};
}

}
}


namespace RT = cl::sycl::detail::pi;

}
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/type_traits.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/type_traits.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_lists.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_lists.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/stl_type_traits.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/stl_type_traits.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iterator" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iterator" 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stream_iterator.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      constexpr istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(std::__addressof(__s))
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return std::__addressof((operator*())); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 152 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_string(0) {}
# 184 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 67 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/iterator" 2 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/stl_type_traits.hpp" 2 3



inline namespace cl {
namespace sycl {
namespace detail {




template <bool B, class T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template <bool B, class T, class F>
using conditional_t = typename std::conditional<B, T, F>::type;

template <typename T>
using remove_const_t = typename std::remove_const<T>::type;

template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;

template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;

template <typename T> using add_pointer_t = typename std::add_pointer<T>::type;

template <typename T> using remove_cv_t = typename std::remove_cv<T>::type;

template <typename T>
using remove_reference_t = typename std::remove_reference<T>::type;


template <bool V> using bool_constant = std::integral_constant<bool, V>;

template <class...> using void_t = void;


template <typename T>
using allocator_value_type_t = typename std::allocator_traits<T>::value_type;

template <typename T>
using allocator_pointer_t = typename std::allocator_traits<T>::pointer;

template <typename T>
using iterator_category_t = typename std::iterator_traits<T>::iterator_category;

template <typename T>
using iterator_value_type_t = typename std::iterator_traits<T>::value_type;

template <typename T>
using iterator_pointer_t = typename std::iterator_traits<T>::pointer;

template <typename T>
using iterator_to_const_type_t =
    std::is_const<typename std::remove_pointer<iterator_pointer_t<T>>::type>;



template <typename T>
using output_iterator_requirements =
    void_t<iterator_category_t<T>,
           decltype(*std::declval<T>() =
                        std::declval<iterator_value_type_t<T>>())>;

template <typename, typename = void> struct is_output_iterator {
  static constexpr bool value = false;
};

template <typename T>
struct is_output_iterator<T, output_iterator_requirements<T>> {
  static constexpr bool value = true;
};

}
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_lists.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/type_list.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/type_list.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {

template <typename T> using head_t = typename T::head;

template <typename T> using tail_t = typename T::tail;


template <typename... T> struct type_list;

using empty_type_list = type_list<>;

template <typename T>
struct is_empty_type_list
    : conditional_t<std::is_same<T, empty_type_list>::value, std::true_type,
                    std::false_type> {};

template <> struct type_list<> {};

template <typename H, typename... T> struct type_list<H, T...> {
  using head = H;
  using tail = type_list<T...>;
};

template <typename H, typename... T, typename... T2>
struct type_list<type_list<H, T...>, T2...> {
private:
  using remainder = tail_t<type_list<H>>;
  static constexpr bool has_remainder = !is_empty_type_list<remainder>::value;
  using without_remainder = type_list<T..., T2...>;
  using with_remainder = type_list<remainder, T..., T2...>;

public:
  using head = head_t<type_list<H>>;
  using tail = conditional_t<has_remainder, with_remainder, without_remainder>;
};


template <typename T, typename L>
struct is_contained
    : conditional_t<std::is_same<remove_cv_t<T>, head_t<L>>::value,
                    std::true_type, is_contained<T, tail_t<L>>> {};

template <typename T>
struct is_contained<T, empty_type_list> : std::false_type {};


template <typename T, T... V> struct value_list;

template <typename T, T H, T... V> struct value_list<T, H, V...> {
  static constexpr T head = H;
  using tail = value_list<T, V...>;
};

template <typename T> struct value_list<T> {};


template <typename T, T V, typename TL>
struct is_contained_value
    : conditional_t<V == TL::head, std::true_type,
                    is_contained_value<T, V, tail_t<TL>>> {};

template <typename T, T V>
struct is_contained_value<T, V, value_list<T>> : std::false_type {};


template <access::address_space... V>
using address_space_list = value_list<access::address_space, V...>;

template <access::address_space AS, typename VL>
using is_one_of_spaces = is_contained_value<access::address_space, AS, VL>;


template <typename T1, typename T2>
struct is_type_size_equal : bool_constant<(sizeof(T1) == sizeof(T2))> {};

template <typename T1, typename T2>
struct is_type_size_greater : bool_constant<(sizeof(T1) > sizeof(T2))> {};

template <typename T1, typename T2>
struct is_type_size_double_of
    : bool_constant<(sizeof(T1) == (sizeof(T2) * 2))> {};

template <typename T1, typename T2>
struct is_type_size_less : bool_constant<(sizeof(T1) < sizeof(T2))> {};

template <typename T1, typename T2>
struct is_type_size_half_of : bool_constant<(sizeof(T1) == (sizeof(T2) / 2))> {
};


template <typename TL, template <typename, typename> class C, typename T>
struct find_type {
  using head = head_t<TL>;
  using tail = typename find_type<tail_t<TL>, C, T>::type;
  using type = conditional_t<C<head, T>::value, head, tail>;
};

template <template <typename, typename> class C, typename T>
struct find_type<empty_type_list, C, T> {
  using type = void;
};

template <typename TL, template <typename, typename> class C, typename T>
using find_type_t = typename find_type<TL, C, T>::type;

template <typename TL, typename T>
using find_same_size_type_t = find_type_t<TL, is_type_size_equal, T>;

template <typename TL, typename T>
using find_smaller_type_t = find_type_t<TL, is_type_size_less, T>;

template <typename TL, typename T>
using find_larger_type_t = find_type_t<TL, is_type_size_greater, T>;

template <typename TL, typename T>
using find_twice_as_small_type_t = find_type_t<TL, is_type_size_half_of, T>;

template <typename TL, typename T>
using find_twice_as_large_type_t = find_type_t<TL, is_type_size_double_of, T>;

}
}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_lists.hpp" 2 3





inline namespace cl {
namespace sycl {
template <typename T, int N> class vec;
namespace detail {
namespace half_impl {
class half;
}
}
using half = detail::half_impl::half;
}
}

inline namespace cl {
namespace sycl {
namespace detail {
namespace gtl {

using scalar_half_list = type_list<half>;

using vector_half_list = type_list<vec<half, 1>, vec<half, 2>, vec<half, 3>,
                                   vec<half, 4>, vec<half, 8>, vec<half, 16>>;

using half_list = type_list<scalar_half_list, vector_half_list>;

using scalar_float_list = type_list<float>;

using vector_float_list =
    type_list<vec<float, 1>, vec<float, 2>, vec<float, 3>, vec<float, 4>,
              vec<float, 8>, vec<float, 16>>;

using float_list = type_list<scalar_float_list, vector_float_list>;

using scalar_double_list = type_list<double>;

using vector_double_list =
    type_list<vec<double, 1>, vec<double, 2>, vec<double, 3>, vec<double, 4>,
              vec<double, 8>, vec<double, 16>>;

using double_list = type_list<scalar_double_list, vector_double_list>;

using scalar_floating_list =
    type_list<scalar_float_list, scalar_double_list, scalar_half_list>;

using vector_floating_list =
    type_list<vector_float_list, vector_double_list, vector_half_list>;

using floating_list = type_list<scalar_floating_list, vector_floating_list>;


using scalar_geo_half_list = type_list<half>;

using scalar_geo_float_list = type_list<float>;

using scalar_geo_double_list = type_list<double>;

using vector_geo_half_list =
    type_list<vec<half, 1>, vec<half, 2>, vec<half, 3>, vec<half, 4>>;

using vector_geo_float_list =
    type_list<vec<float, 1>, vec<float, 2>, vec<float, 3>, vec<float, 4>>;

using vector_geo_double_list =
    type_list<vec<double, 1>, vec<double, 2>, vec<double, 3>, vec<double, 4>>;

using geo_half_list = type_list<scalar_geo_half_list, vector_geo_half_list>;

using geo_float_list = type_list<scalar_geo_float_list, vector_geo_float_list>;

using geo_double_list =
    type_list<scalar_geo_double_list, vector_geo_double_list>;

using scalar_geo_list = type_list<scalar_geo_half_list, scalar_geo_float_list,
                                  scalar_geo_double_list>;

using vector_geo_list = type_list<vector_geo_half_list, vector_geo_float_list,
                                  vector_geo_double_list>;

using geo_list = type_list<scalar_geo_list, vector_geo_list>;


using cross_half_list = type_list<vec<half, 3>, vec<half, 4>>;

using cross_float_list = type_list<vec<float, 3>, vec<float, 4>>;

using cross_double_list = type_list<vec<double, 3>, vec<double, 4>>;

using cross_floating_list =
    type_list<cross_float_list, cross_double_list, cross_half_list>;

using scalar_default_char_list = type_list<char>;

using vector_default_char_list =
    type_list<vec<char, 1>, vec<char, 2>, vec<char, 3>, vec<char, 4>,
              vec<char, 8>, vec<char, 16>>;

using default_char_list =
    type_list<scalar_default_char_list, vector_default_char_list>;

using scalar_signed_char_list = type_list<signed char>;

using vector_signed_char_list =
    type_list<vec<signed char, 1>, vec<signed char, 2>, vec<signed char, 3>,
              vec<signed char, 4>, vec<signed char, 8>, vec<signed char, 16>>;

using signed_char_list =
    type_list<scalar_signed_char_list, vector_signed_char_list>;

using scalar_unsigned_char_list = type_list<unsigned char>;

using vector_unsigned_char_list =
    type_list<vec<unsigned char, 1>, vec<unsigned char, 2>,
              vec<unsigned char, 3>, vec<unsigned char, 4>,
              vec<unsigned char, 8>, vec<unsigned char, 16>>;

using unsigned_char_list =
    type_list<scalar_unsigned_char_list, vector_unsigned_char_list>;

using scalar_char_list =
    type_list<scalar_default_char_list, scalar_signed_char_list,
              scalar_unsigned_char_list>;

using vector_char_list =
    type_list<vector_default_char_list, vector_signed_char_list,
              vector_unsigned_char_list>;

using char_list = type_list<scalar_char_list, vector_char_list>;


using scalar_signed_short_list = type_list<signed short>;

using vector_signed_short_list =
    type_list<vec<signed short, 1>, vec<signed short, 2>, vec<signed short, 3>,
              vec<signed short, 4>, vec<signed short, 8>,
              vec<signed short, 16>>;

using signed_short_list =
    type_list<scalar_signed_short_list, vector_signed_short_list>;

using scalar_unsigned_short_list = type_list<unsigned short>;

using vector_unsigned_short_list =
    type_list<vec<unsigned short, 1>, vec<unsigned short, 2>,
              vec<unsigned short, 3>, vec<unsigned short, 4>,
              vec<unsigned short, 8>, vec<unsigned short, 16>>;

using unsigned_short_list =
    type_list<scalar_unsigned_short_list, vector_unsigned_short_list>;

using scalar_short_list =
    type_list<scalar_signed_short_list, scalar_unsigned_short_list>;

using vector_short_list =
    type_list<vector_signed_short_list, vector_unsigned_short_list>;

using short_list = type_list<scalar_short_list, vector_short_list>;


using scalar_signed_int_list = type_list<signed int>;

using vector_signed_int_list =
    type_list<vec<signed int, 1>, vec<signed int, 2>, vec<signed int, 3>,
              vec<signed int, 4>, vec<signed int, 8>, vec<signed int, 16>>;

using signed_int_list =
    type_list<scalar_signed_int_list, vector_signed_int_list>;

using scalar_unsigned_int_list = type_list<unsigned int>;

using vector_unsigned_int_list =
    type_list<vec<unsigned int, 1>, vec<unsigned int, 2>, vec<unsigned int, 3>,
              vec<unsigned int, 4>, vec<unsigned int, 8>,
              vec<unsigned int, 16>>;

using unsigned_int_list =
    type_list<scalar_unsigned_int_list, vector_unsigned_int_list>;

using scalar_int_list =
    type_list<scalar_signed_int_list, scalar_unsigned_int_list>;

using vector_int_list =
    type_list<vector_signed_int_list, vector_unsigned_int_list>;

using int_list = type_list<scalar_int_list, vector_int_list>;


using scalar_signed_long_list = type_list<signed long>;

using vector_signed_long_list =
    type_list<vec<signed long, 1>, vec<signed long, 2>, vec<signed long, 3>,
              vec<signed long, 4>, vec<signed long, 8>, vec<signed long, 16>>;

using signed_long_list =
    type_list<scalar_signed_long_list, vector_signed_long_list>;

using scalar_unsigned_long_list = type_list<unsigned long>;

using vector_unsigned_long_list =
    type_list<vec<unsigned long, 1>, vec<unsigned long, 2>,
              vec<unsigned long, 3>, vec<unsigned long, 4>,
              vec<unsigned long, 8>, vec<unsigned long, 16>>;

using unsigned_long_list =
    type_list<scalar_unsigned_long_list, vector_unsigned_long_list>;

using scalar_long_list =
    type_list<scalar_signed_long_list, scalar_unsigned_long_list>;

using vector_long_list =
    type_list<vector_signed_long_list, vector_unsigned_long_list>;

using long_list = type_list<scalar_long_list, vector_long_list>;


using scalar_signed_longlong_list = type_list<signed long long>;

using vector_signed_longlong_list =
    type_list<vec<signed long long, 1>, vec<signed long long, 2>,
              vec<signed long long, 3>, vec<signed long long, 4>,
              vec<signed long long, 8>, vec<signed long long, 16>>;

using signed_longlong_list =
    type_list<scalar_signed_longlong_list, vector_signed_longlong_list>;

using scalar_unsigned_longlong_list = type_list<unsigned long long>;

using vector_unsigned_longlong_list =
    type_list<vec<unsigned long long, 1>, vec<unsigned long long, 2>,
              vec<unsigned long long, 3>, vec<unsigned long long, 4>,
              vec<unsigned long long, 8>, vec<unsigned long long, 16>>;

using unsigned_longlong_list =
    type_list<scalar_unsigned_longlong_list, vector_unsigned_longlong_list>;

using scalar_longlong_list =
    type_list<scalar_signed_longlong_list, scalar_unsigned_longlong_list>;

using vector_longlong_list =
    type_list<vector_signed_longlong_list, vector_unsigned_longlong_list>;

using longlong_list = type_list<scalar_longlong_list, vector_longlong_list>;


using scalar_signed_long_integer_list =
    type_list<scalar_signed_long_list, scalar_signed_longlong_list>;

using vector_signed_long_integer_list =
    type_list<vector_signed_long_list, vector_signed_longlong_list>;

using signed_long_integer_list =
    type_list<scalar_signed_long_integer_list, vector_signed_long_integer_list>;

using scalar_unsigned_long_integer_list =
    type_list<scalar_unsigned_long_list, scalar_unsigned_longlong_list>;

using vector_unsigned_long_integer_list =
    type_list<vector_unsigned_long_list, vector_unsigned_longlong_list>;

using unsigned_long_integer_list = type_list<scalar_unsigned_long_integer_list,
                                             vector_unsigned_long_integer_list>;

using scalar_long_integer_list = type_list<scalar_signed_long_integer_list,
                                           scalar_unsigned_long_integer_list>;

using vector_long_integer_list = type_list<vector_signed_long_integer_list,
                                           vector_unsigned_long_integer_list>;

using long_integer_list =
    type_list<scalar_long_integer_list, vector_long_integer_list>;


using scalar_signed_integer_list = type_list<
    conditional_t<std::is_signed<char>::value,
                  type_list<scalar_default_char_list, scalar_signed_char_list>,
                  scalar_signed_char_list>,
    scalar_signed_short_list, scalar_signed_int_list, scalar_signed_long_list,
    scalar_signed_longlong_list>;

using vector_signed_integer_list = type_list<
    conditional_t<std::is_signed<char>::value,
                  type_list<vector_default_char_list, vector_signed_char_list>,
                  vector_signed_char_list>,
    vector_signed_short_list, vector_signed_int_list, vector_signed_long_list,
    vector_signed_longlong_list>;

using signed_integer_list =
    type_list<scalar_signed_integer_list, vector_signed_integer_list>;

using scalar_unsigned_integer_list =
    type_list<conditional_t<std::is_unsigned<char>::value,
                            type_list<scalar_default_char_list,
                                      scalar_unsigned_char_list>,
                            scalar_unsigned_char_list>,
              scalar_unsigned_short_list, scalar_unsigned_int_list,
              scalar_unsigned_long_list, scalar_unsigned_longlong_list>;

using vector_unsigned_integer_list =
    type_list<conditional_t<std::is_unsigned<char>::value,
                            type_list<vector_default_char_list,
                                      vector_unsigned_char_list>,
                            vector_unsigned_char_list>,
              vector_unsigned_short_list, vector_unsigned_int_list,
              vector_unsigned_long_list, vector_unsigned_longlong_list>;

using unsigned_integer_list =
    type_list<scalar_unsigned_integer_list, vector_unsigned_integer_list>;

using scalar_integer_list =
    type_list<scalar_signed_integer_list, scalar_unsigned_integer_list>;

using vector_integer_list =
    type_list<vector_signed_integer_list, vector_unsigned_integer_list>;

using integer_list = type_list<scalar_integer_list, vector_integer_list>;


using scalar_signed_basic_list =
    type_list<scalar_floating_list, scalar_signed_integer_list>;

using vector_signed_basic_list =
    type_list<vector_floating_list, vector_signed_integer_list>;

using signed_basic_list =
    type_list<scalar_signed_basic_list, vector_signed_basic_list>;

using scalar_unsigned_basic_list = type_list<scalar_unsigned_integer_list>;

using vector_unsigned_basic_list = type_list<vector_unsigned_integer_list>;

using unsigned_basic_list =
    type_list<scalar_unsigned_basic_list, vector_unsigned_basic_list>;

using scalar_basic_list =
    type_list<scalar_signed_basic_list, scalar_unsigned_basic_list>;

using vector_basic_list =
    type_list<vector_signed_basic_list, vector_unsigned_basic_list>;

using basic_list = type_list<scalar_basic_list, vector_basic_list>;


using nan_list = type_list<gtl::unsigned_short_list, gtl::unsigned_int_list,
                           gtl::unsigned_long_integer_list>;
}
namespace gvl {

using all_address_space_list = address_space_list<
    access::address_space::local_space, access::address_space::global_space,
    access::address_space::private_space, access::address_space::constant_space,
    access::address_space::global_device_space,
    access::address_space::global_host_space>;

using nonconst_address_space_list =
    address_space_list<access::address_space::local_space,
                       access::address_space::global_space,
                       access::address_space::private_space,
                       access::address_space::global_device_space,
                       access::address_space::global_host_space>;

using nonlocal_address_space_list =
    address_space_list<access::address_space::global_space,
                       access::address_space::private_space,
                       access::address_space::constant_space,
                       access::address_space::global_device_space,
                       access::address_space::global_host_space>;
}
}
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/type_traits.hpp" 2 3





inline namespace cl {
namespace sycl {
template <int Dimensions> class group;
namespace ONEAPI {
struct sub_group;
}
namespace detail {
namespace half_impl {
class half;
}
}
using half = detail::half_impl::half;


template <typename ElementType, access::address_space Space> class multi_ptr;

namespace detail {
template <typename T, typename R> struct copy_cv_qualifiers;

template <typename T, typename R>
using copy_cv_qualifiers_t = typename copy_cv_qualifiers<T, R>::type;

template <int V> using int_constant = std::integral_constant<int, V>;



template <typename T> struct vector_size_impl : int_constant<1> {};
template <typename T, int N>
struct vector_size_impl<vec<T, N>> : int_constant<N> {};
template <typename T>
struct vector_size : vector_size_impl<remove_cv_t<remove_reference_t<T>>> {};


template <typename T, int N>
struct vector_alignment_impl
    : conditional_t<N == 3, int_constant<sizeof(T) * 4>,
                    int_constant<sizeof(T) * N>> {};

template <typename T, int N>
struct vector_alignment
    : vector_alignment_impl<remove_cv_t<remove_reference_t<T>>, N> {};


template <typename T> struct vector_element_impl;
template <typename T>
using vector_element_impl_t = typename vector_element_impl<T>::type;
template <typename T> struct vector_element_impl { using type = T; };
template <typename T, int N> struct vector_element_impl<vec<T, N>> {
  using type = T;
};
template <typename T> struct vector_element {
  using type = copy_cv_qualifiers_t<T, vector_element_impl_t<remove_cv_t<T>>>;
};
template <class T> using vector_element_t = typename vector_element<T>::type;


template <typename T, typename B> struct change_base_type { using type = B; };

template <typename T, int N, typename B> struct change_base_type<vec<T, N>, B> {
  using type = vec<B, N>;
};

template <typename T, typename B>
using change_base_type_t = typename change_base_type<T, B>::type;


template <typename T, typename R> struct copy_cv_qualifiers_impl {
  using type = R;
};

template <typename T, typename R> struct copy_cv_qualifiers_impl<const T, R> {
  using type = const R;
};

template <typename T, typename R>
struct copy_cv_qualifiers_impl<volatile T, R> {
  using type = volatile R;
};

template <typename T, typename R>
struct copy_cv_qualifiers_impl<const volatile T, R> {
  using type = const volatile R;
};

template <typename T, typename R> struct copy_cv_qualifiers {
  using type = typename copy_cv_qualifiers_impl<T, remove_cv_t<R>>::type;
};


template <typename T, typename Enable = void> struct make_signed_impl;

template <typename T>
using make_signed_impl_t = typename make_signed_impl<T, T>::type;

template <typename T>
struct make_signed_impl<
    T, enable_if_t<is_contained<T, gtl::scalar_integer_list>::value, T>> {
  using type = typename std::make_signed<T>::type;
};

template <typename T>
struct make_signed_impl<
    T, enable_if_t<is_contained<T, gtl::vector_integer_list>::value, T>> {
  using base_type = make_signed_impl_t<vector_element_t<T>>;
  using type = change_base_type_t<T, base_type>;
};



template <typename T>
struct make_signed_impl<
    T, enable_if_t<!is_contained<T, gtl::integer_list>::value, T>> {
  using type = T;
};

template <typename T> struct make_signed {
  using new_type_wo_cv_qualifiers = make_signed_impl_t<remove_cv_t<T>>;
  using type = copy_cv_qualifiers_t<T, new_type_wo_cv_qualifiers>;
};

template <typename T> using make_signed_t = typename make_signed<T>::type;


template <typename T, typename Enable = void> struct make_unsigned_impl;

template <typename T>
using make_unsigned_impl_t = typename make_unsigned_impl<T, T>::type;

template <typename T>
struct make_unsigned_impl<
    T, enable_if_t<is_contained<T, gtl::scalar_integer_list>::value, T>> {
  using type = typename std::make_unsigned<T>::type;
};

template <typename T>
struct make_unsigned_impl<
    T, enable_if_t<is_contained<T, gtl::vector_integer_list>::value, T>> {
  using base_type = make_unsigned_impl_t<vector_element_t<T>>;
  using type = change_base_type_t<T, base_type>;
};



template <typename T>
struct make_unsigned_impl<
    T, enable_if_t<!is_contained<T, gtl::integer_list>::value, T>> {
  using type = T;
};

template <typename T> struct make_unsigned {
  using new_type_wo_cv_qualifiers = make_unsigned_impl_t<remove_cv_t<T>>;
  using type = copy_cv_qualifiers_t<T, new_type_wo_cv_qualifiers>;
};

template <typename T> using make_unsigned_t = typename make_unsigned<T>::type;


template <typename T, int N, template <typename> class S>
using is_gen_based_on_type_sizeof =
    bool_constant<S<T>::value && (sizeof(vector_element_t<T>) == N)>;

template <typename> struct is_vec : std::false_type {};
template <typename T, std::size_t N>
struct is_vec<cl::sycl::vec<T, N>> : std::true_type {};


template <typename T>
struct is_integral : std::is_integral<vector_element_t<T>> {};


template <typename T>
struct is_floating_point_impl : std::is_floating_point<T> {};

template <> struct is_floating_point_impl<half> : std::true_type {};

template <typename T>
struct is_floating_point
    : is_floating_point_impl<remove_cv_t<vector_element_t<T>>> {};


template <typename T>
struct is_arithmetic
    : bool_constant<is_integral<T>::value || is_floating_point<T>::value> {};

template <typename T>
struct is_scalar_arithmetic
    : bool_constant<!is_vec<T>::value && is_arithmetic<T>::value> {};

template <typename T>
struct is_vector_arithmetic
    : bool_constant<is_vec<T>::value && is_arithmetic<T>::value> {};


template <typename T>
struct is_scalar_bool
    : bool_constant<std::is_same<remove_cv_t<T>, bool>::value> {};

template <typename T>
struct is_vector_bool
    : bool_constant<is_vec<T>::value &&
                    is_scalar_bool<vector_element_t<T>>::value> {};

template <typename T>
struct is_bool : bool_constant<is_scalar_bool<vector_element_t<T>>::value> {};


template <typename T> struct is_pointer_impl : std::false_type {};

template <typename T> struct is_pointer_impl<T *> : std::true_type {};

template <typename T, access::address_space Space>
struct is_pointer_impl<multi_ptr<T, Space>> : std::true_type {};

template <typename T> struct is_pointer : is_pointer_impl<remove_cv_t<T>> {};


template <typename T> struct remove_pointer_impl { using type = T; };

template <typename T> struct remove_pointer_impl<T *> { using type = T; };

template <typename T, access::address_space Space>
struct remove_pointer_impl<multi_ptr<T, Space>> {
  using type = T;
};

template <typename T>
struct remove_pointer : remove_pointer_impl<remove_cv_t<T>> {};

template <typename T> using remove_pointer_t = typename remove_pointer<T>::type;


template <typename T, typename SpaceList>
struct is_address_space_compliant_impl : std::false_type {};

template <typename T, typename SpaceList>
struct is_address_space_compliant_impl<T *, SpaceList> : std::true_type {};

template <typename T, typename SpaceList, access::address_space Space>
struct is_address_space_compliant_impl<multi_ptr<T, Space>, SpaceList>
    : bool_constant<is_one_of_spaces<Space, SpaceList>::value> {};

template <typename T, typename SpaceList>
struct is_address_space_compliant
    : is_address_space_compliant_impl<remove_cv_t<T>, SpaceList> {};


template <typename T, typename TL> struct make_type_impl {
  using type = find_same_size_type_t<TL, T>;
};

template <typename T, int N, typename TL> struct make_type_impl<vec<T, N>, TL> {
  using scalar_type = typename make_type_impl<T, TL>::type;
  using type = vec<scalar_type, N>;
};

template <typename T, typename TL>
using make_type_t = typename make_type_impl<T, TL>::type;


template <typename T, typename Enable = void> struct make_larger_impl;
template <typename T>
struct make_larger_impl<
    T, enable_if_t<is_contained<T, gtl::scalar_floating_list>::value, T>> {
  using type = find_twice_as_large_type_t<gtl::scalar_floating_list, T>;
};

template <typename T>
struct make_larger_impl<
    T,
    enable_if_t<is_contained<T, gtl::scalar_signed_integer_list>::value, T>> {
  using type = find_twice_as_large_type_t<gtl::scalar_signed_integer_list, T>;
};

template <typename T>
struct make_larger_impl<
    T,
    enable_if_t<is_contained<T, gtl::scalar_unsigned_integer_list>::value, T>> {
  using type = find_twice_as_large_type_t<gtl::scalar_unsigned_integer_list, T>;
};

template <typename T, int N> struct make_larger_impl<vec<T, N>, vec<T, N>> {
  using base_type = vector_element_t<vec<T, N>>;
  using upper_type = typename make_larger_impl<base_type, base_type>::type;
  using new_type = vec<upper_type, N>;
  static constexpr bool found = !std::is_same<upper_type, void>::value;
  using type = conditional_t<found, new_type, void>;
};

template <typename T> struct make_larger {
  using type = typename make_larger_impl<T, T>::type;
};

template <typename T> using make_larger_t = typename make_larger<T>::type;







template <access::address_space AS, class DataT>
using const_if_const_AS = DataT;


template <typename T> struct is_group : std::false_type {};

template <int Dimensions>
struct is_group<group<Dimensions>> : std::true_type {};

template <typename T> struct is_sub_group : std::false_type {};

template <> struct is_sub_group<ONEAPI::sub_group> : std::true_type {};

template <typename T>
struct is_generic_group
    : std::integral_constant<bool,
                             is_group<T>::value || is_sub_group<T>::value> {};

}
}
}
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/numeric" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/numeric" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 1 3
# 65 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 80 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
    {





                                                     ;

      for (; __first != __last; ++__first)
 {
   *__first = __value;
   ++__value;
 }
    }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
# 118 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
# 144 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
# 172 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
# 203 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
# 235 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
# 275 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
# 315 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = std::move(__tmp);
 }
      return ++__result;
    }
# 357 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = std::move(__tmp);
 }
      return ++__result;
    }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/numeric" 2 3
# 80 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/numeric" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
namespace __detail
{



  template<typename _Tp>
    constexpr
    enable_if_t<__and_<is_integral<_Tp>, is_signed<_Tp>>::value, _Tp>
    __abs_integral(_Tp __val)
    { return __val < 0 ? -__val : __val; }

  template<typename _Tp>
    constexpr
    enable_if_t<__and_<is_integral<_Tp>, is_unsigned<_Tp>>::value, _Tp>
    __abs_integral(_Tp __val)
    { return __val; }

  void __abs_integral(bool) = delete;

  template<typename _Mn, typename _Nn>
    constexpr common_type_t<_Mn, _Nn>
    __gcd(_Mn __m, _Nn __n)
    {
      return __m == 0 ? __detail::__abs_integral(__n)
 : __n == 0 ? __detail::__abs_integral(__m)
 : __detail::__gcd(__n, __m % __n);
    }


  template<typename _Mn, typename _Nn>
    constexpr common_type_t<_Mn, _Nn>
    __lcm(_Mn __m, _Nn __n)
    {
      return (__m != 0 && __n != 0)
 ? (__detail::__abs_integral(__m) / __detail::__gcd(__m, __n))
   * __detail::__abs_integral(__n)
 : 0;
    }


}
# 134 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/numeric" 3
  template<typename _Mn, typename _Nn>
    constexpr common_type_t<_Mn, _Nn>
    gcd(_Mn __m, _Nn __n)
    {
      static_assert(is_integral<_Mn>::value, "gcd arguments are integers");
      static_assert(is_integral<_Nn>::value, "gcd arguments are integers");
      static_assert(!is_same<_Mn, bool>::value, "gcd arguments are not bools");
      static_assert(!is_same<_Nn, bool>::value, "gcd arguments are not bools");
      return __detail::__gcd(__m, __n);
    }


  template<typename _Mn, typename _Nn>
    constexpr common_type_t<_Mn, _Nn>
    lcm(_Mn __m, _Nn __n)
    {
      static_assert(is_integral<_Mn>::value, "lcm arguments are integers");
      static_assert(is_integral<_Nn>::value, "lcm arguments are integers");
      static_assert(!is_same<_Mn, bool>::value, "lcm arguments are not bools");
      static_assert(!is_same<_Nn, bool>::value, "lcm arguments are not bools");
      return __detail::__lcm(__m, __n);
    }




}
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 2 3




inline namespace cl {
namespace sycl {
class context;
class event;
template <int Dims, bool WithOffset> class item;
template <int Dims> class group;
template <int Dims> class range;
template <int Dims> class id;
template <int Dims> class nd_item;
template <int Dims> class h_item;
enum class memory_order;

namespace detail {
inline void memcpy(void *Dst, const void *Src, size_t Size) {
  char *Destination = reinterpret_cast<char *>(Dst);
  const char *Source = reinterpret_cast<const char *>(Src);
  for (size_t I = 0; I < Size; ++I) {
    Destination[I] = Source[I];
  }
}

template <typename To, typename From>
constexpr To bit_cast(const From &from) noexcept {
  static_assert(sizeof(To) == sizeof(From),
                "Sizes of To and From must be equal");
  static_assert(std::is_trivially_copyable<From>::value,
                "From must be trivially copyable");
  static_assert(std::is_trivially_copyable<To>::value,
                "To must be trivially copyable");





  return __builtin_bit_cast(To, from);
# 69 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 3
}

class context_impl;


__attribute__((visibility("default"))) std::vector<RT::PiEvent>
getOrWaitEvents(std::vector<cl::sycl::event> DepEvents,
                std::shared_ptr<cl::sycl::detail::context_impl> Context);

__attribute__((visibility("default"))) void waitEvents(std::vector<cl::sycl::event> DepEvents);

class Builder {
public:
  Builder() = delete;

  template <int Dims>
  static group<Dims>
  createGroup(const range<Dims> &Global, const range<Dims> &Local,
              const range<Dims> &Group, const id<Dims> &Index) {
    return group<Dims>(Global, Local, Group, Index);
  }

  template <int Dims>
  static group<Dims> createGroup(const range<Dims> &Global,
                                 const range<Dims> &Local,
                                 const id<Dims> &Index) {
    return group<Dims>(Global, Local, Global / Local, Index);
  }

  template <int Dims, bool WithOffset>
  static detail::enable_if_t<WithOffset, item<Dims, WithOffset>>
  createItem(const range<Dims> &Extent, const id<Dims> &Index,
             const id<Dims> &Offset) {
    return item<Dims, WithOffset>(Extent, Index, Offset);
  }

  template <int Dims, bool WithOffset>
  static detail::enable_if_t<!WithOffset, item<Dims, WithOffset>>
  createItem(const range<Dims> &Extent, const id<Dims> &Index) {
    return item<Dims, WithOffset>(Extent, Index);
  }

  template <int Dims>
  static nd_item<Dims> createNDItem(const item<Dims, true> &Global,
                                    const item<Dims, false> &Local,
                                    const group<Dims> &Group) {
    return nd_item<Dims>(Global, Local, Group);
  }

  template <int Dims>
  static h_item<Dims> createHItem(const item<Dims, false> &Global,
                                  const item<Dims, false> &Local) {
    return h_item<Dims>(Global, Local);
  }

  template <int Dims>
  static h_item<Dims> createHItem(const item<Dims, false> &Global,
                                  const item<Dims, false> &Local,
                                  const range<Dims> &Flex) {
    return h_item<Dims>(Global, Local, Flex);
  }

  template <int Dims, bool WithOffset>
  static void updateItemIndex(cl::sycl::item<Dims, WithOffset> &Item,
                              const id<Dims> &NextIndex) {
    Item.MImpl.MIndex = NextIndex;
  }
# 205 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 3
};

inline constexpr __spv::MemorySemanticsMask::Flag
getSPIRVMemorySemanticsMask(memory_order) {
  return __spv::MemorySemanticsMask::None;
}

inline constexpr uint32_t
getSPIRVMemorySemanticsMask(const access::fence_space AccessSpace,
                            const __spv::MemorySemanticsMask LocalScopeMask =
                                __spv::MemorySemanticsMask::WorkgroupMemory) {
# 241 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/helpers.hpp" 3
  return (AccessSpace == access::fence_space::global_space)
             ? static_cast<uint32_t>(
                   __spv::MemorySemanticsMask::SequentiallyConsistent |
                   __spv::MemorySemanticsMask::CrossWorkgroupMemory)
             : (AccessSpace == access::fence_space::local_space)
                   ? static_cast<uint32_t>(
                         __spv::MemorySemanticsMask::SequentiallyConsistent |
                         LocalScopeMask)
                   :

                   static_cast<uint32_t>(
                       __spv::MemorySemanticsMask::SequentiallyConsistent |
                       __spv::MemorySemanticsMask::CrossWorkgroupMemory |
                       LocalScopeMask);
}

}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/atomic" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/atomic" 3








namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/atomic" 3
  template<typename _Tp>
    struct atomic;



  template<>
  struct atomic<bool>
  {
  private:
    __atomic_base<bool> _M_base;

  public:
    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;

    constexpr atomic(bool __i) noexcept : _M_base(__i) { }

    bool
    operator=(bool __i) noexcept
    { return _M_base.operator=(__i); }

    bool
    operator=(bool __i) volatile noexcept
    { return _M_base.operator=(__i); }

    operator bool() const noexcept
    { return _M_base.load(); }

    operator bool() const volatile noexcept
    { return _M_base.load(); }

    bool
    is_lock_free() const noexcept { return _M_base.is_lock_free(); }

    bool
    is_lock_free() const volatile noexcept { return _M_base.is_lock_free(); }


    static constexpr bool is_always_lock_free = 2 == 2;


    void
    store(bool __i, memory_order __m = memory_order_seq_cst) noexcept
    { _M_base.store(__i, __m); }

    void
    store(bool __i, memory_order __m = memory_order_seq_cst) volatile noexcept
    { _M_base.store(__i, __m); }

    bool
    load(memory_order __m = memory_order_seq_cst) const noexcept
    { return _M_base.load(__m); }

    bool
    load(memory_order __m = memory_order_seq_cst) const volatile noexcept
    { return _M_base.load(__m); }

    bool
    exchange(bool __i, memory_order __m = memory_order_seq_cst) noexcept
    { return _M_base.exchange(__i, __m); }

    bool
    exchange(bool __i,
      memory_order __m = memory_order_seq_cst) volatile noexcept
    { return _M_base.exchange(__i, __m); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
     memory_order __m2) noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
     memory_order __m2) volatile noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2,
     memory_order __m = memory_order_seq_cst) noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2,
       memory_order __m = memory_order_seq_cst) volatile noexcept
    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
       memory_order __m2) noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
       memory_order __m2) volatile noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2,
       memory_order __m = memory_order_seq_cst) noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2,
      memory_order __m = memory_order_seq_cst) volatile noexcept
    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
  };







  template<typename _Tp>
    struct atomic
    {
    private:

      static constexpr int _S_min_alignment
 = (sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16
 ? 0 : sizeof(_Tp);

      static constexpr int _S_alignment
        = _S_min_alignment > alignof(_Tp) ? _S_min_alignment : alignof(_Tp);

      alignas(_S_alignment) _Tp _M_i;

      static_assert(__is_trivially_copyable(_Tp),
      "std::atomic requires a trivially copyable type");

      static_assert(sizeof(_Tp) > 0,
      "Incomplete or zero-sized types are not supported");

    public:
      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }

      operator _Tp() const noexcept
      { return load(); }

      operator _Tp() const volatile noexcept
      { return load(); }

      _Tp
      operator=(_Tp __i) noexcept
      { store(__i); return __i; }

      _Tp
      operator=(_Tp __i) volatile noexcept
      { store(__i); return __i; }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }


      static constexpr bool is_always_lock_free
 = __atomic_always_lock_free(sizeof(_M_i), 0);


      void
      store(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept
      { __atomic_store(std::__addressof(_M_i), std::__addressof(__i), __m); }

      void
      store(_Tp __i, memory_order __m = memory_order_seq_cst) volatile noexcept
      { __atomic_store(std::__addressof(_M_i), std::__addressof(__i), __m); }

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_load(std::__addressof(_M_i), __ptr, __m);
 return *__ptr;
      }

      _Tp
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_load(std::__addressof(_M_i), __ptr, __m);
 return *__ptr;
      }

      _Tp
      exchange(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),
     __ptr, __m);
 return *__ptr;
      }

      _Tp
      exchange(_Tp __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
 __atomic_exchange(std::__addressof(_M_i), std::__addressof(__i),
     __ptr, __m);
 return *__ptr;
      }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
       memory_order __f) noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      true, __s, __f);
      }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
       memory_order __f) volatile noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      true, __s, __f);
      }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i,
       memory_order __m = memory_order_seq_cst) noexcept
      { return compare_exchange_weak(__e, __i, __m,
                                     __cmpexch_failure_order(__m)); }

      bool
      compare_exchange_weak(_Tp& __e, _Tp __i,
       memory_order __m = memory_order_seq_cst) volatile noexcept
      { return compare_exchange_weak(__e, __i, __m,
                                     __cmpexch_failure_order(__m)); }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
         memory_order __f) noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      false, __s, __f);
      }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
         memory_order __f) volatile noexcept
      {
 return __atomic_compare_exchange(std::__addressof(_M_i),
      std::__addressof(__e),
      std::__addressof(__i),
      false, __s, __f);
      }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i,
          memory_order __m = memory_order_seq_cst) noexcept
      { return compare_exchange_strong(__e, __i, __m,
                                       __cmpexch_failure_order(__m)); }

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i,
       memory_order __m = memory_order_seq_cst) volatile noexcept
      { return compare_exchange_strong(__e, __i, __m,
                                       __cmpexch_failure_order(__m)); }
    };



  template<typename _Tp>
    struct atomic<_Tp*>
    {
      typedef _Tp* __pointer_type;
      typedef __atomic_base<_Tp*> __base_type;
      __base_type _M_b;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__pointer_type __p) noexcept : _M_b(__p) { }

      operator __pointer_type() const noexcept
      { return __pointer_type(_M_b); }

      operator __pointer_type() const volatile noexcept
      { return __pointer_type(_M_b); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      { return _M_b.operator=(__p); }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      { return _M_b.operator=(__p); }

      __pointer_type
      operator++(int) noexcept
      { return _M_b++; }

      __pointer_type
      operator++(int) volatile noexcept
      { return _M_b++; }

      __pointer_type
      operator--(int) noexcept
      { return _M_b--; }

      __pointer_type
      operator--(int) volatile noexcept
      { return _M_b--; }

      __pointer_type
      operator++() noexcept
      { return ++_M_b; }

      __pointer_type
      operator++() volatile noexcept
      { return ++_M_b; }

      __pointer_type
      operator--() noexcept
      { return --_M_b; }

      __pointer_type
      operator--() volatile noexcept
      { return --_M_b; }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return _M_b.operator+=(__d); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return _M_b.operator+=(__d); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return _M_b.operator-=(__d); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return _M_b.operator-=(__d); }

      bool
      is_lock_free() const noexcept
      { return _M_b.is_lock_free(); }

      bool
      is_lock_free() const volatile noexcept
      { return _M_b.is_lock_free(); }


    static constexpr bool is_always_lock_free = 2 == 2;


      void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.store(__p, __m); }

      void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.store(__p, __m); }

      __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return _M_b.load(__m); }

      __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      { return _M_b.load(__m); }

      __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.exchange(__p, __m); }

      __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.exchange(__p, __m); }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
       memory_order __m1, memory_order __m2) noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      bool
      compare_exchange_weak(__pointer_type& __p1, __pointer_type __p2,
      memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1, memory_order __m2) noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      { return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2); }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return _M_b.compare_exchange_strong(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
      memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return _M_b.compare_exchange_strong(__p1, __p2, __m,
         __cmpexch_failure_order(__m));
      }

      __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.fetch_add(__d, __m); }

      __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.fetch_add(__d, __m); }

      __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return _M_b.fetch_sub(__d, __m); }

      __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return _M_b.fetch_sub(__d, __m); }
    };



  template<>
    struct atomic<char> : __atomic_base<char>
    {
      typedef char __integral_type;
      typedef __atomic_base<char> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<signed char> : __atomic_base<signed char>
    {
      typedef signed char __integral_type;
      typedef __atomic_base<signed char> __base_type;

      atomic() noexcept= default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<unsigned char> : __atomic_base<unsigned char>
    {
      typedef unsigned char __integral_type;
      typedef __atomic_base<unsigned char> __base_type;

      atomic() noexcept= default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<short> : __atomic_base<short>
    {
      typedef short __integral_type;
      typedef __atomic_base<short> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<unsigned short> : __atomic_base<unsigned short>
    {
      typedef unsigned short __integral_type;
      typedef __atomic_base<unsigned short> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<int> : __atomic_base<int>
    {
      typedef int __integral_type;
      typedef __atomic_base<int> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<unsigned int> : __atomic_base<unsigned int>
    {
      typedef unsigned int __integral_type;
      typedef __atomic_base<unsigned int> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<long> : __atomic_base<long>
    {
      typedef long __integral_type;
      typedef __atomic_base<long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<unsigned long> : __atomic_base<unsigned long>
    {
      typedef unsigned long __integral_type;
      typedef __atomic_base<unsigned long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<long long> : __atomic_base<long long>
    {
      typedef long long __integral_type;
      typedef __atomic_base<long long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<unsigned long long> : __atomic_base<unsigned long long>
    {
      typedef unsigned long long __integral_type;
      typedef __atomic_base<unsigned long long> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<wchar_t> : __atomic_base<wchar_t>
    {
      typedef wchar_t __integral_type;
      typedef __atomic_base<wchar_t> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<char16_t> : __atomic_base<char16_t>
    {
      typedef char16_t __integral_type;
      typedef __atomic_base<char16_t> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };


  template<>
    struct atomic<char32_t> : __atomic_base<char32_t>
    {
      typedef char32_t __integral_type;
      typedef __atomic_base<char32_t> __base_type;

      atomic() noexcept = default;
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(__integral_type __i) noexcept : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;


    static constexpr bool is_always_lock_free = 2 == 2;

    };



  typedef atomic<bool> atomic_bool;


  typedef atomic<char> atomic_char;


  typedef atomic<signed char> atomic_schar;


  typedef atomic<unsigned char> atomic_uchar;


  typedef atomic<short> atomic_short;


  typedef atomic<unsigned short> atomic_ushort;


  typedef atomic<int> atomic_int;


  typedef atomic<unsigned int> atomic_uint;


  typedef atomic<long> atomic_long;


  typedef atomic<unsigned long> atomic_ulong;


  typedef atomic<long long> atomic_llong;


  typedef atomic<unsigned long long> atomic_ullong;


  typedef atomic<wchar_t> atomic_wchar_t;


  typedef atomic<char16_t> atomic_char16_t;


  typedef atomic<char32_t> atomic_char32_t;






  typedef atomic<int8_t> atomic_int8_t;


  typedef atomic<uint8_t> atomic_uint8_t;


  typedef atomic<int16_t> atomic_int16_t;


  typedef atomic<uint16_t> atomic_uint16_t;


  typedef atomic<int32_t> atomic_int32_t;


  typedef atomic<uint32_t> atomic_uint32_t;


  typedef atomic<int64_t> atomic_int64_t;


  typedef atomic<uint64_t> atomic_uint64_t;



  typedef atomic<int_least8_t> atomic_int_least8_t;


  typedef atomic<uint_least8_t> atomic_uint_least8_t;


  typedef atomic<int_least16_t> atomic_int_least16_t;


  typedef atomic<uint_least16_t> atomic_uint_least16_t;


  typedef atomic<int_least32_t> atomic_int_least32_t;


  typedef atomic<uint_least32_t> atomic_uint_least32_t;


  typedef atomic<int_least64_t> atomic_int_least64_t;


  typedef atomic<uint_least64_t> atomic_uint_least64_t;



  typedef atomic<int_fast8_t> atomic_int_fast8_t;


  typedef atomic<uint_fast8_t> atomic_uint_fast8_t;


  typedef atomic<int_fast16_t> atomic_int_fast16_t;


  typedef atomic<uint_fast16_t> atomic_uint_fast16_t;


  typedef atomic<int_fast32_t> atomic_int_fast32_t;


  typedef atomic<uint_fast32_t> atomic_uint_fast32_t;


  typedef atomic<int_fast64_t> atomic_int_fast64_t;


  typedef atomic<uint_fast64_t> atomic_uint_fast64_t;



  typedef atomic<intptr_t> atomic_intptr_t;


  typedef atomic<uintptr_t> atomic_uintptr_t;


  typedef atomic<size_t> atomic_size_t;


  typedef atomic<intmax_t> atomic_intmax_t;


  typedef atomic<uintmax_t> atomic_uintmax_t;


  typedef atomic<ptrdiff_t> atomic_ptrdiff_t;



  inline bool
  atomic_flag_test_and_set_explicit(atomic_flag* __a,
        memory_order __m) noexcept
  { return __a->test_and_set(__m); }

  inline bool
  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a,
        memory_order __m) noexcept
  { return __a->test_and_set(__m); }

  inline void
  atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m) noexcept
  { __a->clear(__m); }

  inline void
  atomic_flag_clear_explicit(volatile atomic_flag* __a,
        memory_order __m) noexcept
  { __a->clear(__m); }

  inline bool
  atomic_flag_test_and_set(atomic_flag* __a) noexcept
  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }

  inline bool
  atomic_flag_test_and_set(volatile atomic_flag* __a) noexcept
  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }

  inline void
  atomic_flag_clear(atomic_flag* __a) noexcept
  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }

  inline void
  atomic_flag_clear(volatile atomic_flag* __a) noexcept
  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }



  template<typename _ITp>
    inline bool
    atomic_is_lock_free(const atomic<_ITp>* __a) noexcept
    { return __a->is_lock_free(); }

  template<typename _ITp>
    inline bool
    atomic_is_lock_free(const volatile atomic<_ITp>* __a) noexcept
    { return __a->is_lock_free(); }

  template<typename _ITp>
    inline void
    atomic_init(atomic<_ITp>* __a, _ITp __i) noexcept
    { __a->store(__i, memory_order_relaxed); }

  template<typename _ITp>
    inline void
    atomic_init(volatile atomic<_ITp>* __a, _ITp __i) noexcept
    { __a->store(__i, memory_order_relaxed); }

  template<typename _ITp>
    inline void
    atomic_store_explicit(atomic<_ITp>* __a, _ITp __i,
     memory_order __m) noexcept
    { __a->store(__i, __m); }

  template<typename _ITp>
    inline void
    atomic_store_explicit(volatile atomic<_ITp>* __a, _ITp __i,
     memory_order __m) noexcept
    { __a->store(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_load_explicit(const atomic<_ITp>* __a, memory_order __m) noexcept
    { return __a->load(__m); }

  template<typename _ITp>
    inline _ITp
    atomic_load_explicit(const volatile atomic<_ITp>* __a,
    memory_order __m) noexcept
    { return __a->load(__m); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange_explicit(atomic<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->exchange(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange_explicit(volatile atomic<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->exchange(__i, __m); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak_explicit(atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2,
       memory_order __m1,
       memory_order __m2) noexcept
    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak_explicit(volatile atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2,
       memory_order __m1,
       memory_order __m2) noexcept
    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong_explicit(atomic<_ITp>* __a,
         _ITp* __i1, _ITp __i2,
         memory_order __m1,
         memory_order __m2) noexcept
    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong_explicit(volatile atomic<_ITp>* __a,
         _ITp* __i1, _ITp __i2,
         memory_order __m1,
         memory_order __m2) noexcept
    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }


  template<typename _ITp>
    inline void
    atomic_store(atomic<_ITp>* __a, _ITp __i) noexcept
    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline void
    atomic_store(volatile atomic<_ITp>* __a, _ITp __i) noexcept
    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_load(const atomic<_ITp>* __a) noexcept
    { return atomic_load_explicit(__a, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_load(const volatile atomic<_ITp>* __a) noexcept
    { return atomic_load_explicit(__a, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange(atomic<_ITp>* __a, _ITp __i) noexcept
    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange(volatile atomic<_ITp>* __a, _ITp __i) noexcept
    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak(atomic<_ITp>* __a,
     _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
         memory_order_seq_cst,
         memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak(volatile atomic<_ITp>* __a,
     _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
         memory_order_seq_cst,
         memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong(atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
           memory_order_seq_cst,
           memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong(volatile atomic<_ITp>* __a,
       _ITp* __i1, _ITp __i2) noexcept
    {
      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
           memory_order_seq_cst,
           memory_order_seq_cst);
    }





  template<typename _ITp>
    inline _ITp
    atomic_fetch_add_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_add(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_add(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_sub(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_sub(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_and(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_and(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or_explicit(__atomic_base<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->fetch_or(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
        memory_order __m) noexcept
    { return __a->fetch_or(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_xor(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m) noexcept
    { return __a->fetch_xor(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor(__atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept
    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }



  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
         memory_order __m) noexcept
    { return __a->fetch_add(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add_explicit(volatile atomic<_ITp*>* __a, ptrdiff_t __d,
         memory_order __m) noexcept
    { return __a->fetch_add(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_add(__d); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_add(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_add(__d); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub_explicit(volatile atomic<_ITp*>* __a,
         ptrdiff_t __d, memory_order __m) noexcept
    { return __a->fetch_sub(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,
         memory_order __m) noexcept
    { return __a->fetch_sub(__d, __m); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_sub(__d); }

  template<typename _ITp>
    inline _ITp*
    atomic_fetch_sub(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept
    { return __a->fetch_sub(__d); }



}
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 2 3



inline namespace cl {
namespace sycl {
namespace ONEAPI {

enum class memory_order : int {
  relaxed,
  acquire,
  __consume_unsupported,
  release,
  acq_rel,
  seq_cst
};
inline constexpr memory_order memory_order_relaxed =
    memory_order::relaxed;
inline constexpr memory_order memory_order_acquire =
    memory_order::acquire;
inline constexpr memory_order memory_order_release =
    memory_order::release;
inline constexpr memory_order memory_order_acq_rel =
    memory_order::acq_rel;
inline constexpr memory_order memory_order_seq_cst =
    memory_order::seq_cst;

enum class memory_scope : int {
  work_item,
  sub_group,
  work_group,
  device,
  system
};
inline constexpr memory_scope memory_scope_work_item =
    memory_scope::work_item;
inline constexpr memory_scope memory_scope_sub_group =
    memory_scope::sub_group;
inline constexpr memory_scope memory_scope_work_group =
    memory_scope::work_group;
inline constexpr memory_scope memory_scope_device = memory_scope::device;
inline constexpr memory_scope memory_scope_system = memory_scope::system;


namespace detail {



static inline constexpr std::memory_order
getStdMemoryOrder(::cl::sycl::ONEAPI::memory_order order) {
  switch (order) {
  case memory_order::relaxed:
    return std::memory_order_relaxed;
  case memory_order::__consume_unsupported:
    return std::memory_order_consume;
  case memory_order::acquire:
    return std::memory_order_acquire;
  case memory_order::release:
    return std::memory_order_release;
  case memory_order::acq_rel:
    return std::memory_order_acq_rel;
  case memory_order::seq_cst:
    return std::memory_order_seq_cst;
  }
}
# 98 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_enums.hpp" 3
}


}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_accessor.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_ref.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_ref.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/atomic.hpp" 1 3
# 26 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/atomic.hpp" 3
inline namespace cl {
namespace sycl {

enum class memory_order : int { relaxed };


template <typename pointerT, access::address_space addressSpace>
class multi_ptr;

namespace detail {

using memory_order = cl::sycl::memory_order;

template <typename T> struct IsValidAtomicType {
  static constexpr bool value =
      (std::is_same<T, int>::value || std::is_same<T, unsigned int>::value ||
       std::is_same<T, long>::value || std::is_same<T, unsigned long>::value ||
       std::is_same<T, long long>::value ||
       std::is_same<T, unsigned long long>::value ||
       std::is_same<T, float>::value);
};

template <cl::sycl::access::address_space AS> struct IsValidAtomicAddressSpace {
  static constexpr bool value =
      (AS == access::address_space::global_space ||
       AS == access::address_space::local_space ||
       AS == access::address_space::global_device_space);
};



template <access::address_space AS> struct GetSpirvMemoryScope {};
template <> struct GetSpirvMemoryScope<access::address_space::global_space> {
  static constexpr auto scope = __spv::Scope::Device;
};
template <>
struct GetSpirvMemoryScope<access::address_space::global_device_space> {
  static constexpr auto scope = __spv::Scope::Device;
};
template <> struct GetSpirvMemoryScope<access::address_space::local_space> {
  static constexpr auto scope = __spv::Scope::Workgroup;
};

}
}
}



inline namespace cl {
namespace sycl {
namespace detail {



static inline std::memory_order
getStdMemoryOrder(__spv::MemorySemanticsMask::Flag) {
  return std::memory_order_relaxed;
}
static inline std::memory_order getStdMemoryOrder(::cl::sycl::memory_order) {
  return std::memory_order_relaxed;
}
}
}
}



template <typename T>
void __spirv_AtomicStore(std::atomic<T> *Ptr, __spv::Scope::Flag,
                         __spv::MemorySemanticsMask::Flag MS, T V) {
  Ptr->store(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
T __spirv_AtomicLoad(const std::atomic<T> *Ptr, __spv::Scope::Flag,
                     __spv::MemorySemanticsMask::Flag MS) {
  return Ptr->load(::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
T __spirv_AtomicExchange(std::atomic<T> *Ptr, __spv::Scope::Flag,
                         __spv::MemorySemanticsMask::Flag MS, T V) {
  return Ptr->exchange(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
extern T __spirv_AtomicIAdd(std::atomic<T> *Ptr, __spv::Scope::Flag,
                            __spv::MemorySemanticsMask::Flag MS, T V) {
  return Ptr->fetch_add(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
extern T __spirv_AtomicISub(std::atomic<T> *Ptr, __spv::Scope::Flag,
                            __spv::MemorySemanticsMask::Flag MS, T V) {
  return Ptr->fetch_sub(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
extern T __spirv_AtomicAnd(std::atomic<T> *Ptr, __spv::Scope::Flag,
                           __spv::MemorySemanticsMask::Flag MS, T V) {
  return Ptr->fetch_and(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
extern T __spirv_AtomicOr(std::atomic<T> *Ptr, __spv::Scope::Flag,
                          __spv::MemorySemanticsMask::Flag MS, T V) {
  return Ptr->fetch_or(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
extern T __spirv_AtomicXor(std::atomic<T> *Ptr, __spv::Scope::Flag,
                           __spv::MemorySemanticsMask::Flag MS, T V) {
  return Ptr->fetch_xor(V, ::cl::sycl::detail::getStdMemoryOrder(MS));
}

template <typename T>
extern T __spirv_AtomicMin(std::atomic<T> *Ptr, __spv::Scope::Flag,
                           __spv::MemorySemanticsMask::Flag MS, T V) {
  std::memory_order MemoryOrder = ::cl::sycl::detail::getStdMemoryOrder(MS);
  T Val = Ptr->load(MemoryOrder);
  while (V < Val) {
    if (Ptr->compare_exchange_strong(Val, V, MemoryOrder, MemoryOrder))
      break;
    Val = Ptr->load(MemoryOrder);
  }
  return Val;
}

template <typename T>
extern T __spirv_AtomicMax(std::atomic<T> *Ptr, __spv::Scope::Flag,
                           __spv::MemorySemanticsMask::Flag MS, T V) {
  std::memory_order MemoryOrder = ::cl::sycl::detail::getStdMemoryOrder(MS);
  T Val = Ptr->load(MemoryOrder);
  while (V > Val) {
    if (Ptr->compare_exchange_strong(Val, V, MemoryOrder, MemoryOrder))
      break;
    Val = Ptr->load(MemoryOrder);
  }
  return Val;
}



inline namespace cl {
namespace sycl {

template <typename T, access::address_space addressSpace =
                          access::address_space::global_space>
class atomic {
  friend class atomic<T, access::address_space::global_space>;
  static_assert(detail::IsValidAtomicType<T>::value,
                "Invalid SYCL atomic type. Valid types are: int, "
                "unsigned int, long, unsigned long, long long, unsigned "
                "long long, float");
  static_assert(detail::IsValidAtomicAddressSpace<addressSpace>::value,
                "Invalid SYCL atomic address_space. Valid address spaces are: "
                "global_space, local_space, global_device_space");
  static constexpr auto SpirvScope =
      detail::GetSpirvMemoryScope<addressSpace>::scope;

public:
  template <typename pointerT>




  atomic(multi_ptr<pointerT, addressSpace> ptr)
      : Ptr(reinterpret_cast<std::atomic<T> *>(ptr.get()))

  {
    static_assert(sizeof(T) == sizeof(pointerT),
                  "T and pointerT must be same size");
  }
# 220 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/atomic.hpp" 3
  void store(T Operand, memory_order Order = memory_order::relaxed) {
    __spirv_AtomicStore(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }
# 245 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/atomic.hpp" 3
  T load(memory_order Order = memory_order::relaxed) const {
    return __spirv_AtomicLoad(Ptr, SpirvScope,
                              detail::getSPIRVMemorySemanticsMask(Order));
  }


  T exchange(T Operand, memory_order Order = memory_order::relaxed) {
    return __spirv_AtomicExchange(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  bool
  compare_exchange_strong(T &Expected, T Desired,
                          memory_order SuccessOrder = memory_order::relaxed,
                          memory_order FailOrder = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
# 272 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/atomic.hpp" 3
    return Ptr->compare_exchange_strong(Expected, Desired,
                                        detail::getStdMemoryOrder(SuccessOrder),
                                        detail::getStdMemoryOrder(FailOrder));

  }

  T fetch_add(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicIAdd(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  T fetch_sub(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicISub(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  T fetch_and(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicAnd(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  T fetch_or(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicOr(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  T fetch_xor(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicXor(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  T fetch_min(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicMin(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

  T fetch_max(T Operand, memory_order Order = memory_order::relaxed) {
    static_assert(!std::is_same<T, float>::value, "SYCL atomic function not available for float type");
    return __spirv_AtomicMax(
        Ptr, SpirvScope, detail::getSPIRVMemorySemanticsMask(Order), Operand);
  }

private:



  std::atomic<T> *Ptr;

};

template <typename T, access::address_space addressSpace>
void atomic_store(atomic<T, addressSpace> Object, T Operand,
                  memory_order MemoryOrder = memory_order::relaxed) {
  Object.store(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_load(atomic<T, addressSpace> Object,
              memory_order MemoryOrder = memory_order::relaxed) {
  return Object.load(MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_exchange(atomic<T, addressSpace> Object, T Operand,
                  memory_order MemoryOrder = memory_order::relaxed) {
  return Object.exchange(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
bool atomic_compare_exchange_strong(
    atomic<T, addressSpace> Object, T &Expected, T Desired,
    memory_order SuccessOrder = memory_order::relaxed,
    memory_order FailOrder = memory_order::relaxed) {
  return Object.compare_exchange_strong(Expected, Desired, SuccessOrder,
                                        FailOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_add(atomic<T, addressSpace> Object, T Operand,
                   memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_add(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_sub(atomic<T, addressSpace> Object, T Operand,
                   memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_sub(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_and(atomic<T, addressSpace> Object, T Operand,
                   memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_and(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_or(atomic<T, addressSpace> Object, T Operand,
                  memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_or(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_xor(atomic<T, addressSpace> Object, T Operand,
                   memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_xor(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_min(atomic<T, addressSpace> Object, T Operand,
                   memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_min(Operand, MemoryOrder);
}

template <typename T, access::address_space addressSpace>
T atomic_fetch_max(atomic<T, addressSpace> Object, T Operand,
                   memory_order MemoryOrder = memory_order::relaxed) {
  return Object.fetch_max(Operand, MemoryOrder);
}

}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_ref.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/spirv.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/spirv.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_traits.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_traits.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/aliases.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/aliases.hpp" 3
inline namespace cl {
namespace sycl {
template <typename T, int N> class vec;
namespace detail {
namespace half_impl {
class half;
}
}
}
}





using half = cl::sycl::detail::half_impl::half;
# 72 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/aliases.hpp" 3
inline namespace cl {
namespace sycl {
using byte = std::uint8_t;
using schar = signed char;
using uchar = unsigned char;
using ushort = unsigned short;
using uint = unsigned int;
using ulong = unsigned long;
using longlong = long long;
using ulonglong = unsigned long long;


using half = cl::sycl::detail::half_impl::half;
using cl_bool = bool;
using cl_char = std::int8_t;
using cl_uchar = std::uint8_t;
using cl_short = std::int16_t;
using cl_ushort = std::uint16_t;
using cl_int = std::int32_t;
using cl_uint = std::uint32_t;
using cl_long = std::int64_t;
using cl_ulong = std::uint64_t;
using cl_half = half;
using cl_float = float;
using cl_double = double;

using char2 = cl::sycl::vec<char, 2>; using short2 = cl::sycl::vec<short, 2>; using int2 = cl::sycl::vec<int, 2>; using long2 = cl::sycl::vec<long, 2>; using float2 = cl::sycl::vec<float, 2>; using double2 = cl::sycl::vec<double, 2>; using half2 = cl::sycl::vec<half, 2>; using cl_char2 = cl::sycl::vec<cl::sycl::cl_char, 2>; using cl_uchar2 = cl::sycl::vec<cl::sycl::cl_uchar, 2>; using cl_short2 = cl::sycl::vec<cl::sycl::cl_short, 2>; using cl_ushort2 = cl::sycl::vec<cl::sycl::cl_ushort, 2>; using cl_int2 = cl::sycl::vec<cl::sycl::cl_int, 2>; using cl_uint2 = cl::sycl::vec<cl::sycl::cl_uint, 2>; using cl_long2 = cl::sycl::vec<cl::sycl::cl_long, 2>; using cl_ulong2 = cl::sycl::vec<cl::sycl::cl_ulong, 2>; using cl_float2 = cl::sycl::vec<cl::sycl::cl_float, 2>; using cl_double2 = cl::sycl::vec<cl::sycl::cl_double, 2>; using cl_half2 = cl::sycl::vec<cl::sycl::cl_half, 2>; using schar2 = cl::sycl::vec<signed char, 2>; using uchar2 = cl::sycl::vec<unsigned char, 2>; using ushort2 = cl::sycl::vec<unsigned short, 2>; using uint2 = cl::sycl::vec<unsigned int, 2>; using ulong2 = cl::sycl::vec<unsigned long, 2>; using longlong2 = cl::sycl::vec<long long, 2>; using ulonglong2 = cl::sycl::vec<unsigned long long, 2>;
using char3 = cl::sycl::vec<char, 3>; using short3 = cl::sycl::vec<short, 3>; using int3 = cl::sycl::vec<int, 3>; using long3 = cl::sycl::vec<long, 3>; using float3 = cl::sycl::vec<float, 3>; using double3 = cl::sycl::vec<double, 3>; using half3 = cl::sycl::vec<half, 3>; using cl_char3 = cl::sycl::vec<cl::sycl::cl_char, 3>; using cl_uchar3 = cl::sycl::vec<cl::sycl::cl_uchar, 3>; using cl_short3 = cl::sycl::vec<cl::sycl::cl_short, 3>; using cl_ushort3 = cl::sycl::vec<cl::sycl::cl_ushort, 3>; using cl_int3 = cl::sycl::vec<cl::sycl::cl_int, 3>; using cl_uint3 = cl::sycl::vec<cl::sycl::cl_uint, 3>; using cl_long3 = cl::sycl::vec<cl::sycl::cl_long, 3>; using cl_ulong3 = cl::sycl::vec<cl::sycl::cl_ulong, 3>; using cl_float3 = cl::sycl::vec<cl::sycl::cl_float, 3>; using cl_double3 = cl::sycl::vec<cl::sycl::cl_double, 3>; using cl_half3 = cl::sycl::vec<cl::sycl::cl_half, 3>; using schar3 = cl::sycl::vec<signed char, 3>; using uchar3 = cl::sycl::vec<unsigned char, 3>; using ushort3 = cl::sycl::vec<unsigned short, 3>; using uint3 = cl::sycl::vec<unsigned int, 3>; using ulong3 = cl::sycl::vec<unsigned long, 3>; using longlong3 = cl::sycl::vec<long long, 3>; using ulonglong3 = cl::sycl::vec<unsigned long long, 3>;
using char4 = cl::sycl::vec<char, 4>; using short4 = cl::sycl::vec<short, 4>; using int4 = cl::sycl::vec<int, 4>; using long4 = cl::sycl::vec<long, 4>; using float4 = cl::sycl::vec<float, 4>; using double4 = cl::sycl::vec<double, 4>; using half4 = cl::sycl::vec<half, 4>; using cl_char4 = cl::sycl::vec<cl::sycl::cl_char, 4>; using cl_uchar4 = cl::sycl::vec<cl::sycl::cl_uchar, 4>; using cl_short4 = cl::sycl::vec<cl::sycl::cl_short, 4>; using cl_ushort4 = cl::sycl::vec<cl::sycl::cl_ushort, 4>; using cl_int4 = cl::sycl::vec<cl::sycl::cl_int, 4>; using cl_uint4 = cl::sycl::vec<cl::sycl::cl_uint, 4>; using cl_long4 = cl::sycl::vec<cl::sycl::cl_long, 4>; using cl_ulong4 = cl::sycl::vec<cl::sycl::cl_ulong, 4>; using cl_float4 = cl::sycl::vec<cl::sycl::cl_float, 4>; using cl_double4 = cl::sycl::vec<cl::sycl::cl_double, 4>; using cl_half4 = cl::sycl::vec<cl::sycl::cl_half, 4>; using schar4 = cl::sycl::vec<signed char, 4>; using uchar4 = cl::sycl::vec<unsigned char, 4>; using ushort4 = cl::sycl::vec<unsigned short, 4>; using uint4 = cl::sycl::vec<unsigned int, 4>; using ulong4 = cl::sycl::vec<unsigned long, 4>; using longlong4 = cl::sycl::vec<long long, 4>; using ulonglong4 = cl::sycl::vec<unsigned long long, 4>;
using char8 = cl::sycl::vec<char, 8>; using short8 = cl::sycl::vec<short, 8>; using int8 = cl::sycl::vec<int, 8>; using long8 = cl::sycl::vec<long, 8>; using float8 = cl::sycl::vec<float, 8>; using double8 = cl::sycl::vec<double, 8>; using half8 = cl::sycl::vec<half, 8>; using cl_char8 = cl::sycl::vec<cl::sycl::cl_char, 8>; using cl_uchar8 = cl::sycl::vec<cl::sycl::cl_uchar, 8>; using cl_short8 = cl::sycl::vec<cl::sycl::cl_short, 8>; using cl_ushort8 = cl::sycl::vec<cl::sycl::cl_ushort, 8>; using cl_int8 = cl::sycl::vec<cl::sycl::cl_int, 8>; using cl_uint8 = cl::sycl::vec<cl::sycl::cl_uint, 8>; using cl_long8 = cl::sycl::vec<cl::sycl::cl_long, 8>; using cl_ulong8 = cl::sycl::vec<cl::sycl::cl_ulong, 8>; using cl_float8 = cl::sycl::vec<cl::sycl::cl_float, 8>; using cl_double8 = cl::sycl::vec<cl::sycl::cl_double, 8>; using cl_half8 = cl::sycl::vec<cl::sycl::cl_half, 8>; using schar8 = cl::sycl::vec<signed char, 8>; using uchar8 = cl::sycl::vec<unsigned char, 8>; using ushort8 = cl::sycl::vec<unsigned short, 8>; using uint8 = cl::sycl::vec<unsigned int, 8>; using ulong8 = cl::sycl::vec<unsigned long, 8>; using longlong8 = cl::sycl::vec<long long, 8>; using ulonglong8 = cl::sycl::vec<unsigned long long, 8>;
using char16 = cl::sycl::vec<char, 16>; using short16 = cl::sycl::vec<short, 16>; using int16 = cl::sycl::vec<int, 16>; using long16 = cl::sycl::vec<long, 16>; using float16 = cl::sycl::vec<float, 16>; using double16 = cl::sycl::vec<double, 16>; using half16 = cl::sycl::vec<half, 16>; using cl_char16 = cl::sycl::vec<cl::sycl::cl_char, 16>; using cl_uchar16 = cl::sycl::vec<cl::sycl::cl_uchar, 16>; using cl_short16 = cl::sycl::vec<cl::sycl::cl_short, 16>; using cl_ushort16 = cl::sycl::vec<cl::sycl::cl_ushort, 16>; using cl_int16 = cl::sycl::vec<cl::sycl::cl_int, 16>; using cl_uint16 = cl::sycl::vec<cl::sycl::cl_uint, 16>; using cl_long16 = cl::sycl::vec<cl::sycl::cl_long, 16>; using cl_ulong16 = cl::sycl::vec<cl::sycl::cl_ulong, 16>; using cl_float16 = cl::sycl::vec<cl::sycl::cl_float, 16>; using cl_double16 = cl::sycl::vec<cl::sycl::cl_double, 16>; using cl_half16 = cl::sycl::vec<cl::sycl::cl_half, 16>; using schar16 = cl::sycl::vec<signed char, 16>; using uchar16 = cl::sycl::vec<unsigned char, 16>; using ushort16 = cl::sycl::vec<unsigned short, 16>; using uint16 = cl::sycl::vec<unsigned int, 16>; using ulong16 = cl::sycl::vec<unsigned long, 16>; using longlong16 = cl::sycl::vec<long long, 16>; using ulonglong16 = cl::sycl::vec<unsigned long long, 16>;
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_traits.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/half_type.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/half_type.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3





# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ();



extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int totalorder (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermag (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ();



extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int totalorderf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ();



extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int totalorderl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ();





extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32 __nanf32 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ();



extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int totalorderf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ();





extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64 __nanf64 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ();



extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int totalorderf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ();





extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32x __nanf32x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ();



extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int totalorderf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ();





extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64x __nanf64x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ();




extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ();





extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ();





extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ();



extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int totalorderf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 684 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }



}
# 685 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



}
# 725 "/usr/include/math.h" 3 4
extern "C++" {
# 754 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 952 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathinline.h" 1 3 4
# 953 "/usr/include/math.h" 2 3 4
# 1205 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (double __x, double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1246 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 2 3
# 77 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 536 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 958 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
}
# 1075 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }



}






namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type;
      return std::__hypot3<__type>(__x, __y, __z);
    }

}





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
#pragma GCC visibility push(default)
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 1 3
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/special_function_util.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  namespace __detail
  {





    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 135 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/special_function_util.h" 3
  }



}
# 50 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma"));

          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi"));

      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }


  }




}
# 50 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 1 3
# 51 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 65 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 94 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 132 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion."));

      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn."));

          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn."));

          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 357 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __mum1 = __mu - _Tp(1);
      const _Tp __mum9 = __mu - _Tp(9);
      const _Tp __mum25 = __mu - _Tp(25);
      const _Tp __mum49 = __mu - _Tp(49);
      const _Tp __xx = _Tp(64) * __x * __x;
      const _Tp __P = _Tp(1) - __mum1 * __mum9 / (_Tp(2) * __xx)
                    * (_Tp(1) - __mum25 * __mum49 / (_Tp(12) * __xx));
      const _Tp __Q = __mum1 / (_Tp(8) * __x)
                    * (_Tp(1) - __mum9 * __mum25 / (_Tp(6) * __xx));

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                            * __numeric_constants<_Tp>::__pi_2();
      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));
      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 413 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 459 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j."));

      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 501 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n."));

      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 538 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 573 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel."));

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 611 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann."));

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }


  }




}
# 51 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 1 3
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }


  }




}
# 52 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 1 3
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(5) * __min;
      const _Tp __uplim = __max / _Tp(5);

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf."));

      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 155 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 193 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 221 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 268 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 316 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));
      const _Tp __uplim = std::pow(_Tp(0.1L) * __errtol / __min, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd."));

      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd."));

      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }


          _Tp __eaa = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __eaa - __eb;
          _Tp __ed = __eaa - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __eaa));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 404 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 438 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 497 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(5) * __min;
      const _Tp __uplim = __max / _Tp(5);

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc."));

      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 568 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));
      const _Tp __uplim = _Tp(0.3L)
                        * std::pow(_Tp(0.2L) * __max, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj."));

      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj"));

      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __lambda, __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }


          _Tp __eaa = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __eaa - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__eaa - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __eaa * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 672 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 712 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }


  }



}
# 53 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 1 3
# 50 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
  namespace __detail
  {


    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series."));

    }
# 201 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac."));

    }
# 246 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }


  }



}
# 54 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 58 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series."));


      return __Fac;
    }
# 120 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke."));


      return __F;
    }
# 227 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series."));


      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke."));


      return __F;
    }
# 438 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke."));

                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect"));


              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect"));

                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect"));

                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect"));

                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect"));

            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg."));

      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }


  }




}
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/legendre_function.tcc" 1 3
# 49 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if ((__x < _Tp(-1)) || (__x > _Tp(+1)))
        std::__throw_domain_error(("Argument out of range" " in __poly_legendre_p."));

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 137 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x)
    {

      if (__x < _Tp(-1) || __x > _Tp(+1))
        std::__throw_domain_error(("Argument out of range" " in __assoc_legendre_p."));

      else if (__m > __l)
        std::__throw_domain_error(("Degree out of range" " in __assoc_legendre_p."));

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= -__fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__l < __m)
        {
          std::__throw_domain_error(("Bad argument " "in __sph_legendre."));

        }
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                   / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            {
              return __y_mm;
            }
          else if (__l == __m + 1)
            {
              return __y_mp1m;
            }
          else
            {
              _Tp __y_lm = _Tp(0);


              for ( int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }


  }




}
# 56 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion."));


      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik."));

          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik."));

          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i."));

      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k."));

      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);

      if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }


  }



}
# 57 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 54 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }


  }



}
# 58 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 58 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre."));


      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }


  }




}
# 59 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 61 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }


  }




}
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 205 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 250 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 266 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 296 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 311 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 341 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 357 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 389 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 405 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 436 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 452 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 487 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 503 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 533 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 549 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 579 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 595 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 631 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 647 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 679 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 695 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 727 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 743 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 775 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 791 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 828 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 843 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 868 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 884 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 916 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 932 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 960 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 976 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1005 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1021 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1056 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1072 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1100 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1116 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1127 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1147 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1163 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1191 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 1216 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1227 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1247 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1264 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1275 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1296 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }

}

#pragma GCC visibility pop
# 1915 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 2 3


}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/half_type.hpp" 2 3
# 30 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/half_type.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {
namespace host_half_impl {

class __attribute__((visibility("default"))) half {
public:
  half() = default;
  half(const half &) = default;
  half(half &&) = default;

  half(const float &rhs);

  half &operator=(const half &rhs) = default;


  half &operator+=(const half &rhs);

  half &operator-=(const half &rhs);

  half &operator*=(const half &rhs);

  half &operator/=(const half &rhs);


  half &operator++() {
    *this += 1;
    return *this;
  }

  half operator++(int) {
    half ret(*this);
    operator++();
    return ret;
  }

  half &operator--() {
    *this -= 1;
    return *this;
  }

  half operator--(int) {
    half ret(*this);
    operator--();
    return ret;
  }


  operator float() const;

  template <typename Key> friend struct std::hash;

private:
  uint16_t Buf;
};

}

namespace half_impl {
class half;
# 115 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/half_type.hpp" 3
  using StorageT = detail::host_half_impl::half;


  using BIsRepresentationT = half;





  template <int NumElements> struct half_vec {
    alignas(detail::vector_alignment<StorageT, NumElements>::value)
      std::array<StorageT, NumElements> s;
  };

  using Vec2StorageT = half_vec<2>;
  using Vec3StorageT = half_vec<3>;
  using Vec4StorageT = half_vec<4>;
  using Vec8StorageT = half_vec<8>;
  using Vec16StorageT = half_vec<16>;


class half {
public:
  half() = default;
  half(const half &) = default;
  half(half &&) = default;

                             half(const float &rhs) : Data(rhs) {}

  half &operator=(const half &rhs) = default;




  half(const detail::host_half_impl::half &rhs) : Data(rhs) {};
  operator detail::host_half_impl::half() const { return Data; }



  half &operator+=(const half &rhs) {
    Data += rhs.Data;
    return *this;
  }

  half &operator-=(const half &rhs) {
    Data -= rhs.Data;
    return *this;
  }

  half &operator*=(const half &rhs) {
    Data *= rhs.Data;
    return *this;
  }

  half &operator/=(const half &rhs) {
    Data /= rhs.Data;
    return *this;
  }


  half &operator++() {
    *this += 1;
    return *this;
  }

  half operator++(int) {
    half ret(*this);
    operator++();
    return ret;
  }

  half &operator--() {
    *this -= 1;
    return *this;
  }

  half operator--(int) {
    half ret(*this);
    operator--();
    return ret;
  }


  operator float() const { return static_cast<float>(Data); }

  template <typename Key> friend struct std::hash;
private:
  StorageT Data;
};
}







template <typename T> inline T cast_if_host_half(T val) { return val; }

inline float cast_if_host_half(half_impl::half val) {
  return static_cast<float>(val);
}

}

}
}


namespace std {


template <> struct hash<cl::sycl::half> {
  size_t operator()(cl::sycl::half const &Key) const noexcept {
    return hash<uint16_t>{}(reinterpret_cast<const uint16_t &>(Key));
  }
};
# 260 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/half_type.hpp" 3
template <> struct numeric_limits<cl::sycl::half> {
  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;

  static constexpr const bool is_integer = false;

  static constexpr const bool is_exact = false;

  static constexpr const bool has_infinity = true;

  static constexpr const bool has_quiet_NaN = true;

  static constexpr const bool has_signaling_NaN = true;

  static constexpr const float_denorm_style has_denorm = denorm_present;

  static constexpr const bool has_denorm_loss = false;

  static constexpr const bool tinyness_before = false;

  static constexpr const bool traps = false;

  static constexpr const int max_exponent10 = 4;

  static constexpr const int max_exponent = 16;

  static constexpr const int min_exponent10 = (-4);

  static constexpr const int min_exponent = (-13);

  static constexpr const int radix = 2;

  static constexpr const int max_digits10 = 5;

  static constexpr const int digits = 11;

  static constexpr const bool is_bounded = true;

  static constexpr const int digits10 = 3;

  static constexpr const bool is_modulo = false;

  static constexpr const bool is_iec559 = true;

  static constexpr const float_round_style round_style = round_to_nearest;

  static const cl::sycl::half(min)() noexcept {
    return 6.103515625e-05F;
  }

  static const cl::sycl::half(max)() noexcept {
    return 65504.0F;
  }

  static const cl::sycl::half lowest() noexcept {
    return -65504.0F;
  }

  static const cl::sycl::half epsilon() noexcept {
    return 9.765625e-04F;
  }

  static const cl::sycl::half
  round_error() noexcept {
    return 0.5F;
  }

  static const cl::sycl::half infinity() noexcept {
    return __builtin_huge_valf();
  }

  static const cl::sycl::half quiet_NaN() noexcept {
    return __builtin_nanf("");
  }

  static const cl::sycl::half
  signaling_NaN() noexcept {
    return __builtin_nansf("");
  }

  static const cl::sycl::half denorm_min() noexcept {
    return 5.96046e-08F;
  }
};

}

inline std::ostream &operator<<(std::ostream &O, cl::sycl::half const &rhs) {
  O << static_cast<float>(rhs);
  return O;
}

inline std::istream &operator>>(std::istream &I, cl::sycl::half &rhs) {
  float ValFloat = 0.0f;
  I >> ValFloat;
  rhs = ValFloat;
  return I;
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/generic_type_traits.hpp" 2 3




inline namespace cl {
namespace sycl {
namespace detail {

template <typename T> using is_floatn = is_contained<T, gtl::vector_float_list>;

template <typename T> using is_genfloatf = is_contained<T, gtl::float_list>;

template <typename T>
using is_doublen = is_contained<T, gtl::vector_double_list>;

template <typename T> using is_genfloatd = is_contained<T, gtl::double_list>;

template <typename T> using is_halfn = is_contained<T, gtl::vector_half_list>;

template <typename T> using is_genfloath = is_contained<T, gtl::half_list>;

template <typename T> using is_genfloat = is_contained<T, gtl::floating_list>;

template <typename T>
using is_sgenfloat = is_contained<T, gtl::scalar_floating_list>;

template <typename T>
using is_vgenfloat = is_contained<T, gtl::vector_floating_list>;

template <typename T>
using is_gengeofloat = is_contained<T, gtl::geo_float_list>;

template <typename T>
using is_gengeodouble = is_contained<T, gtl::geo_double_list>;

template <typename T> using is_gengeohalf = is_contained<T, gtl::geo_half_list>;

template <typename T>
using is_vgengeofloat = is_contained<T, gtl::vector_geo_float_list>;

template <typename T>
using is_vgengeodouble = is_contained<T, gtl::vector_geo_double_list>;

template <typename T>
using is_vgengeohalf = is_contained<T, gtl::vector_geo_half_list>;

template <typename T> using is_sgengeo = is_contained<T, gtl::scalar_geo_list>;

template <typename T> using is_vgengeo = is_contained<T, gtl::vector_geo_list>;

template <typename T>
using is_gencrossfloat = is_contained<T, gtl::cross_float_list>;

template <typename T>
using is_gencrossdouble = is_contained<T, gtl::cross_double_list>;

template <typename T>
using is_gencrosshalf = is_contained<T, gtl::cross_half_list>;

template <typename T>
using is_gencross = is_contained<T, gtl::cross_floating_list>;

template <typename T>
using is_charn = is_contained<T, gtl::vector_default_char_list>;

template <typename T>
using is_scharn = is_contained<T, gtl::vector_signed_char_list>;

template <typename T>
using is_ucharn = is_contained<T, gtl::vector_unsigned_char_list>;

template <typename T>
using is_igenchar = is_contained<T, gtl::signed_char_list>;

template <typename T>
using is_ugenchar = is_contained<T, gtl::unsigned_char_list>;

template <typename T> using is_genchar = is_contained<T, gtl::char_list>;

template <typename T>
using is_shortn = is_contained<T, gtl::vector_signed_short_list>;

template <typename T>
using is_genshort = is_contained<T, gtl::signed_short_list>;

template <typename T>
using is_ushortn = is_contained<T, gtl::vector_unsigned_short_list>;

template <typename T>
using is_ugenshort = is_contained<T, gtl::unsigned_short_list>;

template <typename T>
using is_uintn = is_contained<T, gtl::vector_unsigned_int_list>;

template <typename T>
using is_ugenint = is_contained<T, gtl::unsigned_int_list>;

template <typename T>
using is_intn = is_contained<T, gtl::vector_signed_int_list>;

template <typename T> using is_genint = is_contained<T, gtl::signed_int_list>;

template <typename T>
using is_ulongn = is_contained<T, gtl::vector_unsigned_long_list>;

template <typename T>
using is_ugenlong = is_contained<T, gtl::unsigned_long_list>;

template <typename T>
using is_longn = is_contained<T, gtl::vector_signed_long_list>;

template <typename T> using is_genlong = is_contained<T, gtl::signed_long_list>;

template <typename T>
using is_ulonglongn = is_contained<T, gtl::vector_unsigned_longlong_list>;

template <typename T>
using is_ugenlonglong = is_contained<T, gtl::unsigned_longlong_list>;

template <typename T>
using is_longlongn = is_contained<T, gtl::vector_signed_longlong_list>;

template <typename T>
using is_genlonglong = is_contained<T, gtl::signed_longlong_list>;

template <typename T>
using is_igenlonginteger = is_contained<T, gtl::signed_long_integer_list>;

template <typename T>
using is_ugenlonginteger = is_contained<T, gtl::unsigned_long_integer_list>;

template <typename T> using is_geninteger = is_contained<T, gtl::integer_list>;

template <typename T>
using is_igeninteger = is_contained<T, gtl::signed_integer_list>;

template <typename T>
using is_ugeninteger = is_contained<T, gtl::unsigned_integer_list>;

template <typename T>
using is_sgeninteger = is_contained<T, gtl::scalar_integer_list>;

template <typename T>
using is_vgeninteger = is_contained<T, gtl::vector_integer_list>;

template <typename T>
using is_sigeninteger = is_contained<T, gtl::scalar_signed_integer_list>;

template <typename T>
using is_sugeninteger = is_contained<T, gtl::scalar_unsigned_integer_list>;

template <typename T>
using is_vigeninteger = is_contained<T, gtl::vector_signed_integer_list>;

template <typename T>
using is_vugeninteger = is_contained<T, gtl::vector_unsigned_integer_list>;

template <typename T> using is_gentype = is_contained<T, gtl::basic_list>;

template <typename T>
using is_vgentype = is_contained<T, gtl::vector_basic_list>;

template <typename T>
using is_sgentype = is_contained<T, gtl::scalar_basic_list>;

template <typename T>
using is_igeninteger8bit = is_gen_based_on_type_sizeof<T, 1, is_igeninteger>;

template <typename T>
using is_igeninteger16bit = is_gen_based_on_type_sizeof<T, 2, is_igeninteger>;

template <typename T>
using is_igeninteger32bit = is_gen_based_on_type_sizeof<T, 4, is_igeninteger>;

template <typename T>
using is_igeninteger64bit = is_gen_based_on_type_sizeof<T, 8, is_igeninteger>;

template <typename T>
using is_ugeninteger8bit = is_gen_based_on_type_sizeof<T, 1, is_ugeninteger>;

template <typename T>
using is_ugeninteger16bit = is_gen_based_on_type_sizeof<T, 2, is_ugeninteger>;

template <typename T>
using is_ugeninteger32bit = is_gen_based_on_type_sizeof<T, 4, is_ugeninteger>;

template <typename T>
using is_ugeninteger64bit = is_gen_based_on_type_sizeof<T, 8, is_ugeninteger>;

template <typename T>
using is_geninteger8bit = is_gen_based_on_type_sizeof<T, 1, is_geninteger>;

template <typename T>
using is_geninteger16bit = is_gen_based_on_type_sizeof<T, 2, is_geninteger>;

template <typename T>
using is_geninteger32bit = is_gen_based_on_type_sizeof<T, 4, is_geninteger>;

template <typename T>
using is_geninteger64bit = is_gen_based_on_type_sizeof<T, 8, is_geninteger>;

template <typename T>
using is_genintptr = bool_constant<
    is_pointer<T>::value && is_genint<remove_pointer_t<T>>::value &&
    is_address_space_compliant<T, gvl::nonconst_address_space_list>::value>;

template <typename T>
using is_genfloatptr = bool_constant<
    is_pointer<T>::value && is_genfloat<remove_pointer_t<T>>::value &&
    is_address_space_compliant<T, gvl::nonconst_address_space_list>::value>;

template <typename T>
using is_genptr = bool_constant<
    is_pointer<T>::value && is_gentype<remove_pointer_t<T>>::value &&
    is_address_space_compliant<T, gvl::nonconst_address_space_list>::value>;

template <typename T> using is_nan_type = is_contained<T, gtl::nan_list>;


template <typename T, typename Enable = void> struct nan_types;

template <typename T>
struct nan_types<
    T, enable_if_t<is_contained<T, gtl::unsigned_short_list>::value, T>> {
  using ret_type = change_base_type_t<T, half>;
  using arg_type = find_same_size_type_t<gtl::scalar_unsigned_short_list, half>;
};

template <typename T>
struct nan_types<
    T, enable_if_t<is_contained<T, gtl::unsigned_int_list>::value, T>> {
  using ret_type = change_base_type_t<T, float>;
  using arg_type = find_same_size_type_t<gtl::scalar_unsigned_int_list, float>;
};

template <typename T>
struct nan_types<
    T,
    enable_if_t<is_contained<T, gtl::unsigned_long_integer_list>::value, T>> {
  using ret_type = change_base_type_t<T, double>;
  using arg_type =
      find_same_size_type_t<gtl::scalar_unsigned_long_integer_list, double>;
};

template <typename T> using nan_return_t = typename nan_types<T, T>::ret_type;

template <typename T>
using nan_argument_base_t = typename nan_types<T, T>::arg_type;

template <typename T>
using make_floating_point_t = make_type_t<T, gtl::scalar_floating_list>;

template <typename T>
using make_singed_integer_t = make_type_t<T, gtl::scalar_signed_integer_list>;

template <typename T>
using make_unsinged_integer_t =
    make_type_t<T, gtl::scalar_unsigned_integer_list>;

template <typename T, typename B, typename Enable = void>
struct convert_data_type_impl;

template <typename T, typename B>
struct convert_data_type_impl<T, B, enable_if_t<is_sgentype<T>::value, T>> {
  B operator()(T t) { return static_cast<B>(t); }
};

template <typename T, typename B>
struct convert_data_type_impl<T, B, enable_if_t<is_vgentype<T>::value, T>> {
  vec<B, T::get_count()> operator()(T t) { return t.template convert<B>(); }
};

template <typename T, typename B>
using convert_data_type = convert_data_type_impl<T, B, T>;


template <typename T> class TryToGetPointerT {
  static T check(...);
  template <typename A> static typename A::pointer_t check(const A &);

public:
  using type = decltype(check(T()));
  static constexpr bool value =
      std::is_pointer<T>::value || !std::is_same<T, type>::value;
};


template <typename T> class TryToGetElementType {
  static T check(...);
  template <typename A> static typename A::element_type check(const A &);

public:
  using type = decltype(check(T()));
  static constexpr bool value = !std::is_same<T, type>::value;
};


template <typename T> class TryToGetVectorT {
  static T check(...);
  template <typename A> static typename A::vector_t check(const A &);

public:
  using type = decltype(check(T()));
  static constexpr bool value = !std::is_same<T, type>::value;
};



template <typename T> class TryToGetPointerVecT {
  static T check(...);
  template <typename A>
  static typename PtrValueType<
      typename TryToGetVectorT<typename TryToGetElementType<A>::type>::type,
      A::address_space>::type *
  check(const A &);
  template <typename A>
  static typename TryToGetVectorT<A>::type *check(const A *);

public:
  using type = decltype(check(T()));
};

template <typename T, typename = typename std::enable_if<
                          TryToGetPointerT<T>::value, std::true_type>::type>
typename TryToGetPointerVecT<T>::type TryToGetPointer(T &t) {


  return reinterpret_cast<typename TryToGetPointerVecT<T>::type>(t.get());
}

template <typename T>
typename TryToGetPointerVecT<T *>::type TryToGetPointer(T *t) {


  return reinterpret_cast<typename TryToGetPointerVecT<T *>::type>(t);
}

template <typename T, typename = typename std::enable_if<
                          !TryToGetPointerT<T>::value, std::false_type>::type>
T TryToGetPointer(T &t) {
  return t;
}



template <typename T, typename T8, typename T16, typename T32, typename T64>
using select_apply_cl_scalar_t =
    conditional_t<sizeof(T) == 1, T8,
                  conditional_t<sizeof(T) == 2, T16,
                                conditional_t<sizeof(T) == 4, T32, T64>>>;


template <typename T>
using select_cl_scalar_integral_signed_t =
    select_apply_cl_scalar_t<T, sycl::cl_char, sycl::cl_short, sycl::cl_int,
                             sycl::cl_long>;

template <typename T>
using select_cl_scalar_integral_unsigned_t =
    select_apply_cl_scalar_t<T, sycl::cl_uchar, sycl::cl_ushort, sycl::cl_uint,
                             sycl::cl_ulong>;

template <typename T>
using select_cl_scalar_float_t =
    select_apply_cl_scalar_t<T, std::false_type, sycl::cl_half, sycl::cl_float,
                             sycl::cl_double>;

template <typename T>
using select_cl_scalar_integral_t =
    conditional_t<std::is_signed<T>::value,
                  select_cl_scalar_integral_signed_t<T>,
                  select_cl_scalar_integral_unsigned_t<T>>;



template <typename T>
using select_cl_scalar_t = conditional_t<
    std::is_integral<T>::value, select_cl_scalar_integral_t<T>,
    conditional_t<
        std::is_floating_point<T>::value, select_cl_scalar_float_t<T>,


        conditional_t<std::is_same<T, half>::value,
                      cl::sycl::detail::half_impl::BIsRepresentationT, T>>>;




template <typename T, typename Enable = void> struct select_cl_vector_or_scalar;

template <typename T>
struct select_cl_vector_or_scalar<
    T, typename std::enable_if<is_vgentype<T>::value>::type> {
  using type =



      vec<conditional_t<std::is_same<typename T::element_type, half>::value,
                        typename T::element_type,
                        select_cl_scalar_t<typename T::element_type>>,
          T::get_count()>;
};

template <typename T>
struct select_cl_vector_or_scalar<
    T, typename std::enable_if<!is_vgentype<T>::value>::type> {
  using type = select_cl_scalar_t<T>;
};





template <typename T, typename Enable = void>
struct select_cl_mptr_or_vector_or_scalar;

template <typename T>
struct select_cl_mptr_or_vector_or_scalar<
    T, typename std::enable_if<is_genptr<T>::value &&
                               !std::is_pointer<T>::value>::type> {
  using type = multi_ptr<
      typename select_cl_vector_or_scalar<typename T::element_type>::type,
      T::address_space>;
};

template <typename T>
struct select_cl_mptr_or_vector_or_scalar<
    T, typename std::enable_if<!is_genptr<T>::value ||
                               std::is_pointer<T>::value>::type> {
  using type = typename select_cl_vector_or_scalar<T>::type;
};


template <typename T>
using SelectMatchingOpenCLType_t =
    typename select_cl_mptr_or_vector_or_scalar<T>::type;



template <typename T>
using ConvertToOpenCLType_t = conditional_t<
    TryToGetVectorT<SelectMatchingOpenCLType_t<T>>::value,
    typename TryToGetVectorT<SelectMatchingOpenCLType_t<T>>::type,
    conditional_t<
        TryToGetPointerT<SelectMatchingOpenCLType_t<T>>::value,
        typename TryToGetPointerVecT<SelectMatchingOpenCLType_t<T>>::type,
        SelectMatchingOpenCLType_t<T>>>;



template <typename FROM, typename TO>
typename std::enable_if<is_vgentype<FROM>::value && is_vgentype<TO>::value &&
                            sizeof(TO) == sizeof(FROM),
                        TO>::type
convertDataToType(FROM t) {
  return t.template as<TO>();
}

template <typename FROM, typename TO>
typename std::enable_if<!(is_vgentype<FROM>::value && is_vgentype<TO>::value) &&
                            sizeof(TO) == sizeof(FROM),
                        TO>::type
convertDataToType(FROM t) {
  return TryToGetPointer(t);
}


template <typename T> inline constexpr T msbMask(T) {
  using UT = make_unsigned_t<T>;
  return T(UT(1) << (sizeof(T) * 8 - 1));
}

template <typename T> inline constexpr bool msbIsSet(const T x) {
  return (x & msbMask(x));
}

template <typename T>
using common_rel_ret_t =
    conditional_t<is_vgentype<T>::value, make_singed_integer_t<T>, int>;


template <int N> struct Boolean;


template <typename T, typename Enable = void> struct TryToGetNumElements;

template <typename T>
struct TryToGetNumElements<
    T, typename std::enable_if<TryToGetVectorT<T>::value>::type> {
  static constexpr int value = T::get_count();
};
template <typename T>
struct TryToGetNumElements<
    T, typename std::enable_if<!TryToGetVectorT<T>::value>::type> {
  static constexpr int value = 1;
};


template <typename T> struct RelationalReturnType {



  using type = common_rel_ret_t<T>;

};

template <typename T> using rel_ret_t = typename RelationalReturnType<T>::type;


template <typename T> struct RelationalTestForSignBitType {




  using return_type = int;
  using argument_type = T;

};

template <typename T>
using rel_sign_bit_test_ret_t =
    typename RelationalTestForSignBitType<T>::return_type;

template <typename T>
using rel_sign_bit_test_arg_t =
    typename RelationalTestForSignBitType<T>::argument_type;

template <typename T, typename Enable = void> struct RelConverter;

template <typename T>
struct RelConverter<
    T, typename std::enable_if<TryToGetElementType<T>::value>::type> {
  static const int N = T::get_count();




  using bool_t = Boolean<N>;
  using ret_t = rel_ret_t<T>;


  static ret_t apply(bool_t value) {







    return value;

  }
};

template <typename T>
struct RelConverter<
    T, typename std::enable_if<!TryToGetElementType<T>::value>::type> {
  using R = rel_ret_t<T>;



  using value_t = R;


  static R apply(value_t value) { return value; }
};

template <typename T> static constexpr T max_v() {
  return (std::numeric_limits<T>::max)();
}

template <typename T> static constexpr T min_v() {
  return (std::numeric_limits<T>::min)();
}

template <typename T> static constexpr T quiet_NaN() {
  return std::numeric_limits<T>::quiet_NaN();
}


template <int FirstSize, typename... Args> class is_same_vector_size_impl;

template <int FirstSize, typename T, typename... Args>
class is_same_vector_size_impl<FirstSize, T, Args...> {
  using CurrentT = detail::remove_pointer_t<T>;
  static constexpr int Size = vector_size<CurrentT>::value;
  static constexpr bool IsSizeEqual = (Size == FirstSize);

public:
  static constexpr bool value =
      IsSizeEqual ? is_same_vector_size_impl<FirstSize, Args...>::value : false;
};

template <int FirstSize>
class is_same_vector_size_impl<FirstSize> : public std::true_type {};

template <typename T, typename... Args> class is_same_vector_size {
  using CurrentT = remove_pointer_t<T>;
  static constexpr int Size = vector_size<CurrentT>::value;

public:
  static constexpr bool value = is_same_vector_size_impl<Size, Args...>::value;
};


template <typename... Args> inline void check_vector_size() {
  static_assert(is_same_vector_size<Args...>::value,
                "The built-in function arguments must [point to|have] types "
                "with the same number of elements.");
}

}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/spirv.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/array.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/array.hpp" 3
inline namespace cl {
namespace sycl {
template <int dimensions> class id;
template <int dimensions> class range;
namespace detail {

template <int dimensions = 1> class array {
  static_assert(dimensions >= 1, "Array cannot be 0-dimensional.");

public:


  template <int N = dimensions>
  array(typename std::enable_if<(N == 1), size_t>::type dim0 = 0)
      : common_array{dim0} {}



  template <int N = dimensions>
  array(typename std::enable_if<(N == 2), size_t>::type dim0, size_t dim1)
      : common_array{dim0, dim1} {}

  template <int N = dimensions, detail::enable_if_t<(N == 2), size_t> = 0>
  array() : array(0, 0) {}



  template <int N = dimensions>
  array(typename std::enable_if<(N == 3), size_t>::type dim0, size_t dim1,
        size_t dim2)
      : common_array{dim0, dim1, dim2} {}

  template <int N = dimensions, detail::enable_if_t<(N == 3), size_t> = 0>
  array() : array(0, 0, 0) {}


  operator cl::sycl::id<dimensions>() const {
    cl::sycl::id<dimensions> result;
    for (int i = 0; i < dimensions; ++i) {
      result[i] = common_array[i];
    }
    return result;
  }

  operator cl::sycl::range<dimensions>() const {
    cl::sycl::range<dimensions> result;
    for (int i = 0; i < dimensions; ++i) {
      result[i] = common_array[i];
    }
    return result;
  }

  size_t get(int dimension) const {
    check_dimension(dimension);
    return common_array[dimension];
  }

  size_t &operator[](int dimension) {
    check_dimension(dimension);
    return common_array[dimension];
  }

  size_t operator[](int dimension) const {
    check_dimension(dimension);
    return common_array[dimension];
  }

  array(const array<dimensions> &rhs) = default;
  array(array<dimensions> &&rhs) = default;
  array<dimensions> &operator=(const array<dimensions> &rhs) = default;
  array<dimensions> &operator=(array<dimensions> &&rhs) = default;



  bool operator==(const array<dimensions> &rhs) const {
    for (int i = 0; i < dimensions; ++i) {
      if (this->common_array[i] != rhs.common_array[i]) {
        return false;
      }
    }
    return true;
  }



  bool operator!=(const array<dimensions> &rhs) const {
    for (int i = 0; i < dimensions; ++i) {
      if (this->common_array[i] != rhs.common_array[i]) {
        return true;
      }
    }
    return false;
  }

protected:
  size_t common_array[dimensions];
  __attribute__((always_inline)) void check_dimension(int dimension) const {


    if (dimension >= dimensions || dimension < 0) {
      throw cl::sycl::invalid_parameter_error("Index out of range",
                                              PI_INVALID_VALUE);
    }


    (void)dimension;
  }
};

}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/range.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/range.hpp" 3
inline namespace cl {
namespace sycl {
template <int dimensions> class id;





template <int dimensions = 1> class range : public detail::array<dimensions> {
  static_assert(dimensions >= 1 && dimensions <= 3,
                "range can only be 1, 2, or 3 dimensional.");
  using base = detail::array<dimensions>;
  template <typename N, typename T>
  using IntegralType = detail::enable_if_t<std::is_integral<N>::value, T>;

public:


  template <int N = dimensions>
  range(typename std::enable_if<(N == 1), size_t>::type dim0) : base(dim0) {}



  template <int N = dimensions>
  range(typename std::enable_if<(N == 2), size_t>::type dim0, size_t dim1)
      : base(dim0, dim1) {}



  template <int N = dimensions>
  range(typename std::enable_if<(N == 3), size_t>::type dim0, size_t dim1,
        size_t dim2)
      : base(dim0, dim1, dim2) {}

  explicit operator id<dimensions>() const {
    id<dimensions> result;
    for (int i = 0; i < dimensions; ++i) {
      result[i] = this->get(i);
    }
    return result;
  }

  size_t size() const {
    size_t size = 1;
    for (int i = 0; i < dimensions; ++i) {
      size *= this->get(i);
    }
    return size;
  }

  range(const range<dimensions> &rhs) = default;
  range(range<dimensions> &&rhs) = default;
  range<dimensions> &operator=(const range<dimensions> &rhs) = default;
  range<dimensions> &operator=(range<dimensions> &&rhs) = default;
  range() = delete;
# 98 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/range.hpp" 3
  range<dimensions> operator +(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] + rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator +(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] + rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator +( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs + rhs.common_array[i]; } return result; }
  range<dimensions> operator -(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] - rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator -(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] - rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator -( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs - rhs.common_array[i]; } return result; }
  range<dimensions> operator *(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] * rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator *(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] * rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator *( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs * rhs.common_array[i]; } return result; }
  range<dimensions> operator /(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] / rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator /(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] / rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator /( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs / rhs.common_array[i]; } return result; }
  range<dimensions> operator %(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] % rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator %(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] % rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator %( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs % rhs.common_array[i]; } return result; }
  range<dimensions> operator <<(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] << rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator <<(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] << rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator <<( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs << rhs.common_array[i]; } return result; }
  range<dimensions> operator >>(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >> rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator >>(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >> rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator >>( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs >> rhs.common_array[i]; } return result; }
  range<dimensions> operator &(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] & rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator &(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] & rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator &( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs & rhs.common_array[i]; } return result; }
  range<dimensions> operator |(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] | rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator |(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] | rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator |( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs | rhs.common_array[i]; } return result; }
  range<dimensions> operator ^(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] ^ rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator ^(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] ^ rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator ^( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs ^ rhs.common_array[i]; } return result; }
  range<dimensions> operator &&(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] && rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator &&(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] && rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator &&( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs && rhs.common_array[i]; } return result; }
  range<dimensions> operator ||(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] || rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator ||(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] || rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator ||( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs || rhs.common_array[i]; } return result; }
  range<dimensions> operator <(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] < rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator <(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] < rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator <( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs < rhs.common_array[i]; } return result; }
  range<dimensions> operator >(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] > rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator >(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] > rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator >( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs > rhs.common_array[i]; } return result; }
  range<dimensions> operator <=(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] <= rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator <=(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] <= rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator <=( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs <= rhs.common_array[i]; } return result; }
  range<dimensions> operator >=(const range<dimensions> &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >= rhs.common_array[i]; } return result; } template <typename T> IntegralType<T, range<dimensions>> operator >=(const T &rhs) const { range<dimensions> result(*this); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >= rhs; } return result; } template <typename T> friend IntegralType<T, range<dimensions>> operator >=( const T &lhs, const range<dimensions> &rhs) { range<dimensions> result(rhs); for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs >= rhs.common_array[i]; } return result; }
# 132 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/range.hpp" 3
  range<dimensions> &operator +=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] += rhs[i]; } return *this; } range<dimensions> &operator +=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] += rhs; } return *this; }
  range<dimensions> &operator -=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] -= rhs[i]; } return *this; } range<dimensions> &operator -=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] -= rhs; } return *this; }
  range<dimensions> &operator *=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] *= rhs[i]; } return *this; } range<dimensions> &operator *=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] *= rhs; } return *this; }
  range<dimensions> &operator /=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] /= rhs[i]; } return *this; } range<dimensions> &operator /=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] /= rhs; } return *this; }
  range<dimensions> &operator %=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] %= rhs[i]; } return *this; } range<dimensions> &operator %=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] %= rhs; } return *this; }
  range<dimensions> &operator <<=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] <<= rhs[i]; } return *this; } range<dimensions> &operator <<=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] <<= rhs; } return *this; }
  range<dimensions> &operator >>=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] >>= rhs[i]; } return *this; } range<dimensions> &operator >>=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] >>= rhs; } return *this; }
  range<dimensions> &operator &=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] &= rhs[i]; } return *this; } range<dimensions> &operator &=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] &= rhs; } return *this; }
  range<dimensions> &operator |=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] |= rhs[i]; } return *this; } range<dimensions> &operator |=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] |= rhs; } return *this; }
  range<dimensions> &operator ^=(const range<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] ^= rhs[i]; } return *this; } range<dimensions> &operator ^=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] ^= rhs; } return *this; }


};


range(size_t)->range<1>;
range(size_t, size_t)->range<2>;
range(size_t, size_t, size_t)->range<3>;


}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 2 3

inline namespace cl {
namespace sycl {
template <int dimensions> class range;
template <int dimensions, bool with_offset> class item;




template <int dimensions = 1> class id : public detail::array<dimensions> {
private:
  using base = detail::array<dimensions>;
  static_assert(dimensions >= 1 && dimensions <= 3,
                "id can only be 1, 2, or 3 dimensional.");
  template <int N, int val, typename T>
  using ParamTy = detail::enable_if_t<(N == val), T>;






  class __private_class;

  template <typename N, typename T>
  using EnableIfIntegral = detail::enable_if_t<std::is_integral<N>::value, T>;
  template <bool B, typename T>
  using EnableIfT = detail::conditional_t<B, T, __private_class>;


public:
  id() = default;



  template <int N = dimensions> id(ParamTy<N, 1, size_t> dim0) : base(dim0) {}

  template <int N = dimensions>
  id(ParamTy<N, 1, const range<dimensions>> &range_size)
      : base(range_size.get(0)) {}

  template <int N = dimensions, bool with_offset = true>
  id(ParamTy<N, 1, const item<dimensions, with_offset>> &item)
      : base(item.get_id(0)) {}



  template <int N = dimensions>
  id(ParamTy<N, 2, size_t> dim0, size_t dim1) : base(dim0, dim1) {}

  template <int N = dimensions>
  id(ParamTy<N, 2, const range<dimensions>> &range_size)
      : base(range_size.get(0), range_size.get(1)) {}

  template <int N = dimensions, bool with_offset = true>
  id(ParamTy<N, 2, const item<dimensions, with_offset>> &item)
      : base(item.get_id(0), item.get_id(1)) {}



  template <int N = dimensions>
  id(ParamTy<N, 3, size_t> dim0, size_t dim1, size_t dim2)
      : base(dim0, dim1, dim2) {}

  template <int N = dimensions>
  id(ParamTy<N, 3, const range<dimensions>> &range_size)
      : base(range_size.get(0), range_size.get(1), range_size.get(2)) {}

  template <int N = dimensions, bool with_offset = true>
  id(ParamTy<N, 3, const item<dimensions, with_offset>> &item)
      : base(item.get_id(0), item.get_id(1), item.get_id(2)) {}

  explicit operator range<dimensions>() const {
    range<dimensions> result(
        detail::InitializedVal<dimensions, range>::template get<0>());
    for (int i = 0; i < dimensions; ++i) {
      result[i] = this->get(i);
    }
    return result;
  }







  __attribute__((always_inline)) operator EnableIfT<(dimensions == 1), size_t>() const {
    size_t Result = this->common_array[0];
                             ;
    return Result;
  }




  using detail::array<dimensions>::operator==;

  using detail::array<dimensions>::operator!=;
# 136 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 3
  template <typename T> EnableIfIntegral<T, bool> operator ==(const T &rhs) const { if (this->common_array[0] != rhs) return false == true; return true == true; } template <typename T> friend EnableIfIntegral<T, bool> operator ==(const T &lhs, const id<dimensions> &rhs) { if (lhs != rhs.common_array[0]) return false == true; return true == true; }
  template <typename T> EnableIfIntegral<T, bool> operator !=(const T &rhs) const { if (this->common_array[0] != rhs) return false != true; return true != true; } template <typename T> friend EnableIfIntegral<T, bool> operator !=(const T &lhs, const id<dimensions> &rhs) { if (lhs != rhs.common_array[0]) return false != true; return true != true; }
# 194 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 3
  id<dimensions> operator +(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] + rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator +(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] + rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator +( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs + rhs.common_array[i]; } return result; }
  id<dimensions> operator -(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] - rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator -(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] - rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator -( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs - rhs.common_array[i]; } return result; }
  id<dimensions> operator *(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] * rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator *(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] * rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator *( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs * rhs.common_array[i]; } return result; }
  id<dimensions> operator /(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] / rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator /(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] / rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator /( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs / rhs.common_array[i]; } return result; }
  id<dimensions> operator %(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] % rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator %(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] % rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator %( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs % rhs.common_array[i]; } return result; }
  id<dimensions> operator <<(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] << rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator <<(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] << rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator <<( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs << rhs.common_array[i]; } return result; }
  id<dimensions> operator >>(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >> rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator >>(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >> rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator >>( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs >> rhs.common_array[i]; } return result; }
  id<dimensions> operator &(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] & rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator &(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] & rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator &( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs & rhs.common_array[i]; } return result; }
  id<dimensions> operator |(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] | rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator |(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] | rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator |( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs | rhs.common_array[i]; } return result; }
  id<dimensions> operator ^(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] ^ rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator ^(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] ^ rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator ^( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs ^ rhs.common_array[i]; } return result; }
  id<dimensions> operator &&(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] && rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator &&(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] && rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator &&( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs && rhs.common_array[i]; } return result; }
  id<dimensions> operator ||(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] || rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator ||(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] || rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator ||( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs || rhs.common_array[i]; } return result; }
  id<dimensions> operator <(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] < rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator <(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] < rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator <( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs < rhs.common_array[i]; } return result; }
  id<dimensions> operator >(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] > rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator >(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] > rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator >( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs > rhs.common_array[i]; } return result; }
  id<dimensions> operator <=(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] <= rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator <=(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] <= rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator <=( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs <= rhs.common_array[i]; } return result; }
  id<dimensions> operator >=(const id<dimensions> &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >= rhs.common_array[i]; } return result; } template <typename T> EnableIfIntegral<T, id<dimensions>> operator >=(const T &rhs) const { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = this->common_array[i] >= rhs; } return result; } template <typename T> friend EnableIfIntegral<T, id<dimensions>> operator >=( const T &lhs, const id<dimensions> &rhs) { id<dimensions> result; for (int i = 0; i < dimensions; ++i) { result.common_array[i] = lhs >= rhs.common_array[i]; } return result; }
# 229 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/id.hpp" 3
  id<dimensions> &operator +=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] += rhs.common_array[i]; } return *this; } id<dimensions> &operator +=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] += rhs; } return *this; }
  id<dimensions> &operator -=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] -= rhs.common_array[i]; } return *this; } id<dimensions> &operator -=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] -= rhs; } return *this; }
  id<dimensions> &operator *=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] *= rhs.common_array[i]; } return *this; } id<dimensions> &operator *=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] *= rhs; } return *this; }
  id<dimensions> &operator /=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] /= rhs.common_array[i]; } return *this; } id<dimensions> &operator /=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] /= rhs; } return *this; }
  id<dimensions> &operator %=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] %= rhs.common_array[i]; } return *this; } id<dimensions> &operator %=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] %= rhs; } return *this; }
  id<dimensions> &operator <<=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] <<= rhs.common_array[i]; } return *this; } id<dimensions> &operator <<=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] <<= rhs; } return *this; }
  id<dimensions> &operator >>=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] >>= rhs.common_array[i]; } return *this; } id<dimensions> &operator >>=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] >>= rhs; } return *this; }
  id<dimensions> &operator &=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] &= rhs.common_array[i]; } return *this; } id<dimensions> &operator &=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] &= rhs; } return *this; }
  id<dimensions> &operator |=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] |= rhs.common_array[i]; } return *this; } id<dimensions> &operator |=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] |= rhs; } return *this; }
  id<dimensions> &operator ^=(const id<dimensions> &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] ^= rhs.common_array[i]; } return *this; } id<dimensions> &operator ^=(const size_t &rhs) { for (int i = 0; i < dimensions; ++i) { this->common_array[i] ^= rhs; } return *this; }


};

namespace detail {
template <int dimensions>
size_t getOffsetForId(range<dimensions> Range, id<dimensions> Id,
                      id<dimensions> Offset) {
  size_t offset = 0;
  for (int i = 0; i < dimensions; ++i)
    offset = offset * Range[i] + Offset[i] + Id[i];
  return offset;
}
}




id(size_t)->id<1>;
id(size_t, size_t)->id<2>;
id(size_t, size_t, size_t)->id<3>;


}
}
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/spirv.hpp" 2 3
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_ref.hpp" 2 3






inline namespace cl {
namespace sycl {


template <typename pointerT, access::address_space AddressSpace>
class multi_ptr;

namespace ONEAPI {
namespace detail {


using namespace ::cl::sycl::detail;

using memory_order = cl::sycl::ONEAPI::memory_order;
using memory_scope = cl::sycl::ONEAPI::memory_scope;

template <typename T>
using IsValidAtomicType =
    bool_constant<std::is_arithmetic<T>::value || std::is_pointer<T>::value>;

template <cl::sycl::access::address_space AS>
using IsValidAtomicAddressSpace =
    bool_constant<AS == access::address_space::global_space ||
                  AS == access::address_space::local_space ||
                  AS == access::address_space::global_device_space>;


template <memory_order Order>
using IsValidDefaultOrder = bool_constant<Order == memory_order::relaxed ||
                                          Order == memory_order::acq_rel ||
                                          Order == memory_order::seq_cst>;

template <memory_order ReadModifyWriteOrder> struct memory_order_traits;

template <> struct memory_order_traits<memory_order::relaxed> {
  static constexpr memory_order read_order = memory_order::relaxed;
  static constexpr memory_order write_order = memory_order::relaxed;
};

template <> struct memory_order_traits<memory_order::acq_rel> {
  static constexpr memory_order read_order = memory_order::acquire;
  static constexpr memory_order write_order = memory_order::release;
};

template <> struct memory_order_traits<memory_order::seq_cst> {
  static constexpr memory_order read_order = memory_order::seq_cst;
  static constexpr memory_order write_order = memory_order::seq_cst;
};




inline constexpr memory_order getLoadOrder(memory_order order) {
  switch (order) {
  case memory_order_relaxed:
    return memory_order_relaxed;

  case memory_order_acquire:
  case memory_order::__consume_unsupported:
  case memory_order_acq_rel:
  case memory_order_release:
    return memory_order_acquire;

  case memory_order_seq_cst:
    return memory_order_seq_cst;
  }
}
# 99 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_ref.hpp" 3
template <typename T, typename = void> struct bit_equal;

template <typename T>
struct bit_equal<T, typename detail::enable_if_t<std::is_integral<T>::value>> {
  bool operator()(const T &lhs, const T &rhs) { return lhs == rhs; }
};

template <> struct bit_equal<float> {
  bool operator()(const float &lhs, const float &rhs) {
    auto LhsInt = detail::bit_cast<uint32_t>(lhs);
    auto RhsInt = detail::bit_cast<uint32_t>(rhs);
    return LhsInt == RhsInt;
  }
};

template <> struct bit_equal<double> {
  bool operator()(const double &lhs, const double &rhs) {
    auto LhsInt = detail::bit_cast<uint64_t>(lhs);
    auto RhsInt = detail::bit_cast<uint64_t>(rhs);
    return LhsInt == RhsInt;
  }
};


template <typename T, memory_order DefaultOrder, memory_scope DefaultScope,
          access::address_space AddressSpace>
class atomic_ref_base {
  static_assert(
      detail::IsValidAtomicType<T>::value,
      "Invalid atomic type.  Valid types are arithmetic and pointer types");
  static_assert(!std::is_same<T, bool>::value,
                "ONEAPI::atomic_ref does not support bool type");
  static_assert(!(std::is_same<T, char>::value ||
                  std::is_same<T, signed char>::value ||
                  std::is_same<T, unsigned char>::value),
                "ONEAPI::atomic_ref does not support char type");
  static_assert(!(std::is_same<T, short>::value ||
                  std::is_same<T, unsigned short>::value),
                "ONEAPI::atomic_ref does not support short type");
  static_assert(detail::IsValidAtomicAddressSpace<AddressSpace>::value,
                "Invalid atomic address_space.  Valid address spaces are: "
                "global_space, local_space, global_device_space");
  static_assert(
      detail::IsValidDefaultOrder<DefaultOrder>::value,
      "Invalid default memory_order for atomics.  Valid defaults are: "
      "relaxed, acq_rel, seq_cst");

public:
  using value_type = T;
  static constexpr size_t required_alignment = sizeof(T);
  static constexpr bool is_always_lock_free =
      detail::IsValidAtomicType<T>::value;
  static constexpr memory_order default_read_order =
      detail::memory_order_traits<DefaultOrder>::read_order;
  static constexpr memory_order default_write_order =
      detail::memory_order_traits<DefaultOrder>::write_order;
  static constexpr memory_order default_read_modify_write_order = DefaultOrder;
  static constexpr memory_scope default_scope = DefaultScope;

  bool is_lock_free() const noexcept {
    return detail::IsValidAtomicType<T>::value;
  }





  explicit atomic_ref_base(T &ref)
      : ptr(reinterpret_cast<std::atomic<T> *>(&ref)) {}



  atomic_ref_base(const atomic_ref_base &ref) noexcept { ptr = ref.ptr; };
  atomic_ref_base &operator=(const atomic_ref_base &) = delete;

  void store(T operand, memory_order order = default_write_order,
             memory_scope scope = default_scope) const noexcept {



    (void)scope;
    ptr->store(operand, detail::getStdMemoryOrder(order));

  }

  T operator=(T desired) const noexcept {
    store(desired);
    return desired;
  }

  T load(memory_order order = default_read_order,
         memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->load(detail::getStdMemoryOrder(order));

  }

  operator T() const noexcept { return load(); }

  T exchange(T operand, memory_order order = default_read_modify_write_order,
             memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->exchange(operand, detail::getStdMemoryOrder(order));

  }

  bool compare_exchange_strong(T &expected, T desired, memory_order success,
                               memory_order failure,
                               memory_scope scope = default_scope) const
      noexcept {
# 224 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_ref.hpp" 3
    (void)scope;
    return ptr->compare_exchange_strong(expected, desired,
                                        detail::getStdMemoryOrder(success),
                                        detail::getStdMemoryOrder(failure));

  }

  bool
  compare_exchange_strong(T &expected, T desired,
                          memory_order order = default_read_modify_write_order,
                          memory_scope scope = default_scope) const noexcept {
    return compare_exchange_strong(expected, desired, order, order, scope);
  }

  bool compare_exchange_weak(T &expected, T desired, memory_order success,
                             memory_order failure,
                             memory_scope scope = default_scope) const
      noexcept {






    (void)scope;
    return ptr->compare_exchange_weak(expected, desired,
                                      detail::getStdMemoryOrder(success),
                                      detail::getStdMemoryOrder(failure));

  }

  bool
  compare_exchange_weak(T &expected, T desired,
                        memory_order order = default_read_modify_write_order,
                        memory_scope scope = default_scope) const noexcept {
    return compare_exchange_weak(expected, desired, order, order, scope);
  }

protected:



  std::atomic<T> *ptr;

};


template <typename T, memory_order DefaultOrder, memory_scope DefaultScope,
          access::address_space AddressSpace, typename = void>
class atomic_ref_impl
    : public atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace> {
public:
  using atomic_ref_base<T, DefaultOrder, DefaultScope,
                        AddressSpace>::atomic_ref_base;
};


template <typename T, memory_order DefaultOrder, memory_scope DefaultScope,
          access::address_space AddressSpace>
class atomic_ref_impl<T, DefaultOrder, DefaultScope, AddressSpace,
                      typename detail::enable_if_t<std::is_integral<T>::value>>
    : public atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace> {

public:
  using value_type = T;
  using difference_type = value_type;
  static constexpr size_t required_alignment = sizeof(T);
  static constexpr bool is_always_lock_free =
      detail::IsValidAtomicType<T>::value;
  static constexpr memory_order default_read_order =
      detail::memory_order_traits<DefaultOrder>::read_order;
  static constexpr memory_order default_write_order =
      detail::memory_order_traits<DefaultOrder>::write_order;
  static constexpr memory_order default_read_modify_write_order = DefaultOrder;
  static constexpr memory_scope default_scope = DefaultScope;

  using atomic_ref_base<T, DefaultOrder, DefaultScope,
                        AddressSpace>::atomic_ref_base;
  using atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace>::load;
  using atomic_ref_base<T, DefaultOrder, DefaultScope,
                        AddressSpace>::compare_exchange_weak;

  T fetch_add(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->fetch_add(operand, detail::getStdMemoryOrder(order));

  }

  T operator+=(T operand) const noexcept {
    return fetch_add(operand) + operand;
  }

  T operator++(int) const noexcept {

    return fetch_add(1);
  }

  T operator++() const noexcept {

    return fetch_add(1) + 1;
  }

  T fetch_sub(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->fetch_sub(operand, detail::getStdMemoryOrder(order));

  }

  T operator-=(T operand) const noexcept {
    return fetch_sub(operand) - operand;
  }

  T operator--(int) const noexcept {

    return fetch_sub(1);
  }

  T operator--() const noexcept {

    return fetch_sub(1) - 1;
  }

  T fetch_and(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->fetch_and(operand, detail::getStdMemoryOrder(order));

  }

  T operator&=(T operand) const noexcept {
    return fetch_and(operand) & operand;
  }

  T fetch_or(T operand, memory_order order = default_read_modify_write_order,
             memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->fetch_or(operand, detail::getStdMemoryOrder(order));

  }

  T operator|=(T operand) const noexcept { return fetch_or(operand) | operand; }

  T fetch_xor(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {



    (void)scope;
    return ptr->fetch_xor(operand, detail::getStdMemoryOrder(order));

  }

  T operator^=(T operand) const noexcept {
    return fetch_xor(operand) ^ operand;
  }

  T fetch_min(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {



    auto load_order = detail::getLoadOrder(order);
    T old = load(load_order, scope);
    while (operand < old &&
           !compare_exchange_weak(old, operand, order, scope)) {
    }
    return old;

  }

  T fetch_max(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {



    auto load_order = detail::getLoadOrder(order);
    T old = load(load_order, scope);
    while (operand > old &&
           !compare_exchange_weak(old, operand, order, scope)) {
    }
    return old;

  }

private:
  using atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace>::ptr;
};



template <typename T, memory_order DefaultOrder, memory_scope DefaultScope,
          access::address_space AddressSpace>
class atomic_ref_impl<
    T, DefaultOrder, DefaultScope, AddressSpace,
    typename detail::enable_if_t<std::is_floating_point<T>::value>>
    : public atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace> {

public:
  using value_type = T;
  using difference_type = value_type;
  static constexpr size_t required_alignment = sizeof(T);
  static constexpr bool is_always_lock_free =
      detail::IsValidAtomicType<T>::value;
  static constexpr memory_order default_read_order =
      detail::memory_order_traits<DefaultOrder>::read_order;
  static constexpr memory_order default_write_order =
      detail::memory_order_traits<DefaultOrder>::write_order;
  static constexpr memory_order default_read_modify_write_order = DefaultOrder;
  static constexpr memory_scope default_scope = DefaultScope;

  using atomic_ref_base<T, DefaultOrder, DefaultScope,
                        AddressSpace>::atomic_ref_base;
  using atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace>::load;
  using atomic_ref_base<T, DefaultOrder, DefaultScope,
                        AddressSpace>::compare_exchange_weak;

  T fetch_add(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {
    auto load_order = detail::getLoadOrder(order);
    T expected = load(load_order, scope);
    T desired;
    do {
      desired = expected + operand;
    } while (!compare_exchange_weak(expected, desired, order, scope));
    return expected;
  }

  T operator+=(T operand) const noexcept {
    return fetch_add(operand) + operand;
  }

  T fetch_sub(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {
    auto load_order = detail::getLoadOrder(order);
    T expected = load(load_order, scope);
    T desired;
    do {
      desired = expected - operand;
    } while (!compare_exchange_weak(expected, desired, order, scope));
    return expected;
  }

  T operator-=(T operand) const noexcept {
    return fetch_sub(operand) - operand;
  }

  T fetch_min(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {
    auto load_order = detail::getLoadOrder(order);
    T old = load(load_order, scope);
    while (operand < old &&
           !compare_exchange_weak(old, operand, order, scope)) {
    }
    return old;
  }

  T fetch_max(T operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {
    auto load_order = detail::getLoadOrder(order);
    T old = load(load_order, scope);
    while (operand > old &&
           !compare_exchange_weak(old, operand, order, scope)) {
    }
    return old;
  }

private:
  using atomic_ref_base<T, DefaultOrder, DefaultScope, AddressSpace>::ptr;
};




template <typename T, memory_order DefaultOrder, memory_scope DefaultScope,
          access::address_space AddressSpace>
class atomic_ref_impl<T *, DefaultOrder, DefaultScope, AddressSpace>
    : public atomic_ref_base<uintptr_t, DefaultOrder, DefaultScope,
                             AddressSpace> {

private:
  using base_type =
      atomic_ref_base<uintptr_t, DefaultOrder, DefaultScope, AddressSpace>;

public:
  using value_type = T *;
  using difference_type = ptrdiff_t;
  static constexpr size_t required_alignment = sizeof(T *);
  static constexpr bool is_always_lock_free =
      detail::IsValidAtomicType<T>::value;
  static constexpr memory_order default_read_order =
      detail::memory_order_traits<DefaultOrder>::read_order;
  static constexpr memory_order default_write_order =
      detail::memory_order_traits<DefaultOrder>::write_order;
  static constexpr memory_order default_read_modify_write_order = DefaultOrder;
  static constexpr memory_scope default_scope = DefaultScope;

  using base_type::is_lock_free;

  atomic_ref_impl(T *&ref) : base_type(reinterpret_cast<uintptr_t &>(ref)) {}

  void store(T *operand, memory_order order = default_write_order,
             memory_scope scope = default_scope) const noexcept {
    base_type::store(reinterpret_cast<uintptr_t>(operand), order, scope);
  }

  T *operator=(T *desired) const noexcept {
    store(desired);
    return desired;
  }

  T *load(memory_order order = default_read_order,
          memory_scope scope = default_scope) const noexcept {
    return reinterpret_cast<T *>(base_type::load(order, scope));
  }

  operator T *() const noexcept { return load(); }

  T *exchange(T *operand, memory_order order = default_read_modify_write_order,
              memory_scope scope = default_scope) const noexcept {
    return reinterpret_cast<T *>(base_type::exchange(
        reinterpret_cast<uintptr_t>(operand), order, scope));
  }

  T *fetch_add(difference_type operand,
               memory_order order = default_read_modify_write_order,
               memory_scope scope = default_scope) const noexcept {

    auto load_order = detail::getLoadOrder(order);
    T *expected = load(load_order, scope);
    T *desired;
    do {
      desired = expected + operand;
    } while (!compare_exchange_weak(expected, desired, order, scope));
    return expected;
  }

  T *operator+=(difference_type operand) const noexcept {
    return fetch_add(operand) + operand;
  }

  T *operator++(int) const noexcept { return fetch_add(difference_type(1)); }

  T *operator++() const noexcept {
    return fetch_add(difference_type(1)) + difference_type(1);
  }

  T *fetch_sub(difference_type operand,
               memory_order order = default_read_modify_write_order,
               memory_scope scope = default_scope) const noexcept {

    auto load_order = detail::getLoadOrder(order);
    T *expected = load(load_order, scope);
    T *desired;
    do {
      desired = expected - operand;
    } while (!compare_exchange_weak(expected, desired, order, scope));
    return expected;
  }

  T *operator-=(difference_type operand) const noexcept {
    return fetch_sub(operand) - operand;
  }

  T *operator--(int) const noexcept { return fetch_sub(difference_type(1)); }

  T *operator--() const noexcept {
    return fetch_sub(difference_type(1)) - difference_type(1);
  }

  bool
  compare_exchange_strong(T *&expected, T *desired, memory_order success,
                          memory_order failure,
                          memory_scope scope = default_scope) const noexcept {
    return base_type::compare_exchange_strong(
        reinterpret_cast<uintptr_t &>(expected),
        reinterpret_cast<uintptr_t>(desired), success, failure, scope);
  }

  bool
  compare_exchange_strong(T *&expected, T *desired,
                          memory_order order = default_read_modify_write_order,
                          memory_scope scope = default_scope) const noexcept {
    return compare_exchange_strong(expected, desired, order, order, scope);
  }

  bool
  compare_exchange_weak(T *&expected, T *desired, memory_order success,
                        memory_order failure,
                        memory_scope scope = default_scope) const noexcept {
    return base_type::compare_exchange_weak(
        reinterpret_cast<uintptr_t &>(expected),
        reinterpret_cast<uintptr_t>(desired), success, failure, scope);
  }

  bool
  compare_exchange_weak(T *&expected, T *desired,
                        memory_order order = default_read_modify_write_order,
                        memory_scope scope = default_scope) const noexcept {
    return compare_exchange_weak(expected, desired, order, order, scope);
  }

private:
  using base_type::ptr;
};

}

template <typename T, memory_order DefaultOrder, memory_scope DefaultScope,
          access::address_space AddressSpace>
class atomic_ref : public detail::atomic_ref_impl<T, DefaultOrder, DefaultScope,
                                                  AddressSpace> {
public:
  using detail::atomic_ref_impl<T, DefaultOrder, DefaultScope,
                                AddressSpace>::atomic_ref_impl;
};

}
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_accessor.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/accessor_property_list.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/accessor_property_list.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_list_base.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_list_base.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_helper.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_helper.hpp" 3
inline namespace cl {
namespace sycl {

namespace detail {
# 26 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_helper.hpp" 3
enum DataLessPropKind {
  BufferUseHostPtr = 0,
  ImageUseHostPtr,
  QueueEnableProfiling,
  InOrder,
  NoInit,
  BufferUsePinnedHostMemory,
  UsePrimaryContext,
  DataLessPropKindSize
};


enum PropWithDataKind {
  BufferUseMutex = 0,
  BufferContextBound,
  ImageUseMutex,
  ImageContextBound,
  BufferMemChannel,
  PropWithDataKindSize
};



class DataLessPropertyBase {};




template <int ID> class DataLessProperty : DataLessPropertyBase {
public:
  static constexpr int getKind() { return ID; }
};




class PropertyWithDataBase {
public:
  PropertyWithDataBase(int ID) : MID(ID) {}
  bool isSame(int ID) const { return ID == MID; }
  virtual ~PropertyWithDataBase() = default;

private:
  int MID = -1;
};




template <int ID> class PropertyWithData : public PropertyWithDataBase {
public:
  PropertyWithData() : PropertyWithDataBase(ID) {}
  static int getKind() { return ID; }
};

}

}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_list_base.hpp" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 1 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
# 60 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 70 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
  template<size_t _Nw>
    struct _Base_bitset
    {
      typedef unsigned long _WordT;


      _WordT _M_w[_Nw];

      constexpr _Base_bitset() noexcept
      : _M_w() { }


      constexpr _Base_bitset(unsigned long long __val) noexcept
      : _M_w{ _WordT(__val)



       } { }






      static constexpr size_t
      _S_whichword(size_t __pos) noexcept
      { return __pos / (8 * 8); }

      static constexpr size_t
      _S_whichbyte(size_t __pos) noexcept
      { return (__pos % (8 * 8)) / 8; }

      static constexpr size_t
      _S_whichbit(size_t __pos) noexcept
      { return __pos % (8 * 8); }

      static constexpr _WordT
      _S_maskbit(size_t __pos) noexcept
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }

      _WordT&
      _M_getword(size_t __pos) noexcept
      { return _M_w[_S_whichword(__pos)]; }

      constexpr _WordT
      _M_getword(size_t __pos) const noexcept
      { return _M_w[_S_whichword(__pos)]; }


      const _WordT*
      _M_getdata() const noexcept
      { return _M_w; }


      _WordT&
      _M_hiword() noexcept
      { return _M_w[_Nw - 1]; }

      constexpr _WordT
      _M_hiword() const noexcept
      { return _M_w[_Nw - 1]; }

      void
      _M_do_and(const _Base_bitset<_Nw>& __x) noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] &= __x._M_w[__i];
      }

      void
      _M_do_or(const _Base_bitset<_Nw>& __x) noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] |= __x._M_w[__i];
      }

      void
      _M_do_xor(const _Base_bitset<_Nw>& __x) noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] ^= __x._M_w[__i];
      }

      void
      _M_do_left_shift(size_t __shift) noexcept;

      void
      _M_do_right_shift(size_t __shift) noexcept;

      void
      _M_do_flip() noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] = ~_M_w[__i];
      }

      void
      _M_do_set() noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] = ~static_cast<_WordT>(0);
      }

      void
      _M_do_reset() noexcept
      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }

      bool
      _M_is_equal(const _Base_bitset<_Nw>& __x) const noexcept
      {
 for (size_t __i = 0; __i < _Nw; ++__i)
   if (_M_w[__i] != __x._M_w[__i])
     return false;
 return true;
      }

      template<size_t _Nb>
        bool
        _M_are_all() const noexcept
        {
   for (size_t __i = 0; __i < _Nw - 1; __i++)
     if (_M_w[__i] != ~static_cast<_WordT>(0))
       return false;
   return _M_hiword() == (~static_cast<_WordT>(0)
     >> (_Nw * (8 * 8)
         - _Nb));
 }

      bool
      _M_is_any() const noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   if (_M_w[__i] != static_cast<_WordT>(0))
     return true;
 return false;
      }

      size_t
      _M_do_count() const noexcept
      {
 size_t __result = 0;
 for (size_t __i = 0; __i < _Nw; __i++)
   __result += __builtin_popcountl(_M_w[__i]);
 return __result;
      }

      unsigned long
      _M_do_to_ulong() const;


      unsigned long long
      _M_do_to_ullong() const;



      size_t
      _M_do_find_first(size_t) const noexcept;


      size_t
      _M_do_find_next(size_t, size_t) const noexcept;
    };


  template<size_t _Nw>
    void
    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept
    {
      if (__builtin_expect(__shift != 0, 1))
 {
   const size_t __wshift = __shift / (8 * 8);
   const size_t __offset = __shift % (8 * 8);

   if (__offset == 0)
     for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
       _M_w[__n] = _M_w[__n - __wshift];
   else
     {
       const size_t __sub_offset = ((8 * 8)
        - __offset);
       for (size_t __n = _Nw - 1; __n > __wshift; --__n)
  _M_w[__n] = ((_M_w[__n - __wshift] << __offset)
        | (_M_w[__n - __wshift - 1] >> __sub_offset));
       _M_w[__wshift] = _M_w[0] << __offset;
     }

   std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
 }
    }

  template<size_t _Nw>
    void
    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) noexcept
    {
      if (__builtin_expect(__shift != 0, 1))
 {
   const size_t __wshift = __shift / (8 * 8);
   const size_t __offset = __shift % (8 * 8);
   const size_t __limit = _Nw - __wshift - 1;

   if (__offset == 0)
     for (size_t __n = 0; __n <= __limit; ++__n)
       _M_w[__n] = _M_w[__n + __wshift];
   else
     {
       const size_t __sub_offset = ((8 * 8)
        - __offset);
       for (size_t __n = 0; __n < __limit; ++__n)
  _M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
        | (_M_w[__n + __wshift + 1] << __sub_offset));
       _M_w[__limit] = _M_w[_Nw-1] >> __offset;
     }

   std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
 }
    }

  template<size_t _Nw>
    unsigned long
    _Base_bitset<_Nw>::_M_do_to_ulong() const
    {
      for (size_t __i = 1; __i < _Nw; ++__i)
 if (_M_w[__i])
   __throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));
      return _M_w[0];
    }


  template<size_t _Nw>
    unsigned long long
    _Base_bitset<_Nw>::_M_do_to_ullong() const
    {
      const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
      for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
 if (_M_w[__i])
   __throw_overflow_error(("_Base_bitset::_M_do_to_ullong"));

      if (__dw)
 return _M_w[0] + (static_cast<unsigned long long>(_M_w[1])
     << (8 * 8));
      return _M_w[0];
    }


  template<size_t _Nw>
    size_t
    _Base_bitset<_Nw>::
    _M_do_find_first(size_t __not_found) const noexcept
    {
      for (size_t __i = 0; __i < _Nw; __i++)
 {
   _WordT __thisword = _M_w[__i];
   if (__thisword != static_cast<_WordT>(0))
     return (__i * (8 * 8)
      + __builtin_ctzl(__thisword));
 }

      return __not_found;
    }

  template<size_t _Nw>
    size_t
    _Base_bitset<_Nw>::
    _M_do_find_next(size_t __prev, size_t __not_found) const noexcept
    {

      ++__prev;


      if (__prev >= _Nw * (8 * 8))
 return __not_found;


      size_t __i = _S_whichword(__prev);
      _WordT __thisword = _M_w[__i];


      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);

      if (__thisword != static_cast<_WordT>(0))
 return (__i * (8 * 8)
  + __builtin_ctzl(__thisword));


      __i++;
      for (; __i < _Nw; __i++)
 {
   __thisword = _M_w[__i];
   if (__thisword != static_cast<_WordT>(0))
     return (__i * (8 * 8)
      + __builtin_ctzl(__thisword));
 }

      return __not_found;
    }






  template<>
    struct _Base_bitset<1>
    {
      typedef unsigned long _WordT;
      _WordT _M_w;

      constexpr _Base_bitset() noexcept
      : _M_w(0)
      { }


      constexpr _Base_bitset(unsigned long long __val) noexcept



      : _M_w(__val)
      { }

      static constexpr size_t
      _S_whichword(size_t __pos) noexcept
      { return __pos / (8 * 8); }

      static constexpr size_t
      _S_whichbyte(size_t __pos) noexcept
      { return (__pos % (8 * 8)) / 8; }

      static constexpr size_t
      _S_whichbit(size_t __pos) noexcept
      { return __pos % (8 * 8); }

      static constexpr _WordT
      _S_maskbit(size_t __pos) noexcept
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }

      _WordT&
      _M_getword(size_t) noexcept
      { return _M_w; }

      constexpr _WordT
      _M_getword(size_t) const noexcept
      { return _M_w; }


      const _WordT*
      _M_getdata() const noexcept
      { return &_M_w; }


      _WordT&
      _M_hiword() noexcept
      { return _M_w; }

      constexpr _WordT
      _M_hiword() const noexcept
      { return _M_w; }

      void
      _M_do_and(const _Base_bitset<1>& __x) noexcept
      { _M_w &= __x._M_w; }

      void
      _M_do_or(const _Base_bitset<1>& __x) noexcept
      { _M_w |= __x._M_w; }

      void
      _M_do_xor(const _Base_bitset<1>& __x) noexcept
      { _M_w ^= __x._M_w; }

      void
      _M_do_left_shift(size_t __shift) noexcept
      { _M_w <<= __shift; }

      void
      _M_do_right_shift(size_t __shift) noexcept
      { _M_w >>= __shift; }

      void
      _M_do_flip() noexcept
      { _M_w = ~_M_w; }

      void
      _M_do_set() noexcept
      { _M_w = ~static_cast<_WordT>(0); }

      void
      _M_do_reset() noexcept
      { _M_w = 0; }

      bool
      _M_is_equal(const _Base_bitset<1>& __x) const noexcept
      { return _M_w == __x._M_w; }

      template<size_t _Nb>
        bool
        _M_are_all() const noexcept
        { return _M_w == (~static_cast<_WordT>(0)
     >> ((8 * 8) - _Nb)); }

      bool
      _M_is_any() const noexcept
      { return _M_w != 0; }

      size_t
      _M_do_count() const noexcept
      { return __builtin_popcountl(_M_w); }

      unsigned long
      _M_do_to_ulong() const noexcept
      { return _M_w; }


      unsigned long long
      _M_do_to_ullong() const noexcept
      { return _M_w; }


      size_t
      _M_do_find_first(size_t __not_found) const noexcept
      {
        if (_M_w != 0)
          return __builtin_ctzl(_M_w);
        else
          return __not_found;
      }


      size_t
      _M_do_find_next(size_t __prev, size_t __not_found) const
 noexcept
      {
 ++__prev;
 if (__prev >= ((size_t) (8 * 8)))
   return __not_found;

 _WordT __x = _M_w >> __prev;
 if (__x != 0)
   return __builtin_ctzl(__x) + __prev;
 else
   return __not_found;
      }
    };






  template<>
    struct _Base_bitset<0>
    {
      typedef unsigned long _WordT;

      constexpr _Base_bitset() noexcept
      { }


      constexpr _Base_bitset(unsigned long long) noexcept



      { }

      static constexpr size_t
      _S_whichword(size_t __pos) noexcept
      { return __pos / (8 * 8); }

      static constexpr size_t
      _S_whichbyte(size_t __pos) noexcept
      { return (__pos % (8 * 8)) / 8; }

      static constexpr size_t
      _S_whichbit(size_t __pos) noexcept
      { return __pos % (8 * 8); }

      static constexpr _WordT
      _S_maskbit(size_t __pos) noexcept
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
# 556 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      _WordT&
      _M_getword(size_t) noexcept
      {
 __throw_out_of_range(("_Base_bitset::_M_getword"));
 return *new _WordT;
      }

      constexpr _WordT
      _M_getword(size_t __pos) const noexcept
      { return 0; }

      constexpr _WordT
      _M_hiword() const noexcept
      { return 0; }

      void
      _M_do_and(const _Base_bitset<0>&) noexcept
      { }

      void
      _M_do_or(const _Base_bitset<0>&) noexcept
      { }

      void
      _M_do_xor(const _Base_bitset<0>&) noexcept
      { }

      void
      _M_do_left_shift(size_t) noexcept
      { }

      void
      _M_do_right_shift(size_t) noexcept
      { }

      void
      _M_do_flip() noexcept
      { }

      void
      _M_do_set() noexcept
      { }

      void
      _M_do_reset() noexcept
      { }




      bool
      _M_is_equal(const _Base_bitset<0>&) const noexcept
      { return true; }

      template<size_t _Nb>
        bool
        _M_are_all() const noexcept
        { return true; }

      bool
      _M_is_any() const noexcept
      { return false; }

      size_t
      _M_do_count() const noexcept
      { return 0; }

      unsigned long
      _M_do_to_ulong() const noexcept
      { return 0; }


      unsigned long long
      _M_do_to_ullong() const noexcept
      { return 0; }




      size_t
      _M_do_find_first(size_t) const noexcept
      { return 0; }

      size_t
      _M_do_find_next(size_t, size_t) const noexcept
      { return 0; }
    };



  template<size_t _Extrabits>
    struct _Sanitize
    {
      typedef unsigned long _WordT;

      static void
      _S_do_sanitize(_WordT& __val) noexcept
      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
    };

  template<>
    struct _Sanitize<0>
    {
      typedef unsigned long _WordT;

      static void
      _S_do_sanitize(_WordT) noexcept { }
    };


  template<size_t _Nb, bool = (_Nb < (8 * 8))>
    struct _Sanitize_val
    {
      static constexpr unsigned long long
      _S_do_sanitize_val(unsigned long long __val)
      { return __val; }
    };

  template<size_t _Nb>
    struct _Sanitize_val<_Nb, true>
    {
      static constexpr unsigned long long
      _S_do_sanitize_val(unsigned long long __val)
      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
    };
# 746 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
  template<size_t _Nb>
    class bitset
    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
    {
    private:
      typedef _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))> _Base;
      typedef unsigned long _WordT;

      template<class _CharT, class _Traits, class _Alloc>
      void
      _M_check_initial_position(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
    size_t __position) const
      {
 if (__position > __s.size())
   __throw_out_of_range_fmt(("bitset::bitset: __position " "(which is %zu) > __s.size() " "(which is %zu)"),


       __position, __s.size());
      }

      void _M_check(size_t __position, const char *__s) const
      {
 if (__position >= _Nb)
   __throw_out_of_range_fmt(("%s: __position (which is %zu) " ">= _Nb (which is %zu)"),

       __s, __position, _Nb);
      }

      void
      _M_do_sanitize() noexcept
      {
 typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;
 __sanitize_type::_S_do_sanitize(this->_M_hiword());
      }


      template<typename> friend struct hash;


    public:
# 798 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      class reference
      {
 friend class bitset;

 _WordT* _M_wp;
 size_t _M_bpos;


 reference();

      public:
 reference(bitset& __b, size_t __pos) noexcept
 {
   _M_wp = &__b._M_getword(__pos);
   _M_bpos = _Base::_S_whichbit(__pos);
 }

 ~reference() noexcept
 { }


 reference&
 operator=(bool __x) noexcept
 {
   if (__x)
     *_M_wp |= _Base::_S_maskbit(_M_bpos);
   else
     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
   return *this;
 }


 reference&
 operator=(const reference& __j) noexcept
 {
   if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
     *_M_wp |= _Base::_S_maskbit(_M_bpos);
   else
     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
   return *this;
 }


 bool
 operator~() const noexcept
 { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }


 operator bool() const noexcept
 { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }


 reference&
 flip() noexcept
 {
   *_M_wp ^= _Base::_S_maskbit(_M_bpos);
   return *this;
 }
      };
      friend class reference;



      constexpr bitset() noexcept
      { }



      constexpr bitset(unsigned long long __val) noexcept
      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
# 883 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 explicit
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position = 0)
 : _Base()
 {
   _M_check_initial_position(__s, __position);
   _M_copy_from_string(__s, __position,
         std::basic_string<_CharT, _Traits, _Alloc>::npos,
         _CharT('0'), _CharT('1'));
 }
# 905 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position, size_t __n)
 : _Base()
 {
   _M_check_initial_position(__s, __position);
   _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
 }



      template<class _CharT, class _Traits, class _Alloc>
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position, size_t __n,
        _CharT __zero, _CharT __one = _CharT('1'))
 : _Base()
 {
   _M_check_initial_position(__s, __position);
   _M_copy_from_string(__s, __position, __n, __zero, __one);
 }
# 936 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      template<typename _CharT>
        explicit
        bitset(const _CharT* __str,
        typename std::basic_string<_CharT>::size_type __n
        = std::basic_string<_CharT>::npos,
        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
        : _Base()
        {
   if (!__str)
     __throw_logic_error(("bitset::bitset(const _CharT*, ...)"));

   if (__n == std::basic_string<_CharT>::npos)
     __n = std::char_traits<_CharT>::length(__str);
   _M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0,
            __n, __zero,
            __one);
 }
# 963 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      bitset<_Nb>&
      operator&=(const bitset<_Nb>& __rhs) noexcept
      {
 this->_M_do_and(__rhs);
 return *this;
      }

      bitset<_Nb>&
      operator|=(const bitset<_Nb>& __rhs) noexcept
      {
 this->_M_do_or(__rhs);
 return *this;
      }

      bitset<_Nb>&
      operator^=(const bitset<_Nb>& __rhs) noexcept
      {
 this->_M_do_xor(__rhs);
 return *this;
      }
# 992 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      bitset<_Nb>&
      operator<<=(size_t __position) noexcept
      {
 if (__builtin_expect(__position < _Nb, 1))
   {
     this->_M_do_left_shift(__position);
     this->_M_do_sanitize();
   }
 else
   this->_M_do_reset();
 return *this;
      }

      bitset<_Nb>&
      operator>>=(size_t __position) noexcept
      {
 if (__builtin_expect(__position < _Nb, 1))
   {
     this->_M_do_right_shift(__position);
     this->_M_do_sanitize();
   }
 else
   this->_M_do_reset();
 return *this;
      }
# 1025 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      bitset<_Nb>&
      _Unchecked_set(size_t __pos) noexcept
      {
 this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_set(size_t __pos, int __val) noexcept
      {
 if (__val)
   this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 else
   this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_reset(size_t __pos) noexcept
      {
 this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_flip(size_t __pos) noexcept
      {
 this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
 return *this;
      }

      constexpr bool
      _Unchecked_test(size_t __pos) const noexcept
      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
  != static_cast<_WordT>(0)); }






      bitset<_Nb>&
      set() noexcept
      {
 this->_M_do_set();
 this->_M_do_sanitize();
 return *this;
      }







      bitset<_Nb>&
      set(size_t __position, bool __val = true)
      {
 this->_M_check(__position, ("bitset::set"));
 return _Unchecked_set(__position, __val);
      }




      bitset<_Nb>&
      reset() noexcept
      {
 this->_M_do_reset();
 return *this;
      }
# 1104 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      bitset<_Nb>&
      reset(size_t __position)
      {
 this->_M_check(__position, ("bitset::reset"));
 return _Unchecked_reset(__position);
      }




      bitset<_Nb>&
      flip() noexcept
      {
 this->_M_do_flip();
 this->_M_do_sanitize();
 return *this;
      }






      bitset<_Nb>&
      flip(size_t __position)
      {
 this->_M_check(__position, ("bitset::flip"));
 return _Unchecked_flip(__position);
      }


      bitset<_Nb>
      operator~() const noexcept
      { return bitset<_Nb>(*this).flip(); }
# 1154 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      reference
      operator[](size_t __position)
      { return reference(*this, __position); }

      constexpr bool
      operator[](size_t __position) const
      { return _Unchecked_test(__position); }
# 1169 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      unsigned long
      to_ulong() const
      { return this->_M_do_to_ulong(); }


      unsigned long long
      to_ullong() const
      { return this->_M_do_to_ullong(); }
# 1187 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 std::basic_string<_CharT, _Traits, _Alloc>
 to_string() const
 {
   std::basic_string<_CharT, _Traits, _Alloc> __result;
   _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
   return __result;
 }



      template<class _CharT, class _Traits, class _Alloc>
 std::basic_string<_CharT, _Traits, _Alloc>
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 {
   std::basic_string<_CharT, _Traits, _Alloc> __result;
   _M_copy_to_string(__result, __zero, __one);
   return __result;
 }



      template<class _CharT, class _Traits>
 std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
 to_string() const
 { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }



      template<class _CharT, class _Traits>
 std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 { return to_string<_CharT, _Traits,
                    std::allocator<_CharT> >(__zero, __one); }

      template<class _CharT>
 std::basic_string<_CharT, std::char_traits<_CharT>,
                   std::allocator<_CharT> >
 to_string() const
 {
   return to_string<_CharT, std::char_traits<_CharT>,
                    std::allocator<_CharT> >();
 }

      template<class _CharT>
 std::basic_string<_CharT, std::char_traits<_CharT>,
                   std::allocator<_CharT> >
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 {
   return to_string<_CharT, std::char_traits<_CharT>,
                    std::allocator<_CharT> >(__zero, __one);
 }

      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
      to_string() const
      {
 return to_string<char, std::char_traits<char>,
                  std::allocator<char> >();
      }

      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
      to_string(char __zero, char __one = '1') const
      {
 return to_string<char, std::char_traits<char>,
                  std::allocator<char> >(__zero, __one);
      }


      template<class _CharT, class _Traits>
        void
        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
    _CharT, _CharT);

      template<class _CharT, class _Traits, class _Alloc>
 void
 _M_copy_from_string(const std::basic_string<_CharT,
       _Traits, _Alloc>& __s, size_t __pos, size_t __n,
       _CharT __zero, _CharT __one)
 { _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
         __zero, __one); }

      template<class _CharT, class _Traits, class _Alloc>
 void
        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
     _CharT, _CharT) const;


      template<class _CharT, class _Traits, class _Alloc>
 void
 _M_copy_from_string(const std::basic_string<_CharT,
       _Traits, _Alloc>& __s, size_t __pos, size_t __n)
 { _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }

      template<class _CharT, class _Traits, class _Alloc>
 void
        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
 { _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }


      size_t
      count() const noexcept
      { return this->_M_do_count(); }


      constexpr size_t
      size() const noexcept
      { return _Nb; }



      bool
      operator==(const bitset<_Nb>& __rhs) const noexcept
      { return this->_M_is_equal(__rhs); }

      bool
      operator!=(const bitset<_Nb>& __rhs) const noexcept
      { return !this->_M_is_equal(__rhs); }
# 1312 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      bool
      test(size_t __position) const
      {
 this->_M_check(__position, ("bitset::test"));
 return _Unchecked_test(__position);
      }







      bool
      all() const noexcept
      { return this->template _M_are_all<_Nb>(); }





      bool
      any() const noexcept
      { return this->_M_is_any(); }





      bool
      none() const noexcept
      { return !this->_M_is_any(); }



      bitset<_Nb>
      operator<<(size_t __position) const noexcept
      { return bitset<_Nb>(*this) <<= __position; }

      bitset<_Nb>
      operator>>(size_t __position) const noexcept
      { return bitset<_Nb>(*this) >>= __position; }
# 1362 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      size_t
      _Find_first() const noexcept
      { return this->_M_do_find_first(_Nb); }
# 1373 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
      size_t
      _Find_next(size_t __prev) const noexcept
      { return this->_M_do_find_next(__prev, _Nb); }
    };


  template<size_t _Nb>
    template<class _CharT, class _Traits>
      void
      bitset<_Nb>::
      _M_copy_from_ptr(const _CharT* __s, size_t __len,
         size_t __pos, size_t __n, _CharT __zero, _CharT __one)
      {
 reset();
 const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
 for (size_t __i = __nbits; __i > 0; --__i)
   {
     const _CharT __c = __s[__pos + __nbits - __i];
     if (_Traits::eq(__c, __zero))
       ;
     else if (_Traits::eq(__c, __one))
       _Unchecked_set(__i - 1);
     else
       __throw_invalid_argument(("bitset::_M_copy_from_ptr"));
   }
      }

  template<size_t _Nb>
    template<class _CharT, class _Traits, class _Alloc>
      void
      bitset<_Nb>::
      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,
   _CharT __zero, _CharT __one) const
      {
 __s.assign(_Nb, __zero);
 for (size_t __i = _Nb; __i > 0; --__i)
   if (_Unchecked_test(__i - 1))
     _Traits::assign(__s[_Nb - __i], __one);
      }
# 1423 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
  template<size_t _Nb>
    inline bitset<_Nb>
    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
    {
      bitset<_Nb> __result(__x);
      __result &= __y;
      return __result;
    }

  template<size_t _Nb>
    inline bitset<_Nb>
    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
    {
      bitset<_Nb> __result(__x);
      __result |= __y;
      return __result;
    }

  template <size_t _Nb>
    inline bitset<_Nb>
    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
    {
      bitset<_Nb> __result(__x);
      __result ^= __y;
      return __result;
    }
# 1460 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
  template<class _CharT, class _Traits, size_t _Nb>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
    {
      typedef typename _Traits::char_type char_type;
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      std::basic_string<_CharT, _Traits> __tmp;
      __tmp.reserve(_Nb);



      const char_type __zero = __is.widen('0');
      const char_type __one = __is.widen('1');

      typename __ios_base::iostate __state = __ios_base::goodbit;
      typename __istream_type::sentry __sentry(__is);
      if (__sentry)
 {
   try
     {
       for (size_t __i = _Nb; __i > 0; --__i)
  {
    static typename _Traits::int_type __eof = _Traits::eof();

    typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
    if (_Traits::eq_int_type(__c1, __eof))
      {
        __state |= __ios_base::eofbit;
        break;
      }
    else
      {
        const char_type __c2 = _Traits::to_char_type(__c1);
        if (_Traits::eq(__c2, __zero))
   __tmp.push_back(__zero);
        else if (_Traits::eq(__c2, __one))
   __tmp.push_back(__one);
        else if (_Traits::
          eq_int_type(__is.rdbuf()->sputbackc(__c2),
        __eof))
   {
     __state |= __ios_base::failbit;
     break;
   }
      }
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(__ios_base::badbit); }
 }

      if (__tmp.empty() && _Nb)
 __state |= __ios_base::failbit;
      else
 __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb,
    __zero, __one);
      if (__state)
 __is.setstate(__state);
      return __is;
    }

  template <class _CharT, class _Traits, size_t _Nb>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bitset<_Nb>& __x)
    {
      std::basic_string<_CharT, _Traits> __tmp;



      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__os.getloc());
      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
      return __os << __tmp;
    }



}
# 1554 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/bitset" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<size_t _Nb>
    struct hash<std::bitset<_Nb>>
    : public __hash_base<size_t, std::bitset<_Nb>>
    {
      size_t
      operator()(const std::bitset<_Nb>& __b) const noexcept
      {
 const size_t __clength = (_Nb + 8 - 1) / 8;
 return std::_Hash_impl::hash(__b._M_getdata(), __clength);
      }
    };

  template<>
    struct hash<std::bitset<0>>
    : public __hash_base<size_t, std::bitset<0>>
    {
      size_t
      operator()(const std::bitset<0>&) const noexcept
      { return 0; }
    };


}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/property_list_base.hpp" 2 3




inline namespace cl {
namespace sycl {
namespace detail {
class PropertyListBase {
protected:
  explicit PropertyListBase(
      std::bitset<DataLessPropKind::DataLessPropKindSize> DataLessProps)
      : MDataLessProps(DataLessProps) {}
  PropertyListBase(
      std::bitset<DataLessPropKind::DataLessPropKindSize> DataLessProps,
      std::vector<std::shared_ptr<PropertyWithDataBase>> PropsWithData)
      : MDataLessProps(DataLessProps),
        MPropsWithData(std::move(PropsWithData)) {}
  void ctorHelper() {}

  template <typename... PropsT, class PropT>
  typename std::enable_if<
      std::is_base_of<DataLessPropertyBase, PropT>::value>::type
  ctorHelper(PropT &, PropsT... Props) {
    const int PropKind = static_cast<int>(PropT::getKind());
    MDataLessProps[PropKind] = true;
    ctorHelper(Props...);
  }

  template <typename... PropsT, class PropT>
  typename std::enable_if<
      std::is_base_of<PropertyWithDataBase, PropT>::value>::type
  ctorHelper(PropT &Prop, PropsT... Props) {
    MPropsWithData.emplace_back(new PropT(Prop));
    ctorHelper(Props...);
  }


  template <typename... PropsT, class PropT>
  typename std::enable_if<
      !std::is_base_of<PropertyWithDataBase, PropT>::value &&
      !std::is_base_of<DataLessPropertyBase, PropT>::value>::type
  ctorHelper(PropT &, PropsT... Props) {
    ctorHelper(Props...);
  }

  template <typename PropT>
  typename std::enable_if<std::is_base_of<DataLessPropertyBase, PropT>::value,
                          bool>::type
  has_property_helper() const {
    const int PropKind = static_cast<int>(PropT::getKind());
    if (PropKind >= detail::DataLessPropKind::DataLessPropKindSize)
      return false;
    return MDataLessProps[PropKind];
  }

  template <typename PropT>
  typename std::enable_if<std::is_base_of<PropertyWithDataBase, PropT>::value,
                          bool>::type
  has_property_helper() const {
    const int PropKind = static_cast<int>(PropT::getKind());
    for (const std::shared_ptr<PropertyWithDataBase> &Prop : MPropsWithData)
      if (Prop->isSame(PropKind))
        return true;
    return false;
  }

  template <typename PropT>
  typename std::enable_if<std::is_base_of<DataLessPropertyBase, PropT>::value,
                          PropT>::type
  get_property_helper() const {

    return PropT{};
  }

  template <typename PropT>
  typename std::enable_if<std::is_base_of<PropertyWithDataBase, PropT>::value,
                          PropT>::type
  get_property_helper() const {
    const int PropKind = static_cast<int>(PropT::getKind());
    if (PropKind >= PropWithDataKind::PropWithDataKindSize)
      throw sycl::invalid_object_error("The property is not found",
                                       PI_INVALID_VALUE);

    for (const std::shared_ptr<PropertyWithDataBase> &Prop : MPropsWithData)
      if (Prop->isSame(PropKind))
        return *static_cast<PropT *>(Prop.get());

    throw sycl::invalid_object_error("The property is not found",
                                     PI_INVALID_VALUE);
  }


  std::bitset<DataLessPropKind::DataLessPropKindSize> MDataLessProps;

  std::vector<std::shared_ptr<PropertyWithDataBase>> MPropsWithData;
};
}
}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/accessor_property_list.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/property_list.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/property_list.hpp" 3
inline namespace cl {
namespace sycl {
namespace ONEAPI {
template <typename... PropsT> class accessor_property_list;
}




class property_list : protected detail::PropertyListBase {


  template <typename... Tail> struct AllProperties : std::true_type {};
  template <typename T, typename... Tail>
  struct AllProperties<T, Tail...>
      : std::conditional<
            std::is_base_of<detail::DataLessPropertyBase, T>::value ||
                std::is_base_of<detail::PropertyWithDataBase, T>::value,
            AllProperties<Tail...>, std::false_type>::type {};

public:
  template <typename... PropsT, typename = typename std::enable_if<
                                    AllProperties<PropsT...>::value>::type>
  property_list(PropsT... Props) : detail::PropertyListBase(false) {
    ctorHelper(Props...);
  }

  template <typename PropT> PropT get_property() const {
    if (!has_property<PropT>())
      throw sycl::invalid_object_error("The property is not found",
                                       PI_INVALID_VALUE);

    return get_property_helper<PropT>();
  }

  template <typename PropT> bool has_property() const {
    return has_property_helper<PropT>();
  }

  template <typename... T> operator ONEAPI::accessor_property_list<T...>();

private:
  template <typename... PropsT> friend class ONEAPI::accessor_property_list;
};

}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/accessor_property_list.hpp" 2 3



inline namespace cl {
namespace sycl {

template <typename, int, access::mode, access::target, access::placeholder,
          typename PropertyListT>
class accessor;
namespace detail {


template <typename T> struct IsCompileTimePropertyInstance : std::false_type {};
}
namespace ONEAPI {

template <typename T> struct is_compile_time_property : std::false_type {};
# 43 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/accessor_property_list.hpp" 3
template <typename... PropsT>
class accessor_property_list : protected sycl::detail::PropertyListBase {


  template <class T, class U> struct AreSameTemplate : std::is_same<T, U> {};
  template <template <class...> class T, class T1, class T2>
  struct AreSameTemplate<T<T1>, T<T2>> : std::true_type {};




  template <template <auto...> class T, auto... T1, auto... T2>
  struct AreSameTemplate<T<T1...>, T<T2...>> : std::true_type {};




  template <typename PropT, typename... PropListT> struct ContainsProperty;
  template <typename PropT> struct ContainsProperty<PropT> : std::false_type {};
  template <typename PropT, typename Head, typename... Tail>
  struct ContainsProperty<PropT, Head, Tail...>
      : std::conditional<AreSameTemplate<PropT, Head>::value, std::true_type,
                         ContainsProperty<PropT, Tail...>>::type {};



  template <typename...> struct PropertyContainer {
    using Head = void;
    using Rest = void;
  };
  template <typename T, typename... Other>
  struct PropertyContainer<T, Other...> {
    using Head = T;
    using Rest = PropertyContainer<Other...>;
  };
  template <typename T> struct PropertyContainer<T> {
    using Head = T;
    using Rest = void;
  };




  template <typename ContainerT, template <auto...> typename PropT,
            auto... Args>
  struct ContainsPropertyInstance
      : std::conditional_t<
            !std::is_same_v<typename ContainerT::Head, void> &&
                AreSameTemplate<PropT<Args...>,
                                typename ContainerT::Head>::value,
            std::true_type,
            ContainsPropertyInstance<typename ContainerT::Rest, PropT,
                                     Args...>> {};

  template <template <auto...> typename PropT, auto... Args>
  struct ContainsPropertyInstance<void, PropT, Args...> : std::false_type {};





  template <typename ContainerT, typename... OtherProps>
  struct ContainsSameProperties
      : std::conditional<
            !detail::IsCompileTimePropertyInstance<
                typename ContainerT::Head>::value ||
                ContainsProperty<typename ContainerT::Head,
                                 OtherProps...>::value,
            ContainsSameProperties<typename ContainerT::Rest, OtherProps...>,
            std::false_type>::type {};
  template <typename... OtherProps>
  struct ContainsSameProperties<void, OtherProps...> : std::true_type {};






  template <typename ContainerT, template <auto...> class PropT, auto... Args>
  struct GetCompileTimePropertyHelper {
    using type = typename std::conditional_t<
        AreSameTemplate<typename ContainerT::Head, PropT<Args...>>::value,
        typename ContainerT::Head,
        typename GetCompileTimePropertyHelper<typename ContainerT::Rest, PropT,
                                              Args...>::type>;
  };
  template <typename Head, template <auto...> class PropT, auto... Args>
  struct GetCompileTimePropertyHelper<PropertyContainer<Head>, PropT, Args...> {
    using type = typename std::conditional_t<
        AreSameTemplate<Head, PropT<Args...>>::value, Head, void>;
  };







  template <typename... Tail> struct AllProperties : std::true_type {};
  template <typename T, typename... Tail>
  struct AllProperties<T, Tail...>
      : std::conditional<
            std::is_base_of<sycl::detail::DataLessPropertyBase, T>::value ||
                std::is_base_of<sycl::detail::PropertyWithDataBase, T>::value ||
                sycl::detail::IsCompileTimePropertyInstance<T>::value,
            AllProperties<Tail...>, std::false_type>::type {};

  accessor_property_list(
      std::bitset<sycl::detail::DataLessPropKind::DataLessPropKindSize>
          DataLessProps,
      std::vector<std::shared_ptr<sycl::detail::PropertyWithDataBase>>
          PropsWithData)
      : sycl::detail::PropertyListBase(DataLessProps, PropsWithData) {}

public:
  template <
      typename = typename std::enable_if<AllProperties<PropsT...>::value>::type>
  accessor_property_list(PropsT... Props)
      : sycl::detail::PropertyListBase(false) {
    ctorHelper(Props...);
  }

  accessor_property_list(const sycl::property_list &Props)
      : sycl::detail::PropertyListBase(Props.MDataLessProps,
                                       Props.MPropsWithData) {}

  template <typename... OtherProps,
            typename = typename std::enable_if<
                ContainsSameProperties<PropertyContainer<PropsT...>,
                                       OtherProps...>::value &&
                ContainsSameProperties<PropertyContainer<OtherProps...>,
                                       PropsT...>::value>::type>
  accessor_property_list(const accessor_property_list<OtherProps...> &OtherList)
      : sycl::detail::PropertyListBase(OtherList.MDataLessProps,
                                       OtherList.MPropsWithData) {}

  template <typename PropT, typename = typename std::enable_if<
                                !is_compile_time_property<PropT>::value>::type>
  PropT get_property() const {
    if (!has_property<PropT>())
      throw sycl::invalid_object_error("The property is not found",
                                       PI_INVALID_VALUE);

    return get_property_helper<PropT>();
  }

  template <class PropT>
  typename std::enable_if<!is_compile_time_property<PropT>::value, bool>::type
  has_property() const {
    return has_property_helper<PropT>();
  }


  template <typename T>
  static constexpr
      typename std::enable_if_t<is_compile_time_property<T>::value, bool>
      has_property() {
    return ContainsPropertyInstance<PropertyContainer<PropsT...>,
                                    T::template instance>::value;
  }

  template <typename T,
            typename = typename std::enable_if_t<
                is_compile_time_property<T>::value && has_property<T>()>>
  static constexpr auto get_property() {
    return typename GetCompileTimePropertyHelper<PropertyContainer<PropsT...>,
                                                 T::template instance>::type{};
  }


private:
  template <typename, int, access::mode, access::target, access::placeholder,
            typename PropertyListT>
  friend class sycl::accessor;

  template <typename... OtherProps> friend class accessor_property_list;

  friend class sycl::property_list;



  template <typename... OtherPropsT>
  static constexpr bool areSameCompileTimeProperties() {
    return ContainsSameProperties<PropertyContainer<OtherPropsT...>,
                                  PropsT...>::value;
  }
};
}
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/buffer.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/buffer.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/buffer_impl.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/buffer_impl.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/exception_list.hpp" 1 3
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/exception_list.hpp" 3
inline namespace cl {
namespace sycl {


namespace detail {
class queue_impl;
}




class __attribute__((visibility("default"))) exception_list {
public:
  using value_type = exception_ptr_class;
  using reference = value_type &;
  using const_reference = const value_type &;
  using size_type = std::size_t;
  using iterator = vector_class<exception_ptr_class>::const_iterator;
  using const_iterator = vector_class<exception_ptr_class>::const_iterator;

  size_type size() const;

  iterator begin() const;

  iterator end() const;

private:
  friend class detail::queue_impl;
  void PushBack(const_reference Value);
  void PushBack(value_type&& Value);
  void Clear() noexcept;
  vector_class<exception_ptr_class> MList;
};

using async_handler = function_class<void(cl::sycl::exception_list)>;

}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 3
inline namespace cl {
namespace sycl {

class program;
class device;
class platform;


namespace info {



enum class platform {
  profile = PI_PLATFORM_INFO_PROFILE,
  version = PI_PLATFORM_INFO_VERSION,
  name = PI_PLATFORM_INFO_NAME,
  vendor = PI_PLATFORM_INFO_VENDOR,
  extensions = PI_PLATFORM_INFO_EXTENSIONS,
};


enum class context : cl_context_info {
  reference_count = 0x1080,
  platform = 0x1084,
  devices = 0x1081,
};


enum class device : cl_device_info {
  device_type = 0x1000,
  vendor_id = 0x1001,
  max_compute_units = 0x1002,
  max_work_item_dimensions = 0x1003,
  max_work_item_sizes = 0x1005,
  max_work_group_size = 0x1004,

  preferred_vector_width_char = 0x1006,
  preferred_vector_width_short = 0x1007,
  preferred_vector_width_int = 0x1008,
  preferred_vector_width_long = 0x1009,
  preferred_vector_width_float = 0x100A,
  preferred_vector_width_double = 0x100B,
  preferred_vector_width_half = 0x1034,

  native_vector_width_char = 0x1036,
  native_vector_width_short = 0x1037,
  native_vector_width_int = 0x1038,
  native_vector_width_long = 0x1039,
  native_vector_width_float = 0x103A,
  native_vector_width_double = 0x103B,
  native_vector_width_half = 0x103C,

  max_clock_frequency = 0x100C,
  address_bits = 0x100D,
  max_mem_alloc_size = 0x1010,
  image_support = 0x1016,
  max_read_image_args = 0x100E,
  max_write_image_args = 0x100F,
  image2d_max_width = 0x1011,
  image2d_max_height = 0x1012,
  image3d_max_width = 0x1013,
  image3d_max_height = 0x1014,
  image3d_max_depth = 0x1015,
  image_max_buffer_size = 0x1040,
  image_max_array_size = 0x1041,
  max_samplers = 0x1018,
  max_parameter_size = 0x1017,
  mem_base_addr_align = 0x1019,
  half_fp_config = 0x1033,
  single_fp_config = 0x101B,
  double_fp_config = 0x1032,
  global_mem_cache_type = 0x101C,
  global_mem_cache_line_size = 0x101D,
  global_mem_cache_size = 0x101E,
  global_mem_size = 0x101F,
  max_constant_buffer_size = 0x1020,
  max_constant_args = 0x1021,
  local_mem_type = 0x1022,
  local_mem_size = 0x1023,
  error_correction_support = 0x1024,
  host_unified_memory = 0x1035,
  profiling_timer_resolution = 0x1025,
  is_endian_little = 0x1026,
  is_available = 0x1027,
  is_compiler_available = 0x1028,
  is_linker_available = 0x103E,
  execution_capabilities = 0x1029,
  queue_profiling = 0x102A,
  built_in_kernels = 0x103F,
  platform = 0x1031,
  name = 0x102B,
  vendor = 0x102C,
  driver_version = 0x102D,
  profile = 0x102E,
  version = 0x102F,
  opencl_c_version = 0x103D,
  extensions = 0x1030,
  printf_buffer_size = 0x1049,
  preferred_interop_user_sync = 0x1048,
  parent_device = 0x1042,
  partition_max_sub_devices = 0x1043,
  partition_properties = 0x1044,
  partition_affinity_domains = 0x1045,
  partition_type_affinity_domain = 0x1046,
  reference_count = 0x1047,
  il_version =
      0x105B,
  max_num_sub_groups = 0x105C,
  sub_group_independent_forward_progress =
      0x105D,
  sub_group_sizes = 0x4108,
  partition_type_property,
  kernel_kernel_pipe_support,

  usm_device_allocations = PI_DEVICE_INFO_USM_DEVICE_SUPPORT,
  usm_host_allocations = PI_DEVICE_INFO_USM_HOST_SUPPORT,
  usm_shared_allocations = PI_DEVICE_INFO_USM_SINGLE_SHARED_SUPPORT,
  usm_restricted_shared_allocations = PI_DEVICE_INFO_USM_CROSS_SHARED_SUPPORT,
  usm_system_allocator = PI_DEVICE_INFO_USM_SYSTEM_SHARED_SUPPORT
};

enum class device_type : pi_uint64 {
  cpu = PI_DEVICE_TYPE_CPU,
  gpu = PI_DEVICE_TYPE_GPU,
  accelerator = PI_DEVICE_TYPE_ACC,

  custom = (1 << 4),
  automatic,
  host,
  all = 0xFFFFFFFF
};

enum class partition_property : cl_device_partition_property {
  no_partition = 0,
  partition_equally = 0x1086,
  partition_by_counts = 0x1087,
  partition_by_affinity_domain = 0x1088
};

enum class partition_affinity_domain : cl_device_affinity_domain {
  not_applicable = 0,
  numa = (1 << 0),
  L4_cache = (1 << 1),
  L3_cache = (1 << 2),
  L2_cache = (1 << 3),
  L1_cache = (1 << 4),
  next_partitionable = (1 << 5)
};

enum class local_mem_type : int { none, local, global };

enum class fp_config : cl_device_fp_config {
  denorm = (1 << 0),
  inf_nan = (1 << 1),
  round_to_nearest = (1 << 2),
  round_to_zero = (1 << 3),
  round_to_inf = (1 << 4),
  fma = (1 << 5),
  correctly_rounded_divide_sqrt,
  soft_float
};

enum class global_mem_cache_type : int { none, read_only, read_write };

enum class execution_capability : unsigned int {
  exec_kernel,
  exec_native_kernel
};


enum class queue : cl_command_queue_info {
  context = 0x1090,
  device = 0x1091,
  reference_count = 0x1092
};


enum class kernel : cl_kernel_info {
  function_name = 0x1190,
  num_args = 0x1191,
  context = 0x1193,
  program = 0x1194,
  reference_count = 0x1192,
  attributes = 0x1195
};

enum class kernel_work_group : cl_kernel_work_group_info {
  global_work_size = 0x11B5,
  work_group_size = 0x11B0,
  compile_work_group_size = 0x11B1,
  preferred_work_group_size_multiple =
      0x11B3,
  private_mem_size = 0x11B4
};

enum class kernel_sub_group : cl_kernel_sub_group_info {
  max_sub_group_size = 0x2033,
  max_num_sub_groups = 0x11B9,
  compile_num_sub_groups = 0x11BA,
  compile_sub_group_size = 0x410A
};


enum class program : cl_program_info {
  context = 0x1161,
  devices = 0x1163,
  reference_count = 0x1160
};


enum class event : cl_event_info {
  reference_count = 0x11D2,
  command_execution_status = 0x11D3
};

enum class event_command_status : cl_int {
  submitted = 0x2,
  running = 0x1,
  complete = 0x0
};

enum class event_profiling : cl_profiling_info {
  command_submit = 0x1281,
  command_start = 0x1282,
  command_end = 0x1283
};


template <typename T, T param> class param_traits {};
# 258 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/device_traits.def" 1 3
template <> class param_traits<device, device::device_type> { public: using return_type = info::device_type; };
template <> class param_traits<device, device::vendor_id> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_compute_units> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_work_item_dimensions> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_work_item_sizes> { public: using return_type = id<3>; };
template <> class param_traits<device, device::max_work_group_size> { public: using return_type = size_t; };
template <> class param_traits<device, device::preferred_vector_width_char> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::preferred_vector_width_short> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::preferred_vector_width_int> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::preferred_vector_width_long> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::preferred_vector_width_float> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::preferred_vector_width_double> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::preferred_vector_width_half> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_char> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_short> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_int> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_long> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_float> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_double> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::native_vector_width_half> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_clock_frequency> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::address_bits> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_mem_alloc_size> { public: using return_type = pi_uint64; };
template <> class param_traits<device, device::image_support> { public: using return_type = bool; };
template <> class param_traits<device, device::max_read_image_args> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_write_image_args> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::image2d_max_width> { public: using return_type = size_t; };
template <> class param_traits<device, device::image2d_max_height> { public: using return_type = size_t; };
template <> class param_traits<device, device::image3d_max_width> { public: using return_type = size_t; };
template <> class param_traits<device, device::image3d_max_height> { public: using return_type = size_t; };
template <> class param_traits<device, device::image3d_max_depth> { public: using return_type = size_t; };
template <> class param_traits<device, device::image_max_buffer_size> { public: using return_type = size_t; };
template <> class param_traits<device, device::image_max_array_size> { public: using return_type = size_t; };
template <> class param_traits<device, device::max_samplers> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_parameter_size> { public: using return_type = size_t; };
template <> class param_traits<device, device::mem_base_addr_align> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::half_fp_config> { public: using return_type = vector_class<info::fp_config>; };
template <> class param_traits<device, device::single_fp_config> { public: using return_type = vector_class<info::fp_config>; };
template <> class param_traits<device, device::double_fp_config> { public: using return_type = vector_class<info::fp_config>; };
template <> class param_traits<device, device::global_mem_cache_type> { public: using return_type = info::global_mem_cache_type; };
template <> class param_traits<device, device::global_mem_cache_line_size> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::global_mem_cache_size> { public: using return_type = pi_uint64; };
template <> class param_traits<device, device::global_mem_size> { public: using return_type = pi_uint64; };
template <> class param_traits<device, device::max_constant_buffer_size> { public: using return_type = pi_uint64; };
template <> class param_traits<device, device::max_constant_args> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::local_mem_type> { public: using return_type = info::local_mem_type; };
template <> class param_traits<device, device::local_mem_size> { public: using return_type = pi_uint64; };
template <> class param_traits<device, device::error_correction_support> { public: using return_type = bool; };
template <> class param_traits<device, device::host_unified_memory> { public: using return_type = bool; };
template <> class param_traits<device, device::profiling_timer_resolution> { public: using return_type = size_t; };
template <> class param_traits<device, device::is_endian_little> { public: using return_type = bool; };
template <> class param_traits<device, device::is_available> { public: using return_type = bool; };
template <> class param_traits<device, device::is_compiler_available> { public: using return_type = bool; };
template <> class param_traits<device, device::is_linker_available> { public: using return_type = bool; };
template <> class param_traits<device, device::execution_capabilities> { public: using return_type = vector_class<info::execution_capability>; };

template <> class param_traits<device, device::queue_profiling> { public: using return_type = bool; };
template <> class param_traits<device, device::built_in_kernels> { public: using return_type = vector_class<string_class>; };
template <> class param_traits<device, device::platform> { public: using return_type = cl::sycl::platform; };
template <> class param_traits<device, device::name> { public: using return_type = string_class; };
template <> class param_traits<device, device::vendor> { public: using return_type = string_class; };
template <> class param_traits<device, device::driver_version> { public: using return_type = string_class; };
template <> class param_traits<device, device::profile> { public: using return_type = string_class; };
template <> class param_traits<device, device::version> { public: using return_type = string_class; };
template <> class param_traits<device, device::opencl_c_version> { public: using return_type = string_class; };
template <> class param_traits<device, device::extensions> { public: using return_type = vector_class<string_class>; };
template <> class param_traits<device, device::printf_buffer_size> { public: using return_type = size_t; };
template <> class param_traits<device, device::preferred_interop_user_sync> { public: using return_type = bool; };
template <> class param_traits<device, device::parent_device> { public: using return_type = cl::sycl::device; };
template <> class param_traits<device, device::partition_max_sub_devices> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::partition_properties> { public: using return_type = vector_class<info::partition_property>; };

template <> class param_traits<device, device::partition_affinity_domains> { public: using return_type = vector_class<info::partition_affinity_domain>; };

template <> class param_traits<device, device::partition_type_property> { public: using return_type = info::partition_property; };
template <> class param_traits<device, device::partition_type_affinity_domain> { public: using return_type = info::partition_affinity_domain; };

template <> class param_traits<device, device::reference_count> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::max_num_sub_groups> { public: using return_type = pi_uint32; };
template <> class param_traits<device, device::sub_group_independent_forward_progress> { public: using return_type = bool; };
template <> class param_traits<device, device::sub_group_sizes> { public: using return_type = vector_class<size_t>; };
template <> class param_traits<device, device::kernel_kernel_pipe_support> { public: using return_type = bool; };
template <> class param_traits<device, device::usm_device_allocations> { public: using return_type = bool; };
template <> class param_traits<device, device::usm_host_allocations> { public: using return_type = bool; };
template <> class param_traits<device, device::usm_shared_allocations> { public: using return_type = bool; };
template <> class param_traits<device, device::usm_restricted_shared_allocations> { public: using return_type = bool; };
template <> class param_traits<device, device::usm_system_allocator> { public: using return_type = bool; };
# 259 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/context_traits.def" 1 3
template <> class param_traits<context, context::reference_count> { public: using return_type = cl_uint; };
template <> class param_traits<context, context::platform> { public: using return_type = cl::sycl::platform; };
template <> class param_traits<context, context::devices> { public: using return_type = vector_class<cl::sycl::device>; };
# 261 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/event_traits.def" 1 3
template <> class param_traits<event, event::command_execution_status> { public: using return_type = info::event_command_status; };
template <> class param_traits<event, event::reference_count> { public: using return_type = cl_uint; };
# 263 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/event_profiling_traits.def" 1 3
template <> class param_traits<event_profiling, event_profiling::command_submit> { public: using return_type = cl_ulong; };
template <> class param_traits<event_profiling, event_profiling::command_start> { public: using return_type = cl_ulong; };
template <> class param_traits<event_profiling, event_profiling::command_end> { public: using return_type = cl_ulong; };
# 265 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/kernel_sub_group_traits.def" 1 3
template <> class param_traits<kernel_sub_group, kernel_sub_group::max_sub_group_size> { public: using return_type = uint32_t; using input_type = cl::sycl::range<3>; };

template <> class param_traits<kernel_sub_group, kernel_sub_group::max_num_sub_groups> { public: using return_type = uint32_t; };
template <> class param_traits<kernel_sub_group, kernel_sub_group::compile_num_sub_groups> { public: using return_type = uint32_t; };
template <> class param_traits<kernel_sub_group, kernel_sub_group::compile_sub_group_size> { public: using return_type = uint32_t; };
# 267 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/kernel_traits.def" 1 3
template <> class param_traits<kernel, kernel::function_name> { public: using return_type = string_class; };
template <> class param_traits<kernel, kernel::num_args> { public: using return_type = cl_uint; };
template <> class param_traits<kernel, kernel::reference_count> { public: using return_type = cl_uint; };
template <> class param_traits<kernel, kernel::attributes> { public: using return_type = string_class; };
template <> class param_traits<kernel, kernel::context> { public: using return_type = cl::sycl::context; };
template <> class param_traits<kernel, kernel::program> { public: using return_type = cl::sycl::program; };
# 268 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/kernel_work_group_traits.def" 1 3
template <> class param_traits<kernel_work_group, kernel_work_group::compile_work_group_size> { public: using return_type = cl::sycl::range<3>; };

template <> class param_traits<kernel_work_group, kernel_work_group::global_work_size> { public: using return_type = cl::sycl::range<3>; };
template <> class param_traits<kernel_work_group, kernel_work_group::preferred_work_group_size_multiple> { public: using return_type = size_t; };
template <> class param_traits<kernel_work_group, kernel_work_group::private_mem_size> { public: using return_type = cl_ulong; };
template <> class param_traits<kernel_work_group, kernel_work_group::work_group_size> { public: using return_type = size_t; };
# 269 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/platform_traits.def" 1 3
template <> class param_traits<platform, platform::profile> { public: using return_type = string_class; };
template <> class param_traits<platform, platform::version> { public: using return_type = string_class; };
template <> class param_traits<platform, platform::name> { public: using return_type = string_class; };
template <> class param_traits<platform, platform::vendor> { public: using return_type = string_class; };
template <> class param_traits<platform, platform::extensions> { public: using return_type = vector_class<string_class>; };
# 271 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/program_traits.def" 1 3
template <> class param_traits<program, program::context> { public: using return_type = cl::sycl::context; };
template <> class param_traits<program, program::devices> { public: using return_type = vector_class<cl::sycl::device>; };
template <> class param_traits<program, program::reference_count> { public: using return_type = cl_uint; };
# 273 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/queue_traits.def" 1 3
template <> class param_traits<queue, queue::reference_count> { public: using return_type = cl_uint; };
template <> class param_traits<queue, queue::context> { public: using return_type = cl::sycl::context; };
template <> class param_traits<queue, queue::device> { public: using return_type = cl::sycl::device; };
# 275 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/info/info_desc.hpp" 2 3




}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 2 3






inline namespace cl {
namespace sycl {

class device;
class platform;
namespace detail {
class context_impl;
}





class __attribute__((visibility("default"))) context {
public:
# 45 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const property_list &PropList = {});
# 58 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const async_handler &AsyncHandler,
                   const property_list &PropList = {});
# 70 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const device &Device, const property_list &PropList = {});
# 84 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const device &Device, async_handler AsyncHandler,
                   const property_list &PropList = {});
# 96 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const platform &Platform,
                   const property_list &PropList = {});
# 110 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const platform &Platform, async_handler AsyncHandler,
                   const property_list &PropList = {});
# 123 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const vector_class<device> &DeviceList,
                   const property_list &PropList = {});
# 139 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  explicit context(const vector_class<device> &DeviceList,
                   async_handler AsyncHandler,
                   const property_list &PropList = {});
# 151 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/context.hpp" 3
  context(cl_context ClContext, async_handler AsyncHandler = {});




  template <info::context param>
  typename info::param_traits<info::context, param>::return_type
  get_info() const;

  context(const context &rhs) = default;

  context(context &&rhs) = default;

  context &operator=(const context &rhs) = default;

  context &operator=(context &&rhs) = default;

  bool operator==(const context &rhs) const { return impl == rhs.impl; }

  bool operator!=(const context &rhs) const { return !(*this == rhs); }




  template <typename propertyT> bool has_property() const;







  template <typename propertyT> propertyT get_property() const;






  cl_context get() const;




  bool is_host() const;




  platform get_platform() const;




  vector_class<device> get_devices() const;




  template <backend BackendName>
  auto get_native() const -> typename interop<BackendName, context>::type {
    return reinterpret_cast<typename interop<BackendName, context>::type>(
        getNative());
  }

private:

  context(shared_ptr_class<detail::context_impl> Impl);

  pi_native_handle getNative() const;

  shared_ptr_class<detail::context_impl> impl;
  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);

  template <class T>
  friend
      typename std::add_pointer<typename decltype(T::impl)::element_type>::type
      detail::getRawSyclObjImpl(const T &SyclObject);

  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);
};

}
}

namespace std {
template <> struct hash<cl::sycl::context> {
  size_t operator()(const cl::sycl::context &Context) const {
    return hash<cl::sycl::shared_ptr_class<cl::sycl::detail::context_impl>>()(
        cl::sycl::detail::getSyclObjImpl(Context));
  }
};
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/buffer_impl.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_allocator.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_allocator.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {

template <typename T>
class aligned_allocator;

class SYCLMemObjAllocator {

protected:
  virtual void *getAllocatorImpl() = 0;

public:
  virtual ~SYCLMemObjAllocator() = default;
  virtual void *allocate(std::size_t) = 0;
  virtual void deallocate(void *, std::size_t) = 0;
  virtual std::size_t getValueSize() const = 0;
  virtual void setAlignment(std::size_t RequiredAlign) = 0;
  template <typename AllocatorT> AllocatorT getAllocator() {
    return *reinterpret_cast<AllocatorT *>(getAllocatorImpl());
  }
};

template <typename AllocatorT>
class SYCLMemObjAllocatorHolder : public SYCLMemObjAllocator {
  using sycl_memory_object_allocator = detail::aligned_allocator<char>;

  template <typename T>
  using EnableIfDefaultAllocator =
      enable_if_t<std::is_same<T, sycl_memory_object_allocator>::value>;

  template <typename T>
  using EnableIfNonDefaultAllocator =
      enable_if_t<!std::is_same<T, sycl_memory_object_allocator>::value>;

public:
  SYCLMemObjAllocatorHolder(AllocatorT Allocator)
      : MAllocator(Allocator),
        MValueSize(sizeof(typename AllocatorT::value_type)) {}

  SYCLMemObjAllocatorHolder()
      : MAllocator(AllocatorT()),
        MValueSize(sizeof(typename AllocatorT::value_type)) {}

  ~SYCLMemObjAllocatorHolder() = default;

  virtual void *allocate(std::size_t Count) override {
    return reinterpret_cast<void *>(MAllocator.allocate(Count));
  }

  virtual void deallocate(void *Ptr, std::size_t Count) override {
    MAllocator.deallocate(
        reinterpret_cast<typename AllocatorT::value_type *>(Ptr), Count);
  }

  void setAlignment(std::size_t RequiredAlign) override {
    setAlignImpl(RequiredAlign);
  }

  virtual std::size_t getValueSize() const override { return MValueSize; }

protected:
  virtual void *getAllocatorImpl() override { return &MAllocator; }

private:
  template <typename T = AllocatorT>
  EnableIfNonDefaultAllocator<T> setAlignImpl(std::size_t) {

  }

  template <typename T = AllocatorT>
  EnableIfDefaultAllocator<T> setAlignImpl(std::size_t RequiredAlign) {
    MAllocator.setAlignment(std::max<size_t>(RequiredAlign, 64));
  }

  AllocatorT MAllocator;
  std::size_t MValueSize;
};
}
}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_i.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_i.hpp" 3
inline namespace cl {
namespace sycl {

namespace detail {

class event_impl;
class context_impl;
struct MemObjRecord;

using EventImplPtr = shared_ptr_class<detail::event_impl>;
using ContextImplPtr = shared_ptr_class<detail::context_impl>;



class SYCLMemObjI {
public:
  virtual ~SYCLMemObjI() = default;

  enum MemObjType { BUFFER, IMAGE, UNDEFINED };

  virtual MemObjType getType() const = 0;
# 46 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_i.hpp" 3
  virtual void *allocateMem(ContextImplPtr Context, bool InitFromUserData,
                            void *HostPtr, RT::PiEvent &InteropEvent) = 0;


  virtual void *allocateHostMem() = 0;





  virtual void releaseMem(ContextImplPtr Context, void *Ptr) = 0;


  virtual void releaseHostMem(void *Ptr) = 0;


  virtual size_t getSize() const = 0;



  virtual ContextImplPtr getInteropContext() const = 0;

protected:





  shared_ptr_class<MemObjRecord> MRecord;
  friend class Scheduler;
  friend class ExecCGCommand;
};

}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/event.hpp" 1 3
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/event.hpp" 3
inline namespace cl {
namespace sycl {

class context;
namespace detail {
class event_impl;
}





class __attribute__((visibility("default"))) event {
public:



  event();







  event(cl_event ClEvent, const context &SyclContext);

  event(const event &rhs) = default;

  event(event &&rhs) = default;

  event &operator=(const event &rhs) = default;

  event &operator=(event &&rhs) = default;

  bool operator==(const event &rhs) const;

  bool operator!=(const event &rhs) const;




  cl_event get() const;




  bool is_host() const;







  vector_class<event> get_wait_list();


  void wait();




  static void wait(const vector_class<event> &EventList);






  void wait_and_throw();
# 98 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/event.hpp" 3
  static void wait_and_throw(const vector_class<event> &EventList);




  template <info::event param>
  typename info::param_traits<info::event, param>::return_type get_info() const;
# 117 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/event.hpp" 3
  template <info::event_profiling param>
  typename info::param_traits<info::event_profiling, param>::return_type
  get_profiling_info() const;




  template <backend BackendName>
  auto get_native() const -> typename interop<BackendName, event>::type {
    return static_cast<typename interop<BackendName, event>::type>(getNative());
  }

private:
  event(shared_ptr_class<detail::event_impl> EventImpl);

  pi_native_handle getNative() const;

  shared_ptr_class<detail::event_impl> impl;

  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);

  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);
};

}
}

namespace std {
template <> struct hash<cl::sycl::event> {
  size_t operator()(const cl::sycl::event &e) const {
    return hash<cl::sycl::shared_ptr_class<cl::sycl::detail::event_impl>>()(
        cl::sycl::detail::getSyclObjImpl(e));
  }
};
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/buffer_properties.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/buffer_properties.hpp" 3
inline namespace cl {
namespace sycl {

namespace property {
namespace buffer {
class use_host_ptr : public detail::DataLessProperty<detail::BufferUseHostPtr> {
};

class use_mutex : public detail::PropertyWithData<detail::BufferUseMutex> {
public:
  use_mutex(sycl::mutex_class &MutexRef) : MMutex(MutexRef) {}

  sycl::mutex_class *get_mutex_ptr() const { return &MMutex; }

private:
  sycl::mutex_class &MMutex;
};

class context_bound
    : public detail::PropertyWithData<detail::BufferContextBound> {
public:
  context_bound(sycl::context BoundContext) : MCtx(std::move(BoundContext)) {}

  sycl::context get_context() const { return MCtx; }

private:
  sycl::context MCtx;
};

class mem_channel : public detail::PropertyWithData<
                        detail::PropWithDataKind::BufferMemChannel> {
public:
  mem_channel(cl_uint Channel) : m_Channel(Channel) {}
  cl_uint get_channel() const { return m_Channel; }

private:
  cl_uint m_Channel;
};

}
}

namespace ext {
namespace oneapi {
namespace property {
namespace buffer {

class use_pinned_host_memory
    : public detail::DataLessProperty<detail::BufferUsePinnedHostMemory> {};
}
}
}
}
}
}
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/image_properties.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/image_properties.hpp" 3
inline namespace cl {
namespace sycl {
namespace property {
namespace image {
class use_host_ptr : public detail::DataLessProperty<detail::ImageUseHostPtr> {
};

class use_mutex : public detail::PropertyWithData<detail::ImageUseMutex> {
public:
  use_mutex(sycl::mutex_class &MutexRef) : MMutex(MutexRef) {}

  sycl::mutex_class *get_mutex_ptr() const { return &MMutex; }

private:
  sycl::mutex_class &MMutex;
};

class context_bound
    : public detail::PropertyWithData<detail::ImageContextBound> {
public:
  context_bound(sycl::context BoundContext) : MCtx(std::move(BoundContext)) {}

  sycl::context get_context() const { return MCtx; }

private:
  sycl::context MCtx;
};
}
}
}
}
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {





# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4








extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 90 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 103 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 114 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 225 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 265 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 302 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 329 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 359 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();




# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
# 486 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 2 3
# 71 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
# 23 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_mem_obj_t.hpp" 2 3


inline namespace cl {
namespace sycl {
namespace detail {


class context_impl;
class event_impl;
class plugin;

using ContextImplPtr = shared_ptr_class<context_impl>;
using EventImplPtr = shared_ptr_class<event_impl>;

template <typename T>
class aligned_allocator;
using sycl_memory_object_allocator = aligned_allocator<char>;


class __attribute__((visibility("default"))) SYCLMemObjT : public SYCLMemObjI {





  template <typename T>
  using EnableIfOutputPointerT = enable_if_t<
                                          std::is_pointer<T>::value>;

  template <typename T>
  using EnableIfOutputIteratorT = enable_if_t<
                                          !std::is_pointer<T>::value>;

  template <typename T>
  using EnableIfDefaultAllocator =
      enable_if_t<std::is_same<T, sycl_memory_object_allocator>::value>;

  template <typename T>
  using EnableIfNonDefaultAllocator =
      enable_if_t<!std::is_same<T, sycl_memory_object_allocator>::value>;

public:
  SYCLMemObjT(const size_t SizeInBytes, const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : MAllocator(std::move(Allocator)), MProps(Props), MInteropEvent(nullptr),
        MInteropContext(nullptr), MInteropMemObject(nullptr),
        MOpenCLInterop(false), MHostPtrReadOnly(false), MNeedWriteBack(true),
        MSizeInBytes(SizeInBytes), MUserPtr(nullptr), MShadowCopy(nullptr),
        MUploadDataFunctor(nullptr), MSharedPtrStorage(nullptr) {}

  SYCLMemObjT(const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : SYCLMemObjT( 0, Props, std::move(Allocator)) {}

  SYCLMemObjT(cl_mem MemObject, const context &SyclContext,
              const size_t SizeInBytes, event AvailableEvent,
              unique_ptr_class<SYCLMemObjAllocator> Allocator);

  SYCLMemObjT(cl_mem MemObject, const context &SyclContext,
              event AvailableEvent,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : SYCLMemObjT(MemObject, SyclContext, 0, AvailableEvent,
                    std::move(Allocator)) {}

  virtual ~SYCLMemObjT() = default;

  const plugin &getPlugin() const;

  __attribute__((visibility("hidden"))) size_t getSize() const override { return MSizeInBytes; }
  __attribute__((visibility("hidden"))) size_t get_count() const {
    size_t AllocatorValueSize = MAllocator->getValueSize();
    return (getSize() + AllocatorValueSize - 1) / AllocatorValueSize;
  }

  template <typename propertyT> __attribute__((visibility("hidden"))) bool has_property() const {
    return MProps.has_property<propertyT>();
  }

  template <typename propertyT> __attribute__((visibility("hidden"))) propertyT get_property() const {
    return MProps.get_property<propertyT>();
  }

  template <typename AllocatorT> __attribute__((visibility("hidden"))) AllocatorT get_allocator() const {
    return MAllocator->getAllocator<AllocatorT>();
  }

  __attribute__((visibility("hidden"))) void *allocateHostMem() override {
    return MAllocator->allocate(get_count());
  }

  __attribute__((visibility("hidden"))) void releaseHostMem(void *Ptr) override {
    if (Ptr)
      MAllocator->deallocate(Ptr, get_count());
  }

  void releaseMem(ContextImplPtr Context, void *MemAllocation) override;

  __attribute__((visibility("hidden"))) void *getUserPtr() const {
    return MOpenCLInterop ? static_cast<void *>(MInteropMemObject) : MUserPtr;
  }

  __attribute__((visibility("hidden"))) void set_write_back(bool NeedWriteBack) {
    MNeedWriteBack = NeedWriteBack;
  }

  __attribute__((visibility("hidden"))) void set_final_data(std::nullptr_t) {
    MUploadDataFunctor = nullptr;
  }

  template <template <typename T> class PtrT, typename T>
  __attribute__((visibility("hidden"))) enable_if_t<std::is_convertible<PtrT<T>, weak_ptr_class<T>>::value>
  set_final_data(PtrT<T> FinalData) {
    weak_ptr_class<T> TempFinalData(FinalData);
    set_final_data(TempFinalData);
  }

  template <typename T>
  __attribute__((visibility("hidden"))) void set_final_data(weak_ptr_class<T> FinalData) {
    MUploadDataFunctor = [this, FinalData]() {
      if (shared_ptr_class<T> LockedFinalData = FinalData.lock()) {
        updateHostMemory(LockedFinalData.get());
      }
    };
  }

  __attribute__((visibility("hidden"))) void set_final_data_from_storage() {
    MUploadDataFunctor = [this]() {
      if (!MSharedPtrStorage.unique()) {
        void *FinalData = const_cast<void *>(MSharedPtrStorage.get());
        updateHostMemory(FinalData);
      }
    };
  }

  template <typename Destination>
  __attribute__((visibility("hidden"))) EnableIfOutputPointerT<Destination>
  set_final_data(Destination FinalData) {
    if (!FinalData)
      MUploadDataFunctor = nullptr;
    else
      MUploadDataFunctor = [this, FinalData]() {
        updateHostMemory(FinalData);
      };
  }

  template <typename Destination>
  __attribute__((visibility("hidden"))) EnableIfOutputIteratorT<Destination>
  set_final_data(Destination FinalData) {
    MUploadDataFunctor = [this, FinalData]() {
      using DestinationValueT = iterator_value_type_t<Destination>;



      const size_t Size = MSizeInBytes / sizeof(DestinationValueT);
      vector_class<DestinationValueT> ContiguousStorage(Size);
      updateHostMemory(ContiguousStorage.data());
      std::copy(ContiguousStorage.cbegin(), ContiguousStorage.cend(),
                FinalData);
    };
  }

protected:
  void updateHostMemory(void *const Ptr);






  void updateHostMemory();

public:
  __attribute__((visibility("hidden"))) bool useHostPtr() {
    return has_property<property::buffer::use_host_ptr>() ||
           has_property<property::image::use_host_ptr>();
  }

  __attribute__((visibility("hidden"))) bool canReuseHostPtr(void *HostPtr, const size_t RequiredAlign) {
    bool Aligned =
        (reinterpret_cast<std::uintptr_t>(HostPtr) % RequiredAlign) == 0;
    return Aligned || useHostPtr();
  }

  __attribute__((visibility("hidden"))) void handleHostData(void *HostPtr, const size_t RequiredAlign) {
    if (!MHostPtrReadOnly)
      set_final_data(reinterpret_cast<char *>(HostPtr));

    if (canReuseHostPtr(HostPtr, RequiredAlign)) {
      MUserPtr = HostPtr;
    } else {
      setAlign(RequiredAlign);
      MShadowCopy = allocateHostMem();
      MUserPtr = MShadowCopy;
      std::memcpy(MUserPtr, HostPtr, MSizeInBytes);
    }
  }

  __attribute__((visibility("hidden"))) void handleHostData(const void *HostPtr,
                                const size_t RequiredAlign) {
    MHostPtrReadOnly = true;
    handleHostData(const_cast<void *>(HostPtr), RequiredAlign);
  }

  template <typename T>
  __attribute__((visibility("hidden"))) void handleHostData(const shared_ptr_class<T> &HostPtr,
                                const size_t RequiredAlign) {
    MSharedPtrStorage = HostPtr;
    MHostPtrReadOnly = std::is_const<T>::value;
    if (HostPtr) {
      if (!MHostPtrReadOnly)
        set_final_data_from_storage();

      if (canReuseHostPtr(HostPtr.get(), RequiredAlign))
        MUserPtr = HostPtr.get();
      else {
        setAlign(RequiredAlign);
        MShadowCopy = allocateHostMem();
        MUserPtr = MShadowCopy;
        std::memcpy(MUserPtr, HostPtr.get(), MSizeInBytes);
      }
    }
  }

  template <class InputIterator>
  __attribute__((visibility("hidden"))) void handleHostData(InputIterator First, InputIterator Last,
                                const size_t RequiredAlign) {
    MHostPtrReadOnly = iterator_to_const_type_t<InputIterator>::value;
    setAlign(RequiredAlign);
    if (useHostPtr())
      throw runtime_error(
          "Buffer constructor from a pair of iterator values does not support "
          "use_host_ptr property.",
          PI_INVALID_OPERATION);

    setAlign(RequiredAlign);
    MShadowCopy = allocateHostMem();
    MUserPtr = MShadowCopy;



    using IteratorValueType = iterator_value_type_t<InputIterator>;
    using IteratorNonConstValueType = remove_const_t<IteratorValueType>;
    using IteratorPointerToNonConstValueType =
        add_pointer_t<IteratorNonConstValueType>;
    std::copy(First, Last,
              static_cast<IteratorPointerToNonConstValueType>(MUserPtr));
  }

  __attribute__((visibility("hidden"))) void setAlign(size_t RequiredAlign) {
    MAllocator->setAlignment(RequiredAlign);
  }

  static size_t getBufSizeForContext(const ContextImplPtr &Context,
                                     cl_mem MemObject);

  __attribute__((visibility("hidden"))) void *allocateMem(ContextImplPtr Context, bool InitFromUserData,
                              void *HostPtr,
                              RT::PiEvent &InteropEvent) override {
    (void)Context;
    (void)InitFromUserData;
    (void)HostPtr;
    (void)InteropEvent;
    throw runtime_error("Not implemented", PI_INVALID_OPERATION);
  }

  __attribute__((visibility("hidden"))) MemObjType getType() const override { return UNDEFINED; }

  ContextImplPtr getInteropContext() const override { return MInteropContext; }

protected:

  unique_ptr_class<SYCLMemObjAllocator> MAllocator;

  property_list MProps;


  EventImplPtr MInteropEvent;

  ContextImplPtr MInteropContext;


  cl_mem MInteropMemObject;


  bool MOpenCLInterop;

  bool MHostPtrReadOnly;

  bool MNeedWriteBack;

  size_t MSizeInBytes;

  void *MUserPtr;

  void *MShadowCopy;

  function_class<void(void)> MUploadDataFunctor;


  shared_ptr_class<const void> MSharedPtrStorage;
};

}
}
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/buffer_impl.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 1 3
# 55 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cassert" 1 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cassert" 2 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 2 3


inline namespace cl {
namespace sycl {

template <typename dataT, int dimensions, access::mode accessMode,
          access::target accessTarget, access::placeholder isPlaceholder,
          typename PropertyListT>
class accessor;





template <typename ElementType, access::address_space Space> class multi_ptr {
public:
  using element_type =
      detail::conditional_t<std::is_same<ElementType, half>::value,
                    cl::sycl::detail::half_impl::BIsRepresentationT,
                    ElementType>;
  using difference_type = std::ptrdiff_t;



  using pointer_t = typename detail::PtrValueType<ElementType, Space>::type *;
  using const_pointer_t =
      typename detail::PtrValueType<ElementType, Space>::type const *;
  using reference_t = typename detail::PtrValueType<ElementType, Space>::type &;
  using const_reference_t =
      typename detail::PtrValueType<ElementType, Space>::type &;

  static constexpr access::address_space address_space = Space;


  multi_ptr() : m_Pointer(nullptr) {}
  multi_ptr(const multi_ptr &rhs) = default;
  multi_ptr(multi_ptr &&) = default;




  multi_ptr(ElementType *pointer) : m_Pointer((pointer_t)(pointer)) {


  }





  multi_ptr(std::nullptr_t) : m_Pointer(nullptr) {}
  ~multi_ptr() = default;


  multi_ptr &operator=(const multi_ptr &) = default;
  multi_ptr &operator=(multi_ptr &&) = default;
# 80 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  multi_ptr &operator=(ElementType *pointer) {


    m_Pointer = (pointer_t)pointer;
    return *this;
  }

  multi_ptr &operator=(std::nullptr_t) {
    m_Pointer = nullptr;
    return *this;
  }

  using ReturnPtr = detail::const_if_const_AS<Space, ElementType> *;
  using ReturnRef = detail::const_if_const_AS<Space, ElementType> &;
  using ReturnConstRef = const ElementType &;

  ReturnRef operator*() const {
    return *reinterpret_cast<ReturnPtr>(m_Pointer);
  }

  ReturnPtr operator->() const {
    return reinterpret_cast<ReturnPtr>(m_Pointer);
  }

  ReturnRef operator[](difference_type index) {
    return reinterpret_cast<ReturnPtr>(m_Pointer)[index];
  }

  ReturnConstRef operator[](difference_type index) const {
    return reinterpret_cast<ReturnPtr>(m_Pointer)[index];
  }


  template <int dimensions, access::mode Mode,
            access::placeholder isPlaceholder, typename PropertyListT,
            access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                (Space == access::address_space::global_space ||
                 Space == access::address_space::global_device_space)>::type>
  multi_ptr(
      accessor<ElementType, dimensions, Mode, access::target::global_buffer,
               isPlaceholder, PropertyListT>
          Accessor) {
    m_Pointer = (pointer_t)(Accessor.get_pointer().get());
  }


  template <
      int dimensions, access::mode Mode, access::placeholder isPlaceholder,
      typename PropertyListT, access::address_space _Space = Space,
      typename = typename std::enable_if<
          _Space == Space && Space == access::address_space::local_space>::type>
  multi_ptr(accessor<ElementType, dimensions, Mode, access::target::local,
                     isPlaceholder, PropertyListT>
                Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <int dimensions, access::mode Mode,
            access::placeholder isPlaceholder, typename PropertyListT,
            access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                Space == access::address_space::constant_space>::type>
  multi_ptr(
      accessor<ElementType, dimensions, Mode, access::target::constant_buffer,
               isPlaceholder, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}
# 161 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  template <int dimensions, access::mode Mode,
            access::placeholder isPlaceholder, typename PropertyListT,
            access::address_space _Space = Space, typename ET = ElementType,
            typename = typename std::enable_if<
                _Space == Space &&
                (Space == access::address_space::global_space ||
                 Space == access::address_space::global_device_space) &&
                std::is_const<ET>::value &&
                std::is_same<ET, ElementType>::value>::type>
  multi_ptr(
      accessor<typename std::remove_const<ET>::type, dimensions, Mode,
               access::target::global_buffer, isPlaceholder, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <
      int dimensions, access::mode Mode, access::placeholder isPlaceholder,
      typename PropertyListT, access::address_space _Space = Space,
      typename ET = ElementType,
      typename = typename std::enable_if<
          _Space == Space && Space == access::address_space::local_space &&
          std::is_const<ET>::value &&
          std::is_same<ET, ElementType>::value>::type>
  multi_ptr(accessor<typename std::remove_const<ET>::type, dimensions, Mode,
                     access::target::local, isPlaceholder, PropertyListT>
                Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <
      int dimensions, access::mode Mode, access::placeholder isPlaceholder,
      typename PropertyListT, access::address_space _Space = Space,
      typename ET = ElementType,
      typename = typename std::enable_if<
          _Space == Space && Space == access::address_space::constant_space &&
          std::is_const<ET>::value &&
          std::is_same<ET, ElementType>::value>::type>
  multi_ptr(
      accessor<typename std::remove_const<ET>::type, dimensions, Mode,
               access::target::constant_buffer, isPlaceholder, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}







  template <typename ET = ElementType>
  multi_ptr(typename std::enable_if<
      std::is_const<ET>::value && std::is_same<ET, ElementType>::value,
      const multi_ptr<typename std::remove_const<ET>::type, Space> >::type &ETP)
      : m_Pointer(ETP.get()) {}


  pointer_t get() const { return m_Pointer; }


  operator ReturnPtr() const { return reinterpret_cast<ReturnPtr>(m_Pointer); }



  template <typename ET = ElementType>
  operator multi_ptr<typename std::enable_if<
      std::is_same<ET, ElementType>::value && !std::is_const<ET>::value,
      void>::type, Space>() const {
    using ptr_t = typename detail::PtrValueType<void, Space>::type *;
    return multi_ptr<void, Space>(reinterpret_cast<ptr_t>(m_Pointer));
  }



  template <typename ET = ElementType>
  operator multi_ptr<typename std::enable_if<
      std::is_same<ET, ElementType>::value && std::is_const<ET>::value,
      const void>::type, Space>() const {
    using ptr_t = typename detail::PtrValueType<const void, Space>::type *;
    return multi_ptr<const void, Space>(reinterpret_cast<ptr_t>(m_Pointer));
  }


  operator multi_ptr<const ElementType, Space>() const {
    using ptr_t =
        typename detail::PtrValueType<const ElementType, Space>::type *;
    return multi_ptr<const ElementType, Space>(
        reinterpret_cast<ptr_t>(m_Pointer));
  }


  multi_ptr &operator++() {
    m_Pointer += (difference_type)1;
    return *this;
  }
  multi_ptr operator++(int) {
    multi_ptr result(*this);
    ++(*this);
    return result;
  }
  multi_ptr &operator--() {
    m_Pointer -= (difference_type)1;
    return *this;
  }
  multi_ptr operator--(int) {
    multi_ptr result(*this);
    --(*this);
    return result;
  }
  multi_ptr &operator+=(difference_type r) {
    m_Pointer += r;
    return *this;
  }
  multi_ptr &operator-=(difference_type r) {
    m_Pointer -= r;
    return *this;
  }
  multi_ptr operator+(difference_type r) const {
    return multi_ptr(m_Pointer + r);
  }
  multi_ptr operator-(difference_type r) const {
    return multi_ptr(m_Pointer - r);
  }
# 304 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  template <access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                Space == access::address_space::global_space>::type>
  void prefetch(size_t NumElements) const {
    size_t NumBytes = NumElements * sizeof(ElementType);
    using ptr_t = typename detail::PtrValueType<char, Space>::type const *;
    __spirv_ocl_prefetch(reinterpret_cast<ptr_t>(m_Pointer), NumBytes);
  }

private:
  pointer_t m_Pointer;
};


template <access::address_space Space> class multi_ptr<void, Space> {
public:
  using element_type = void;
  using difference_type = std::ptrdiff_t;



  using pointer_t = typename detail::PtrValueType<void, Space>::type *;
  using const_pointer_t =
      typename detail::PtrValueType<void, Space>::type const *;

  static constexpr access::address_space address_space = Space;


  multi_ptr() : m_Pointer(nullptr) {}
  multi_ptr(const multi_ptr &) = default;
  multi_ptr(multi_ptr &&) = default;
  multi_ptr(pointer_t pointer) : m_Pointer(pointer) {}
# 347 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  multi_ptr(std::nullptr_t) : m_Pointer(nullptr) {}
  ~multi_ptr() = default;





  template <typename ElementType>
  multi_ptr(const multi_ptr<ElementType, Space> &ETP) : m_Pointer(ETP.get()) {}


  multi_ptr &operator=(const multi_ptr &) = default;
  multi_ptr &operator=(multi_ptr &&) = default;
  multi_ptr &operator=(pointer_t pointer) {
    m_Pointer = pointer;
    return *this;
  }
# 372 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  multi_ptr &operator=(std::nullptr_t) {
    m_Pointer = nullptr;
    return *this;
  }


  template <typename ElementType, int dimensions, access::mode Mode,
            typename PropertyListT, access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                (Space == access::address_space::global_space ||
                 Space == access::address_space::global_device_space)>::type>
  multi_ptr(
      accessor<ElementType, dimensions, Mode, access::target::global_buffer,
               access::placeholder::false_t, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <
      typename ElementType, int dimensions, access::mode Mode,
      typename PropertyListT, access::address_space _Space = Space,
      typename = typename std::enable_if<
          _Space == Space && Space == access::address_space::local_space>::type>
  multi_ptr(accessor<ElementType, dimensions, Mode, access::target::local,
                     access::placeholder::false_t, PropertyListT>
                Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <typename ElementType, int dimensions, access::mode Mode,
            typename PropertyListT, access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                Space == access::address_space::constant_space>::type>
  multi_ptr(
      accessor<ElementType, dimensions, Mode, access::target::constant_buffer,
               access::placeholder::false_t, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}

  using ReturnPtr = detail::const_if_const_AS<Space, void> *;

  pointer_t get() const { return m_Pointer; }


  operator ReturnPtr() const { return reinterpret_cast<ReturnPtr>(m_Pointer); };


  template <typename ElementType>
  explicit operator multi_ptr<ElementType, Space>() const {
    using elem_pointer_t =
        typename detail::PtrValueType<ElementType, Space>::type *;
    return multi_ptr<ElementType, Space>(
        static_cast<elem_pointer_t>(m_Pointer));
  }


  operator multi_ptr<const void, Space>() const {
    using ptr_t = typename detail::PtrValueType<const void, Space>::type *;
    return multi_ptr<const void, Space>(reinterpret_cast<ptr_t>(m_Pointer));
  }

private:
  pointer_t m_Pointer;
};


template <access::address_space Space>
class multi_ptr<const void, Space> {
public:
  using element_type = const void;
  using difference_type = std::ptrdiff_t;



  using pointer_t = typename detail::PtrValueType<const void, Space>::type *;
  using const_pointer_t =
      typename detail::PtrValueType<const void, Space>::type const *;

  static constexpr access::address_space address_space = Space;


  multi_ptr() : m_Pointer(nullptr) {}
  multi_ptr(const multi_ptr &) = default;
  multi_ptr(multi_ptr &&) = default;
  multi_ptr(pointer_t pointer) : m_Pointer(pointer) {}
# 469 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  multi_ptr(std::nullptr_t) : m_Pointer(nullptr) {}
  ~multi_ptr() = default;





  template <typename ElementType>
  multi_ptr(const multi_ptr<ElementType, Space> &ETP) : m_Pointer(ETP.get()) {}


  multi_ptr &operator=(const multi_ptr &) = default;
  multi_ptr &operator=(multi_ptr &&) = default;
  multi_ptr &operator=(pointer_t pointer) {
    m_Pointer = pointer;
    return *this;
  }
# 494 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
  multi_ptr &operator=(std::nullptr_t) {
    m_Pointer = nullptr;
    return *this;
  }


  template <typename ElementType, int dimensions, access::mode Mode,
            typename PropertyListT, access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                (Space == access::address_space::global_space ||
                 Space == access::address_space::global_device_space)>::type>
  multi_ptr(
      accessor<ElementType, dimensions, Mode, access::target::global_buffer,
               access::placeholder::false_t, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <
      typename ElementType, int dimensions, access::mode Mode,
      typename PropertyListT, access::address_space _Space = Space,
      typename = typename std::enable_if<
          _Space == Space && Space == access::address_space::local_space>::type>
  multi_ptr(accessor<ElementType, dimensions, Mode, access::target::local,
                     access::placeholder::false_t, PropertyListT>
                Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  template <typename ElementType, int dimensions, access::mode Mode,
            typename PropertyListT, access::address_space _Space = Space,
            typename = typename std::enable_if<
                _Space == Space &&
                Space == access::address_space::constant_space>::type>
  multi_ptr(
      accessor<ElementType, dimensions, Mode, access::target::constant_buffer,
               access::placeholder::false_t, PropertyListT>
          Accessor)
      : multi_ptr(Accessor.get_pointer()) {}


  pointer_t get() const { return m_Pointer; }


  operator const void*() const {
    return reinterpret_cast<const void *>(m_Pointer);
  };




  template <typename ElementType>
  explicit operator multi_ptr<const ElementType, Space>() const {
    using elem_pointer_t =
        typename detail::PtrValueType<const ElementType, Space>::type *;
    return multi_ptr<const ElementType, Space>(
        static_cast<elem_pointer_t>(m_Pointer));
  }

private:
  pointer_t m_Pointer;
};


template <int dimensions, access::mode Mode, access::placeholder isPlaceholder,
          typename PropertyListT, class T>
multi_ptr(accessor<T, dimensions, Mode, access::target::global_buffer,
                   isPlaceholder, PropertyListT>)
    ->multi_ptr<T, access::address_space::global_space>;
template <int dimensions, access::mode Mode, access::placeholder isPlaceholder,
          typename PropertyListT, class T>
multi_ptr(accessor<T, dimensions, Mode, access::target::constant_buffer,
                   isPlaceholder, PropertyListT>)
    ->multi_ptr<T, access::address_space::constant_space>;
template <int dimensions, access::mode Mode, access::placeholder isPlaceholder,
          typename PropertyListT, class T>
multi_ptr(accessor<T, dimensions, Mode, access::target::local, isPlaceholder,
                   PropertyListT>)
    ->multi_ptr<T, access::address_space::local_space>;


template <typename ElementType, access::address_space Space>
multi_ptr<ElementType, Space>
make_ptr(typename multi_ptr<ElementType, Space>::pointer_t pointer) {
  return multi_ptr<ElementType, Space>(pointer);
}
# 599 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/multi_ptr.hpp" 3
template <typename ElementType, access::address_space Space>
bool operator==(const multi_ptr<ElementType, Space> &lhs,
                const multi_ptr<ElementType, Space> &rhs) {
  return lhs.get() == rhs.get();
}

template <typename ElementType, access::address_space Space>
bool operator!=(const multi_ptr<ElementType, Space> &lhs,
                const multi_ptr<ElementType, Space> &rhs) {
  return lhs.get() != rhs.get();
}

template <typename ElementType, access::address_space Space>
bool operator<(const multi_ptr<ElementType, Space> &lhs,
               const multi_ptr<ElementType, Space> &rhs) {
  return lhs.get() < rhs.get();
}

template <typename ElementType, access::address_space Space>
bool operator>(const multi_ptr<ElementType, Space> &lhs,
               const multi_ptr<ElementType, Space> &rhs) {
  return lhs.get() > rhs.get();
}

template <typename ElementType, access::address_space Space>
bool operator<=(const multi_ptr<ElementType, Space> &lhs,
                const multi_ptr<ElementType, Space> &rhs) {
  return lhs.get() <= rhs.get();
}

template <typename ElementType, access::address_space Space>
bool operator>=(const multi_ptr<ElementType, Space> &lhs,
                const multi_ptr<ElementType, Space> &rhs) {
  return lhs.get() >= rhs.get();
}

template <typename ElementType, access::address_space Space>
bool operator!=(const multi_ptr<ElementType, Space> &lhs, std::nullptr_t) {
  return lhs.get() != nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator!=(std::nullptr_t, const multi_ptr<ElementType, Space> &rhs) {
  return rhs.get() != nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator==(const multi_ptr<ElementType, Space> &lhs, std::nullptr_t) {
  return lhs.get() == nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator==(std::nullptr_t, const multi_ptr<ElementType, Space> &rhs) {
  return rhs.get() == nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator>(const multi_ptr<ElementType, Space> &lhs, std::nullptr_t) {
  return lhs.get() != nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator>(std::nullptr_t, const multi_ptr<ElementType, Space> &) {
  return false;
}

template <typename ElementType, access::address_space Space>
bool operator<(const multi_ptr<ElementType, Space> &, std::nullptr_t) {
  return false;
}

template <typename ElementType, access::address_space Space>
bool operator<(std::nullptr_t, const multi_ptr<ElementType, Space> &rhs) {
  return rhs.get() != nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator>=(const multi_ptr<ElementType, Space> &, std::nullptr_t) {
  return true;
}

template <typename ElementType, access::address_space Space>
bool operator>=(std::nullptr_t, const multi_ptr<ElementType, Space> &rhs) {
  return rhs.get() == nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator<=(const multi_ptr<ElementType, Space> &lhs, std::nullptr_t) {
  return lhs.get() == nullptr;
}

template <typename ElementType, access::address_space Space>
bool operator<=(std::nullptr_t, const multi_ptr<ElementType, Space> &rhs) {
  return rhs.get() == nullptr;
}

}
}
# 56 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
# 59 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 3
# 60 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cfenv" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cfenv" 3








# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/fenv.h" 1 3
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/fenv.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fenv.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fenv.h" 3



# 1 "/usr/include/fenv.h" 1 3 4
# 26 "/usr/include/fenv.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/fenv.h" 2 3 4
# 64 "/usr/include/fenv.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fenv.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/fenv.h" 3 4
enum
  {
    FE_INVALID =

      0x01,
    __FE_DENORM = 0x02,
    FE_DIVBYZERO =

      0x04,
    FE_OVERFLOW =

      0x08,
    FE_UNDERFLOW =

      0x10,
    FE_INEXACT =

      0x20
  };







enum
  {
    FE_TONEAREST =

      0,
    FE_DOWNWARD =

      0x400,
    FE_UPWARD =

      0x800,
    FE_TOWARDZERO =

      0xc00
  };



typedef unsigned short int fexcept_t;






typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved1;
    unsigned short int __status_word;
    unsigned short int __glibc_reserved2;
    unsigned short int __tags;
    unsigned short int __glibc_reserved3;
    unsigned int __eip;
    unsigned short int __cs_selector;
    unsigned int __opcode:11;
    unsigned int __glibc_reserved4:5;
    unsigned int __data_offset;
    unsigned short int __data_selector;
    unsigned short int __glibc_reserved5;

    unsigned int __mxcsr;

  }
fenv_t;
# 106 "/usr/include/x86_64-linux-gnu/bits/fenv.h" 3 4
typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __glibc_reserved;
    unsigned int __mxcsr;
  }
femode_t;







extern "C" {



extern int __feraiseexcept_renamed (int) throw () __asm__ ("" "feraiseexcept");

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void
 __feraiseexcept_invalid_divbyzero (int __excepts) throw ()
{
  if ((0x01 & __excepts) != 0)
    {

      float __f = 0.0;


      __asm__ __volatile__ ("divss %0, %0 " : : "x" (__f));




      (void) &__f;
    }
  if ((0x04 & __excepts) != 0)
    {
      float __f = 1.0;
      float __g = 0.0;


      __asm__ __volatile__ ("divss %1, %0" : : "x" (__f), "x" (__g));




      (void) &__f;
    }
}
extern __inline __attribute__ ((__gnu_inline__)) int
 feraiseexcept (int __excepts) throw ()
{
  if (__builtin_constant_p (__excepts)
      && (__excepts & ~(0x01 | 0x04)) == 0)
    {
      __feraiseexcept_invalid_divbyzero (__excepts);
      return 0;
    }

  return __feraiseexcept_renamed (__excepts);
}

}
# 65 "/usr/include/fenv.h" 2 3 4

extern "C" {




extern int feclearexcept (int __excepts) throw ();



extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) throw ();


extern int feraiseexcept (int __excepts) throw ();




extern int fesetexcept (int __excepts) throw ();




extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) throw ();



extern int fetestexcept (int __excepts) throw ();




extern int fetestexceptflag (const fexcept_t *__flagp, int __excepts) throw ();






extern int fegetround (void) throw () __attribute__ ((__pure__));


extern int fesetround (int __rounding_direction) throw ();






extern int fegetenv (fenv_t *__envp) throw ();




extern int feholdexcept (fenv_t *__envp) throw ();



extern int fesetenv (const fenv_t *__envp) throw ();




extern int feupdateenv (const fenv_t *__envp) throw ();







extern int fegetmode (femode_t *__modep) throw ();



extern int fesetmode (const femode_t *__modep) throw ();





# 1 "/usr/include/x86_64-linux-gnu/bits/fenvinline.h" 1 3 4
# 146 "/usr/include/fenv.h" 2 3 4
# 161 "/usr/include/fenv.h" 3 4
extern int feenableexcept (int __excepts) throw ();




extern int fedisableexcept (int __excepts) throw ();


extern int fegetexcept (void) throw ();


}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fenv.h" 2 3
# 55 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/fenv.h" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/fenv.h" 2 3





extern "C" {
# 44 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../compiler/include/fenv.h" 3
}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cfenv" 2 3
# 58 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cfenv" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 62 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 2 3





inline namespace cl {
namespace sycl {

enum class rounding_mode { automatic, rte, rtz, rtp, rtn };
struct elem {
  static constexpr int x = 0;
  static constexpr int y = 1;
  static constexpr int z = 2;
  static constexpr int w = 3;
  static constexpr int r = 0;
  static constexpr int g = 1;
  static constexpr int b = 2;
  static constexpr int a = 3;
  static constexpr int s0 = 0;
  static constexpr int s1 = 1;
  static constexpr int s2 = 2;
  static constexpr int s3 = 3;
  static constexpr int s4 = 4;
  static constexpr int s5 = 5;
  static constexpr int s6 = 6;
  static constexpr int s7 = 7;
  static constexpr int s8 = 8;
  static constexpr int s9 = 9;
  static constexpr int sA = 10;
  static constexpr int sB = 11;
  static constexpr int sC = 12;
  static constexpr int sD = 13;
  static constexpr int sE = 14;
  static constexpr int sF = 15;
};

namespace detail {

template <typename VecT, typename OperationLeftT, typename OperationRightT,
          template <typename> class OperationCurrentT, int... Indexes>
class SwizzleOp;

template <typename T, int N> class BaseCLTypeConverter;


template <typename DataT>
using rel_t = typename std::conditional<
    sizeof(DataT) == sizeof(cl_char), cl_char,
    typename std::conditional<
        sizeof(DataT) == sizeof(cl_short), cl_short,
        typename std::conditional<
            sizeof(DataT) == sizeof(cl_int), cl_int,
            typename std::conditional<sizeof(DataT) == sizeof(cl_long), cl_long,
                                      bool>::type>::type>::type>::type;



template <typename T> class GetOp {
public:
  using DataT = T;
  DataT getValue(size_t) const { return 0; }
  DataT operator()(DataT, DataT) { return 0; }
};




template <typename T> class GetScalarOp {
public:
  using DataT = T;
  GetScalarOp(DataT Data) : m_Data(Data) {}
  DataT getValue(size_t) const { return m_Data; }

private:
  DataT m_Data;
};

template <typename T> struct EqualTo {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs == Rhs) ? -1 : 0;
  }
};

template <typename T> struct NotEqualTo {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs != Rhs) ? -1 : 0;
  }
};

template <typename T> struct GreaterEqualTo {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs >= Rhs) ? -1 : 0;
  }
};

template <typename T> struct LessEqualTo {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs <= Rhs) ? -1 : 0;
  }
};

template <typename T> struct GreaterThan {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs > Rhs) ? -1 : 0;
  }
};

template <typename T> struct LessThan {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs < Rhs) ? -1 : 0;
  }
};

template <typename T> struct LogicalAnd {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs && Rhs) ? -1 : 0;
  }
};

template <typename T> struct LogicalOr {
  constexpr rel_t<T> operator()(const T &Lhs, const T &Rhs) const {
    return (Lhs || Rhs) ? -1 : 0;
  }
};

template <typename T> struct RShift {
  constexpr T operator()(const T &Lhs, const T &Rhs) const {
    return Lhs >> Rhs;
  }
};

template <typename T> struct LShift {
  constexpr T operator()(const T &Lhs, const T &Rhs) const {
    return Lhs << Rhs;
  }
};

template <typename T, typename R>
using is_int_to_int =
    std::integral_constant<bool, std::is_integral<T>::value &&
                                     std::is_integral<R>::value>;

template <typename T, typename R>
using is_sint_to_sint =
    std::integral_constant<bool, is_sigeninteger<T>::value &&
                                     is_sigeninteger<R>::value>;

template <typename T, typename R>
using is_uint_to_uint =
    std::integral_constant<bool, is_sugeninteger<T>::value &&
                                     is_sugeninteger<R>::value>;

template <typename T, typename R>
using is_sint_to_from_uint = std::integral_constant<
    bool, (is_sugeninteger<T>::value && is_sigeninteger<R>::value) ||
              (is_sigeninteger<T>::value && is_sugeninteger<R>::value)>;

template <typename T, typename R>
using is_sint_to_float =
    std::integral_constant<bool, std::is_integral<T>::value &&
                                     !(std::is_unsigned<T>::value) &&
                                     detail::is_floating_point<R>::value>;

template <typename T, typename R>
using is_uint_to_float =
    std::integral_constant<bool, std::is_unsigned<T>::value &&
                                     detail::is_floating_point<R>::value>;

template <typename T, typename R>
using is_int_to_float =
    std::integral_constant<bool, std::is_integral<T>::value &&
                                     detail::is_floating_point<R>::value>;

template <typename T, typename R>
using is_float_to_int =
    std::integral_constant<bool, detail::is_floating_point<T>::value &&
                                     std::is_integral<R>::value>;

template <typename T, typename R>
using is_float_to_float =
    std::integral_constant<bool, detail::is_floating_point<T>::value &&
                                     detail::is_floating_point<R>::value>;
template <typename T>
using is_standard_type = std::integral_constant<
    bool, detail::is_sgentype<T>::value && !std::is_same<T, long long>::value &&
              !std::is_same<T, unsigned long long>::value>;

template <typename T, typename R, rounding_mode roundingMode, typename OpenCLT,
          typename OpenCLR>
detail::enable_if_t<std::is_same<T, R>::value, R> convertImpl(T Value) {
  return Value;
}





template <typename T, typename R, rounding_mode roundingMode, typename OpenCLT,
          typename OpenCLR>
detail::enable_if_t<!std::is_same<T, R>::value &&
                        (is_int_to_int<T, R>::value ||
                         is_int_to_float<T, R>::value ||
                         is_float_to_float<T, R>::value),
                    R>
convertImpl(T Value) {
  return static_cast<R>(Value);
}


template <typename T, typename R, rounding_mode roundingMode, typename OpenCLT,
          typename OpenCLR>
detail::enable_if_t<is_float_to_int<T, R>::value, R> convertImpl(T Value) {
  switch (roundingMode) {

  case rounding_mode::automatic:

  case rounding_mode::rte: {
    int OldRoundingDirection = std::fegetround();
    int Err = std::fesetround(0);
    if (Err)
      throw runtime_error("Unable to set rounding mode to FE_TONEAREST",
                          PI_ERROR_UNKNOWN);
    R Result = std::rint(Value);
    Err = std::fesetround(OldRoundingDirection);
    if (Err)
      throw runtime_error("Unable to restore rounding mode.", PI_ERROR_UNKNOWN);
    return Result;
  }

  case rounding_mode::rtz:
    return std::trunc(Value);

  case rounding_mode::rtp:
    return std::ceil(Value);

  case rounding_mode::rtn:
    return std::floor(Value);
  default:
    (static_cast <bool> (!"Unsupported rounding mode!") ? void (0) : __assert_fail ("!\"Unsupported rounding mode!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp", 300, __extension__ __PRETTY_FUNCTION__));
    return static_cast<R>(Value);
  };
}
# 507 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
}
# 532 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
template <typename Type, int NumElements> class vec {
  using DataT = Type;



  using DataType =
      typename detail::BaseCLTypeConverter<DataT, NumElements>::DataType;

  static constexpr int getNumElements() { return NumElements; }


  template <int Counter, int MaxValue, class...>
  struct SizeChecker: detail::conditional_t<Counter == MaxValue,
      std::true_type, std::false_type> {};

  template <int Counter, int MaxValue, typename DataT_, class... tail>
  struct SizeChecker<Counter, MaxValue, DataT_, tail...>
      : detail::conditional_t<Counter + 1 <= MaxValue,
                      SizeChecker<Counter + 1, MaxValue, tail...>,
                      std::false_type> {};
# 583 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <int Counter, int MaxValue, typename DataT_, class... tail> struct SizeChecker<Counter, MaxValue, vec<DataT_, 1>, tail...> : detail::conditional_t< Counter + (1) <= MaxValue, SizeChecker<Counter + (1), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<vec<DataT_, 1>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<const vec<DataT_, 1>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {};
  template <int Counter, int MaxValue, typename DataT_, class... tail> struct SizeChecker<Counter, MaxValue, vec<DataT_, 2>, tail...> : detail::conditional_t< Counter + (2) <= MaxValue, SizeChecker<Counter + (2), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<vec<DataT_, 2>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<const vec<DataT_, 2>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {};
  template <int Counter, int MaxValue, typename DataT_, class... tail> struct SizeChecker<Counter, MaxValue, vec<DataT_, 3>, tail...> : detail::conditional_t< Counter + (3) <= MaxValue, SizeChecker<Counter + (3), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<vec<DataT_, 3>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<const vec<DataT_, 3>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {};
  template <int Counter, int MaxValue, typename DataT_, class... tail> struct SizeChecker<Counter, MaxValue, vec<DataT_, 4>, tail...> : detail::conditional_t< Counter + (4) <= MaxValue, SizeChecker<Counter + (4), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<vec<DataT_, 4>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<const vec<DataT_, 4>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {};
  template <int Counter, int MaxValue, typename DataT_, class... tail> struct SizeChecker<Counter, MaxValue, vec<DataT_, 8>, tail...> : detail::conditional_t< Counter + (8) <= MaxValue, SizeChecker<Counter + (8), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<vec<DataT_, 8>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<const vec<DataT_, 8>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {};
  template <int Counter, int MaxValue, typename DataT_, class... tail> struct SizeChecker<Counter, MaxValue, vec<DataT_, 16>, tail...> : detail::conditional_t< Counter + (16) <= MaxValue, SizeChecker<Counter + (16), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<vec<DataT_, 16>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {}; template <int Counter, int MaxValue, typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5, class... tail> struct SizeChecker< Counter, MaxValue, detail::SwizzleOp<const vec<DataT_, 16>, T2, T3, T4, T5...>, tail...> : detail::conditional_t< Counter + sizeof...(T5) <= MaxValue, SizeChecker<Counter + sizeof...(T5), MaxValue, tail...>, std::false_type> {};


  template <class...> struct conjunction : std::true_type {};
  template <class B1, class... tail>
  struct conjunction<B1, tail...>
      : detail::conditional_t<bool(B1::value), conjunction<tail...>, B1> {};


  template <typename T, typename DataT_>
  struct TypeChecker : std::is_convertible<T, DataT_> {};
# 613 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <typename DataT_> struct TypeChecker<vec<DataT_, 1>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<vec<DataT_, 1>, T2, T3, T4, T5...>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<const vec<DataT_, 1>, T2, T3, T4, T5...>, DataT_> : std::true_type {};
  template <typename DataT_> struct TypeChecker<vec<DataT_, 2>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<vec<DataT_, 2>, T2, T3, T4, T5...>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<const vec<DataT_, 2>, T2, T3, T4, T5...>, DataT_> : std::true_type {};
  template <typename DataT_> struct TypeChecker<vec<DataT_, 3>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<vec<DataT_, 3>, T2, T3, T4, T5...>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<const vec<DataT_, 3>, T2, T3, T4, T5...>, DataT_> : std::true_type {};
  template <typename DataT_> struct TypeChecker<vec<DataT_, 4>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<vec<DataT_, 4>, T2, T3, T4, T5...>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<const vec<DataT_, 4>, T2, T3, T4, T5...>, DataT_> : std::true_type {};
  template <typename DataT_> struct TypeChecker<vec<DataT_, 8>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<vec<DataT_, 8>, T2, T3, T4, T5...>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<const vec<DataT_, 8>, T2, T3, T4, T5...>, DataT_> : std::true_type {};
  template <typename DataT_> struct TypeChecker<vec<DataT_, 16>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<vec<DataT_, 16>, T2, T3, T4, T5...>, DataT_> : std::true_type {}; template <typename DataT_, typename T2, typename T3, template <typename> class T4, int... T5> struct TypeChecker< detail::SwizzleOp<const vec<DataT_, 16>, T2, T3, T4, T5...>, DataT_> : std::true_type {};


  template <int... Indexes>
  using Swizzle =
      detail::SwizzleOp<vec, detail::GetOp<DataT>, detail::GetOp<DataT>,
                        detail::GetOp, Indexes...>;

  template <int... Indexes>
  using ConstSwizzle =
      detail::SwizzleOp<const vec, detail::GetOp<DataT>, detail::GetOp<DataT>,
                        detail::GetOp, Indexes...>;


  template <typename... argTN>
  using EnableIfSuitableTypes = typename std::enable_if<
      conjunction<TypeChecker<argTN, DataT>...>::value>::type;

  template <typename... argTN>
  using EnableIfSuitableNumElements = typename std::enable_if<
      SizeChecker<0, NumElements, argTN...>::value>::type;

public:
  using element_type = DataT;
  using rel_t = detail::rel_t<DataT>;





  vec() = default;






  vec(const vec &Rhs) : m_Data(Rhs.m_Data) {}


  vec(vec &&Rhs) = default;

  vec &operator=(const vec &Rhs) = default;


  template <typename Ty = DataT>
  typename std::enable_if<!std::is_same<Ty, rel_t>::value &&
                              std::is_convertible<Ty, rel_t>::value,
                          vec &>::type
  operator=(const vec<rel_t, NumElements> &Rhs) {
    *this = Rhs.template as<vec>();
    return *this;
  }


  template <typename T = void>
  using EnableIfNotHostHalf = typename std::enable_if<
      !std::is_same<DataT, cl::sycl::detail::half_impl::half>::value ||
          !std::is_same<cl::sycl::detail::half_impl::StorageT,
                            cl::sycl::detail::host_half_impl::half>::value,
      T>::type;
  template <typename T = void>
  using EnableIfHostHalf = typename std::enable_if<
      std::is_same<DataT, cl::sycl::detail::half_impl::half>::value &&
          std::is_same<cl::sycl::detail::half_impl::StorageT,
                       cl::sycl::detail::host_half_impl::half>::value,
      T>::type;

  template <typename Ty = DataT>
  explicit vec(const EnableIfNotHostHalf<Ty> &arg) {
    m_Data = (DataType)arg;
  }

  template <typename Ty = DataT>
  typename std::enable_if<
      std::is_fundamental<Ty>::value ||
          std::is_same<typename std::remove_const<Ty>::type, half>::value,
      vec &>::type
  operator=(const EnableIfNotHostHalf<Ty> &Rhs) {
    m_Data = (DataType)Rhs;
    return *this;
  }

  template <typename Ty = DataT> explicit vec(const EnableIfHostHalf<Ty> &arg) {
    for (int i = 0; i < NumElements; ++i) {
      setValue(i, arg);
    }
  }

  template <typename Ty = DataT>
  typename std::enable_if<
      std::is_fundamental<Ty>::value ||
          std::is_same<typename std::remove_const<Ty>::type, half>::value,
      vec &>::type
  operator=(const EnableIfHostHalf<Ty> &Rhs) {
    for (int i = 0; i < NumElements; ++i) {
      setValue(i, Rhs);
    }
    return *this;
  }
# 744 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <int IdxNum, typename T = void>
  using EnableIfMultipleElems = typename std::enable_if<
      std::is_convertible<T, DataT>::value && NumElements == IdxNum,
      DataT>::type;
  template <typename Ty = DataT>
  vec(const EnableIfMultipleElems<2, Ty> Arg0,
      const EnableIfNotHostHalf<Ty> Arg1)
      : m_Data{Arg0, Arg1} {}
  template <typename Ty = DataT>
  vec(const EnableIfMultipleElems<3, Ty> Arg0,
      const EnableIfNotHostHalf<Ty> Arg1, const DataT Arg2)
      : m_Data{Arg0, Arg1, Arg2} {}
  template <typename Ty = DataT>
  vec(const EnableIfMultipleElems<4, Ty> Arg0,
      const EnableIfNotHostHalf<Ty> Arg1, const DataT Arg2, const Ty Arg3)
      : m_Data{Arg0, Arg1, Arg2, Arg3} {}
  template <typename Ty = DataT>
  vec(const EnableIfMultipleElems<8, Ty> Arg0,
      const EnableIfNotHostHalf<Ty> Arg1, const DataT Arg2, const DataT Arg3,
      const DataT Arg4, const DataT Arg5, const DataT Arg6, const DataT Arg7)
      : m_Data{Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7} {}
  template <typename Ty = DataT>
  vec(const EnableIfMultipleElems<16, Ty> Arg0,
      const EnableIfNotHostHalf<Ty> Arg1, const DataT Arg2, const DataT Arg3,
      const DataT Arg4, const DataT Arg5, const DataT Arg6, const DataT Arg7,
      const DataT Arg8, const DataT Arg9, const DataT ArgA, const DataT ArgB,
      const DataT ArgC, const DataT ArgD, const DataT ArgE, const DataT ArgF)
      : m_Data{Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
               Arg8, Arg9, ArgA, ArgB, ArgC, ArgD, ArgE, ArgF} {}




  template <typename... argTN, typename = EnableIfSuitableTypes<argTN...>,
            typename = EnableIfSuitableNumElements<argTN...>>
  vec(const argTN &... args) {
    vaargCtorHelper(0, args...);
  }


  void dump() {

    for (int I = 0; I < NumElements; ++I) {
      std::cout << "  " << I << ": " << getValue(I) << std::endl;
    }
    std::cout << std::endl;

  }
# 803 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <int N = NumElements>
  operator typename std::enable_if<N == 1, DataT>::type() const {
    return m_Data;
  }
  static constexpr size_t get_count() { return NumElements; }
  static constexpr size_t get_size() { return sizeof(m_Data); }

  template <typename convertT,
            rounding_mode roundingMode = rounding_mode::automatic>
  vec<convertT, NumElements> convert() const {
    static_assert(std::is_integral<convertT>::value ||
                      detail::is_floating_point<convertT>::value,
                  "Unsupported convertT");
    vec<convertT, NumElements> Result;
    using OpenCLT = detail::ConvertToOpenCLType_t<DataT>;
    using OpenCLR = detail::ConvertToOpenCLType_t<convertT>;
    for (size_t I = 0; I < NumElements; ++I) {
      Result.setValue(
          I,
          detail::convertImpl<DataT, convertT, roundingMode, OpenCLT, OpenCLR>(
              getValue(I)));
    }
    return Result;
  }

  template <typename asT> asT as() const {
    static_assert((sizeof(*this) == sizeof(asT)),
                  "The new SYCL vec type must have the same storage size in "
                  "bytes as this SYCL vec");
    static_assert(
        detail::is_contained<asT, detail::gtl::vector_basic_list>::value,
        "asT must be SYCL vec of a different element type and "
        "number of elements specified by asT");
    asT Result;
    detail::memcpy(&Result.m_Data, &m_Data, sizeof(decltype(Result.m_Data)));
    return Result;
  }

  template <int... SwizzleIndexes> Swizzle<SwizzleIndexes...> swizzle() {
    return this;
  }

  template <int... SwizzleIndexes>
  ConstSwizzle<SwizzleIndexes...> swizzle() const {
    return this;
  }
# 862 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  const DataT &operator[](int i) const {
    return reinterpret_cast<const DataT *>(&m_Data)[i];
  }

  DataT &operator[](int i) { return reinterpret_cast<DataT *>(&m_Data)[i]; }


private:





  template <int Index>
  struct Indexer {
    static constexpr int value = Index;
  };

public:





# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/swizzles.def" 1 3
# 78 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/swizzles.def" 3
template <int N = getNumElements()> typename std::enable_if<(N <= 4), DataT &>::type x() { return (*this)[0]; } template <int N = getNumElements()> typename std::enable_if<(N <= 4), const DataT &>::type x() const { return (*this)[0]; }
template <int N = getNumElements()> typename std::enable_if<(N == 2 || N == 3 || N == 4), DataT &>::type y() { return (*this)[1]; } template <int N = getNumElements()> typename std::enable_if<(N == 2 || N == 3 || N == 4), const DataT &>::type y() const { return (*this)[1]; }
template <int N = getNumElements()> typename std::enable_if<(N == 3 || N == 4), DataT &>::type z() { return (*this)[2]; } template <int N = getNumElements()> typename std::enable_if<(N == 3 || N == 4), const DataT &>::type z() const { return (*this)[2]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type w() { return (*this)[3]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type w() const { return (*this)[3]; }


template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type r() { return (*this)[0]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type r() const { return (*this)[0]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type g() { return (*this)[1]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type g() const { return (*this)[1]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type b() { return (*this)[2]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type b() const { return (*this)[2]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type a() { return (*this)[3]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type a() const { return (*this)[3]; }


template <int N = getNumElements()> typename std::enable_if<(N > 0), DataT &>::type s0() { return (*this)[0]; } template <int N = getNumElements()> typename std::enable_if<(N > 0), const DataT &>::type s0() const { return (*this)[0]; }
template <int N = getNumElements()> typename std::enable_if<(N > 1), DataT &>::type s1() { return (*this)[1]; } template <int N = getNumElements()> typename std::enable_if<(N > 1), const DataT &>::type s1() const { return (*this)[1]; }
template <int N = getNumElements()> typename std::enable_if<(N > 2), DataT &>::type s2() { return (*this)[2]; } template <int N = getNumElements()> typename std::enable_if<(N > 2), const DataT &>::type s2() const { return (*this)[2]; }
template <int N = getNumElements()> typename std::enable_if<(N > 2), DataT &>::type s3() { return (*this)[3]; } template <int N = getNumElements()> typename std::enable_if<(N > 2), const DataT &>::type s3() const { return (*this)[3]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s4() { return (*this)[4]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s4() const { return (*this)[4]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s5() { return (*this)[5]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s5() const { return (*this)[5]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s6() { return (*this)[6]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s6() const { return (*this)[6]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s7() { return (*this)[7]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s7() const { return (*this)[7]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type s8() { return (*this)[8]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type s8() const { return (*this)[8]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type s9() { return (*this)[9]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type s9() const { return (*this)[9]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sA() { return (*this)[10]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sA() const { return (*this)[10]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sB() { return (*this)[11]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sB() const { return (*this)[11]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sC() { return (*this)[12]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sC() const { return (*this)[12]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sD() { return (*this)[13]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sD() const { return (*this)[13]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sE() { return (*this)[14]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sE() const { return (*this)[14]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sF() { return (*this)[15]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sF() const { return (*this)[15]; }
# 787 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/swizzles.def" 3
template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<0>::value>>::type lo() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<0>::value>>::type lo() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value>>::type lo() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value>>::type lo() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value, Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type lo() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value, Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type lo() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<1>::value>>::type hi() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<1>::value>>::type hi() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type hi() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type hi() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<8>::value, Indexer<9>::value, Indexer<10>::value, Indexer<11>::value, Indexer<12>::value, Indexer<13>::value, Indexer<14>::value, Indexer<15>::value>>::type hi() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<8>::value, Indexer<9>::value, Indexer<10>::value, Indexer<11>::value, Indexer<12>::value, Indexer<13>::value, Indexer<14>::value, Indexer<15>::value>>::type hi() const { return this; }

template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<1>::value>>::type odd() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<1>::value>>::type odd() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value>>::type odd() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value>>::type odd() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value, Indexer<9>::value, Indexer<11>::value, Indexer<13>::value, Indexer<15>::value>>::type odd() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value, Indexer<9>::value, Indexer<11>::value, Indexer<13>::value, Indexer<15>::value>>::type odd() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<0>::value>>::type even() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<0>::value>>::type even() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<0>::value, Indexer<2>::value>>::type even() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<0>::value, Indexer<2>::value>>::type even() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<0>::value, Indexer<2>::value>>::type even() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<0>::value, Indexer<2>::value>>::type even() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value>>::type even() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value>>::type even() const { return this; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value, Indexer<8>::value, Indexer<10>::value, Indexer<12>::value, Indexer<14>::value>>::type even() { return this; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value, Indexer<8>::value, Indexer<10>::value, Indexer<12>::value, Indexer<14>::value>>::type even() const { return this; }
# 886 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 2 3



  template <access::address_space Space>
  void load(size_t Offset, multi_ptr<const DataT, Space> Ptr) {
    for (int I = 0; I < NumElements; I++) {
      setValue(I,
               *multi_ptr<const DataT, Space>(Ptr + Offset * NumElements + I));
    }
  }
  template <access::address_space Space>
  void load(size_t Offset, multi_ptr<DataT, Space> Ptr) {
    multi_ptr<const DataT, Space> ConstPtr(Ptr);
    load(Offset, ConstPtr);
  }
  template <int Dimensions, access::mode Mode,
            access::placeholder IsPlaceholder, access::target Target,
            typename PropertyListT>
  void
  load(size_t Offset,
       accessor<DataT, Dimensions, Mode, Target, IsPlaceholder, PropertyListT>
           Acc) {
    multi_ptr<const DataT, detail::TargetToAS<Target>::AS> MultiPtr(Acc);
    load(Offset, MultiPtr);
  }
  template <access::address_space Space>
  void store(size_t Offset, multi_ptr<DataT, Space> Ptr) const {
    for (int I = 0; I < NumElements; I++) {
      *multi_ptr<DataT, Space>(Ptr + Offset * NumElements + I) = getValue(I);
    }
  }
  template <int Dimensions, access::mode Mode,
            access::placeholder IsPlaceholder, access::target Target,
            typename PropertyListT>
  void
  store(size_t Offset,
        accessor<DataT, Dimensions, Mode, Target, IsPlaceholder, PropertyListT>
            Acc) {
    multi_ptr<DataT, detail::TargetToAS<Target>::AS> MultiPtr(Acc);
    store(Offset, MultiPtr);
  }
# 997 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <typename Ty = vec> vec operator +(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data + Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator +(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) + Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator +(const T &Rhs) const { return *this + vec(static_cast<const DataT &>(Rhs)); } vec &operator +=(const vec &Rhs) { *this = *this + Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator +=(const DataT &Rhs) { *this = *this + vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator -(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data - Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator -(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) - Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator -(const T &Rhs) const { return *this - vec(static_cast<const DataT &>(Rhs)); } vec &operator -=(const vec &Rhs) { *this = *this - Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator -=(const DataT &Rhs) { *this = *this - vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator *(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data * Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator *(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) * Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator *(const T &Rhs) const { return *this * vec(static_cast<const DataT &>(Rhs)); } vec &operator *=(const vec &Rhs) { *this = *this * Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator *=(const DataT &Rhs) { *this = *this * vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator /(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data / Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator /(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) / Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator /(const T &Rhs) const { return *this / vec(static_cast<const DataT &>(Rhs)); } vec &operator /=(const vec &Rhs) { *this = *this / Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator /=(const DataT &Rhs) { *this = *this / vec(Rhs); return *this; }



  template <typename Ty = vec> vec operator %(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data % Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator %(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) % Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator %(const T &Rhs) const { return *this % vec(static_cast<const DataT &>(Rhs)); } vec &operator %=(const vec &Rhs) { *this = *this % Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator %=(const DataT &Rhs) { *this = *this % vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator |(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data | Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator |(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) | Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator |(const T &Rhs) const { return *this | vec(static_cast<const DataT &>(Rhs)); } vec &operator |=(const vec &Rhs) { *this = *this | Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator |=(const DataT &Rhs) { *this = *this | vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator &(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data & Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator &(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) & Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator &(const T &Rhs) const { return *this & vec(static_cast<const DataT &>(Rhs)); } vec &operator &=(const vec &Rhs) { *this = *this & Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator &=(const DataT &Rhs) { *this = *this & vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator ^(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data ^ Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator ^(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) ^ Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator ^(const T &Rhs) const { return *this ^ vec(static_cast<const DataT &>(Rhs)); } vec &operator ^=(const vec &Rhs) { *this = *this ^ Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator ^=(const DataT &Rhs) { *this = *this ^ vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator >>(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data >> Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator >>(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) >> Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator >>(const T &Rhs) const { return *this >> vec(static_cast<const DataT &>(Rhs)); } vec &operator >>=(const vec &Rhs) { *this = *this >> Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator >>=(const DataT &Rhs) { *this = *this >> vec(Rhs); return *this; }
  template <typename Ty = vec> vec operator <<(const EnableIfNotHostHalf<Ty> &Rhs) const { vec Ret; Ret.m_Data = m_Data << Rhs.m_Data; return Ret; } template <typename Ty = vec> vec operator <<(const EnableIfHostHalf<Ty> &Rhs) const { vec Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, (getValue(I) << Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if< std::is_convertible<DataT, T>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec>::type operator <<(const T &Rhs) const { return *this << vec(static_cast<const DataT &>(Rhs)); } vec &operator <<=(const vec &Rhs) { *this = *this << Rhs; return *this; } template <int Num = NumElements> typename std::enable_if<Num != 1, vec &>::type operator <<=(const DataT &Rhs) { *this = *this << vec(Rhs); return *this; }
# 1062 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  vec<rel_t, NumElements> operator ==(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) == Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator ==(const T &Rhs) const { return *this == vec(static_cast<const DataT &>(Rhs)); }
  vec<rel_t, NumElements> operator !=(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) != Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator !=(const T &Rhs) const { return *this != vec(static_cast<const DataT &>(Rhs)); }
  vec<rel_t, NumElements> operator >(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) > Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator >(const T &Rhs) const { return *this > vec(static_cast<const DataT &>(Rhs)); }
  vec<rel_t, NumElements> operator <(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) < Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator <(const T &Rhs) const { return *this < vec(static_cast<const DataT &>(Rhs)); }
  vec<rel_t, NumElements> operator >=(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) >= Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator >=(const T &Rhs) const { return *this >= vec(static_cast<const DataT &>(Rhs)); }
  vec<rel_t, NumElements> operator <=(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) <= Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator <=(const T &Rhs) const { return *this <= vec(static_cast<const DataT &>(Rhs)); }

  vec<rel_t, NumElements> operator &&(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) && Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator &&(const T &Rhs) const { return *this && vec(static_cast<const DataT &>(Rhs)); }
  vec<rel_t, NumElements> operator ||(const vec &Rhs) const { vec<rel_t, NumElements> Ret; for (size_t I = 0; I < NumElements; ++I) { Ret.setValue(I, -(getValue(I) || Rhs.getValue(I))); } return Ret; } template <typename T> typename std::enable_if<std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<T, half>::value), vec<rel_t, NumElements>>::type operator ||(const T &Rhs) const { return *this || vec(static_cast<const DataT &>(Rhs)); }
# 1087 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  vec &operator ++() { *this += 1; return *this; } vec operator ++(int) { vec Ret(*this); *this += 1; return Ret; }
  vec &operator --() { *this -= 1; return *this; } vec operator --(int) { vec Ret(*this); *this -= 1; return Ret; }




  template <typename T = DataT>
  typename std::enable_if<std::is_integral<T>::value, vec>::type
  operator~() const {






    vec Ret;
    for (size_t I = 0; I < NumElements; ++I) {
      Ret.setValue(I, ~getValue(I));
    }
    return Ret;

  }

  vec<rel_t, NumElements> operator!() const {






    vec<rel_t, NumElements> Ret;
    for (size_t I = 0; I < NumElements; ++I) {
      Ret.setValue(I, !getValue(I));
    }
    return Ret;

  }

  vec operator+() const {





    vec Ret;
    for (size_t I = 0; I < NumElements; ++I)
      Ret.setValue(I, +getValue(I));
    return Ret;

  }

  vec operator-() const {





    vec Ret;
    for (size_t I = 0; I < NumElements; ++I)
      Ret.setValue(I, -getValue(I));
    return Ret;

  }
# 1158 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
private:


  template <template <typename> class Operation,
            typename Ty = vec<DataT, NumElements>>
  vec<DataT, NumElements>
  operatorHelper(const EnableIfNotHostHalf<Ty> &Rhs) const {
    vec<DataT, NumElements> Result;
    Operation<DataType> Op;
    Result.m_Data = Op(m_Data, Rhs.m_Data);
    return Result;
  }

  template <template <typename> class Operation,
            typename Ty = vec<DataT, NumElements>>
  vec<DataT, NumElements>
  operatorHelper(const EnableIfHostHalf<Ty> &Rhs) const {
    vec<DataT, NumElements> Result;
    Operation<DataT> Op;
    for (size_t I = 0; I < NumElements; ++I) {
      Result.setValue(I, Op(Rhs.getValue(I), getValue(I)));
    }
    return Result;
  }
# 1198 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <int Num = NumElements, typename Ty = int,
            typename = typename std::enable_if<1 != Num>::type>
  void setValue(EnableIfNotHostHalf<Ty> Index, const DataT &Value, int) {
    m_Data[Index] = Value;
  }

  template <int Num = NumElements, typename Ty = int,
            typename = typename std::enable_if<1 != Num>::type>
  DataT getValue(EnableIfNotHostHalf<Ty> Index, int) const {
    return m_Data[Index];
  }

  template <int Num = NumElements, typename Ty = int,
            typename = typename std::enable_if<1 != Num>::type>
  void setValue(EnableIfHostHalf<Ty> Index, const DataT &Value, int) {
    m_Data.s[Index] = Value;
  }

  template <int Num = NumElements, typename Ty = int,
            typename = typename std::enable_if<1 != Num>::type>
  DataT getValue(EnableIfHostHalf<Ty> Index, int) const {
    return m_Data.s[Index];
  }
# 1235 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  template <int Num = NumElements,
            typename = typename std::enable_if<1 == Num>::type>
  void setValue(int, const DataT &Value, float) {
    m_Data = Value;
  }

  template <int Num = NumElements,
            typename = typename std::enable_if<1 == Num>::type>
  DataT getValue(int, float) const {
    return m_Data;
  }


  void setValue(int Index, const DataT &Value) {
    if (NumElements == 1)
      setValue(Index, Value, 0);
    else
      setValue(Index, Value, 0.f);
  }

  DataT getValue(int Index) const {
    return (NumElements == 1) ? getValue(Index, 0) : getValue(Index, 0.f);
  }


  template <typename T, typename... argTN>
  int vaargCtorHelper(int Idx, const T &arg) {
    setValue(Idx, arg);
    return Idx + 1;
  }

  template <typename DataT_, int NumElements_>
  int vaargCtorHelper(int Idx, const vec<DataT_, NumElements_> &arg) {
    for (size_t I = 0; I < NumElements_; ++I) {
      setValue(Idx + I, arg.getValue(I));
    }
    return Idx + NumElements_;
  }

  template <typename DataT_, int NumElements_, typename T2, typename T3,
            template <typename> class T4, int... T5>
  int vaargCtorHelper(int Idx,
                      const detail::SwizzleOp<vec<DataT_, NumElements_>, T2, T3,
                                              T4, T5...> &arg) {
    size_t NumElems = sizeof...(T5);
    for (size_t I = 0; I < NumElems; ++I) {
      setValue(Idx + I, arg.getValue(I));
    }
    return Idx + NumElems;
  }

  template <typename DataT_, int NumElements_, typename T2, typename T3,
            template <typename> class T4, int... T5>
  int vaargCtorHelper(int Idx,
                      const detail::SwizzleOp<const vec<DataT_, NumElements_>,
                                              T2, T3, T4, T5...> &arg) {
    size_t NumElems = sizeof...(T5);
    for (size_t I = 0; I < NumElems; ++I) {
      setValue(Idx + I, arg.getValue(I));
    }
    return Idx + NumElems;
  }

  template <typename T1, typename... argTN>
  void vaargCtorHelper(int Idx, const T1 &arg, const argTN &... args) {
    int NewIdx = vaargCtorHelper(Idx, arg);
    vaargCtorHelper(NewIdx, args...);
  }

  template <typename DataT_, int NumElements_, typename... argTN>
  void vaargCtorHelper(int Idx, const vec<DataT_, NumElements_> &arg,
                       const argTN &... args) {
    int NewIdx = vaargCtorHelper(Idx, arg);
    vaargCtorHelper(NewIdx, args...);
  }






  alignas((detail::vector_alignment<DataT, NumElements>::value))
      DataType m_Data;


  template <typename T1, typename T2, typename T3, template <typename> class T4,
            int... T5>
  friend class detail::SwizzleOp;
  template <typename T1, int T2> friend class vec;
};



template <class T, class... U,
          class = detail::enable_if_t<(std::is_same<T, U>::value && ...)>>
vec(T, U...)->vec<T, sizeof...(U) + 1>;


namespace detail {



template <typename VecT, typename OperationLeftT, typename OperationRightT,
          template <typename> class OperationCurrentT, int... Indexes>
class SwizzleOp {
  using DataT = typename VecT::element_type;
  using CommonDataT =
      typename std::common_type<typename OperationLeftT::DataT,
                                typename OperationRightT::DataT>::type;
  static constexpr int getNumElements() { return sizeof...(Indexes); }

  using rel_t = detail::rel_t<DataT>;
  using vec_t = vec<DataT, sizeof...(Indexes)>;
  using vec_rel_t = vec<rel_t, sizeof...(Indexes)>;

  template <typename OperationRightT_,
            template <typename> class OperationCurrentT_, int... Idx_>
  using NewLHOp = SwizzleOp<VecT,
                            SwizzleOp<VecT, OperationLeftT, OperationRightT,
                                      OperationCurrentT, Indexes...>,
                            OperationRightT_, OperationCurrentT_, Idx_...>;

  template <typename OperationRightT_,
            template <typename> class OperationCurrentT_, int... Idx_>
  using NewRelOp = SwizzleOp<vec<rel_t, VecT::getNumElements()>,
                             SwizzleOp<VecT, OperationLeftT, OperationRightT,
                                       OperationCurrentT, Indexes...>,
                             OperationRightT_, OperationCurrentT_, Idx_...>;

  template <typename OperationLeftT_,
            template <typename> class OperationCurrentT_, int... Idx_>
  using NewRHOp = SwizzleOp<VecT, OperationLeftT_,
                            SwizzleOp<VecT, OperationLeftT, OperationRightT,
                                      OperationCurrentT, Indexes...>,
                            OperationCurrentT_, Idx_...>;

  template <int IdxNum, typename T = void>
  using EnableIfOneIndex = typename std::enable_if<
      1 == IdxNum && SwizzleOp::getNumElements() == IdxNum, T>::type;

  template <int IdxNum, typename T = void>
  using EnableIfMultipleIndexes = typename std::enable_if<
      1 != IdxNum && SwizzleOp::getNumElements() == IdxNum, T>::type;

  template <typename T>
  using EnableIfScalarType = typename std::enable_if<
      std::is_convertible<DataT, T>::value &&
      (std::is_fundamental<T>::value ||
       std::is_same<typename std::remove_const<T>::type, half>::value)>::type;

  template <typename T>
  using EnableIfNoScalarType = typename std::enable_if<
      !std::is_convertible<DataT, T>::value ||
      !(std::is_fundamental<T>::value ||
        std::is_same<typename std::remove_const<T>::type, half>::value)>::type;

  template <int... Indices>
  using Swizzle =
      SwizzleOp<VecT, GetOp<DataT>, GetOp<DataT>, GetOp, Indices...>;

  template <int... Indices>
  using ConstSwizzle =
      SwizzleOp<const VecT, GetOp<DataT>, GetOp<DataT>, GetOp, Indices...>;

public:
  size_t get_count() const { return getNumElements(); }
  template <int Num = getNumElements()> size_t get_size() const {
    return sizeof(DataT) * (Num == 3 ? 4 : Num);
  }

  template <typename T, int IdxNum = getNumElements(),
            typename = EnableIfOneIndex<IdxNum>,
            typename = EnableIfScalarType<T>>
  operator T() const {
    return getValue(0);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  friend NewRHOp<GetScalarOp<T>, std::multiplies, Indexes...>
  operator*(const T &Lhs, const SwizzleOp &Rhs) {
    return NewRHOp<GetScalarOp<T>, std::multiplies, Indexes...>(
        Rhs.m_Vector, GetScalarOp<T>(Lhs), Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  friend NewRHOp<GetScalarOp<T>, std::plus, Indexes...>
  operator+(const T &Lhs, const SwizzleOp &Rhs) {
    return NewRHOp<GetScalarOp<T>, std::plus, Indexes...>(
        Rhs.m_Vector, GetScalarOp<T>(Lhs), Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  friend NewRHOp<GetScalarOp<T>, std::divides, Indexes...>
  operator/(const T &Lhs, const SwizzleOp &Rhs) {
    return NewRHOp<GetScalarOp<T>, std::divides, Indexes...>(
        Rhs.m_Vector, GetScalarOp<T>(Lhs), Rhs);
  }
# 1448 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  SwizzleOp &operator +=(const DataT &Rhs) { operatorHelper<std::plus>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator +=(const RhsOperation &Rhs) { operatorHelper<std::plus>(Rhs); return *this; }
  SwizzleOp &operator -=(const DataT &Rhs) { operatorHelper<std::minus>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator -=(const RhsOperation &Rhs) { operatorHelper<std::minus>(Rhs); return *this; }
  SwizzleOp &operator *=(const DataT &Rhs) { operatorHelper<std::multiplies>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator *=(const RhsOperation &Rhs) { operatorHelper<std::multiplies>(Rhs); return *this; }
  SwizzleOp &operator /=(const DataT &Rhs) { operatorHelper<std::divides>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator /=(const RhsOperation &Rhs) { operatorHelper<std::divides>(Rhs); return *this; }
  SwizzleOp &operator %=(const DataT &Rhs) { operatorHelper<std::modulus>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator %=(const RhsOperation &Rhs) { operatorHelper<std::modulus>(Rhs); return *this; }
  SwizzleOp &operator &=(const DataT &Rhs) { operatorHelper<std::bit_and>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator &=(const RhsOperation &Rhs) { operatorHelper<std::bit_and>(Rhs); return *this; }
  SwizzleOp &operator |=(const DataT &Rhs) { operatorHelper<std::bit_or>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator |=(const RhsOperation &Rhs) { operatorHelper<std::bit_or>(Rhs); return *this; }
  SwizzleOp &operator ^=(const DataT &Rhs) { operatorHelper<std::bit_xor>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator ^=(const RhsOperation &Rhs) { operatorHelper<std::bit_xor>(Rhs); return *this; }
  SwizzleOp &operator >>=(const DataT &Rhs) { operatorHelper<RShift>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator >>=(const RhsOperation &Rhs) { operatorHelper<RShift>(Rhs); return *this; }
  SwizzleOp &operator <<=(const DataT &Rhs) { operatorHelper<LShift>(vec_t(Rhs)); return *this; } template <typename RhsOperation> SwizzleOp &operator <<=(const RhsOperation &Rhs) { operatorHelper<LShift>(Rhs); return *this; }
# 1474 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
  SwizzleOp &operator ++() { *this += static_cast<DataT>(1); return *this; } vec_t operator ++(int) { vec_t Ret = *this; *this += static_cast<DataT>(1); return Ret; }
  SwizzleOp &operator --() { *this -= static_cast<DataT>(1); return *this; } vec_t operator --(int) { vec_t Ret = *this; *this -= static_cast<DataT>(1); return Ret; }


  template <typename T = DataT>
  typename std::enable_if<std::is_integral<T>::value, vec_t>::type
  operator~() {
    vec_t Tmp = *this;
    return ~Tmp;
  }

  vec_rel_t operator!() {
    vec_t Tmp = *this;
    return !Tmp;
  }

  vec_t operator+() {
    vec_t Tmp = *this;
    return +Tmp;
  }

  vec_t operator-() {
    vec_t Tmp = *this;
    return -Tmp;
  }

  template <int IdxNum = getNumElements(),
            typename = EnableIfMultipleIndexes<IdxNum>>
  SwizzleOp &operator=(const vec<DataT, IdxNum> &Rhs) {
    std::array<int, IdxNum> Idxs{Indexes...};
    for (size_t I = 0; I < Idxs.size(); ++I) {
      m_Vector->setValue(Idxs[I], Rhs.getValue(I));
    }
    return *this;
  }

  template <int IdxNum = getNumElements(), typename = EnableIfOneIndex<IdxNum>>
  SwizzleOp &operator=(const DataT &Rhs) {
    std::array<int, IdxNum> Idxs{Indexes...};
    m_Vector->setValue(Idxs[0], Rhs);
    return *this;
  }

  template <int IdxNum = getNumElements(), typename = EnableIfOneIndex<IdxNum>>
  SwizzleOp &operator=(DataT &&Rhs) {
    std::array<int, IdxNum> Idxs{Indexes...};
    m_Vector->setValue(Idxs[0], Rhs);
    return *this;
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::multiplies, Indexes...>
  operator*(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::multiplies, Indexes...>(
        m_Vector, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::multiplies, Indexes...>
  operator*(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::multiplies, Indexes...>(m_Vector, *this,
                                                              Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::plus, Indexes...> operator+(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::plus, Indexes...>(m_Vector, *this,
                                                          GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::plus, Indexes...>
  operator+(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::plus, Indexes...>(m_Vector, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::minus, Indexes...>
  operator-(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::minus, Indexes...>(m_Vector, *this,
                                                           GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::minus, Indexes...>
  operator-(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::minus, Indexes...>(m_Vector, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::divides, Indexes...>
  operator/(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::divides, Indexes...>(
        m_Vector, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::divides, Indexes...>
  operator/(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::divides, Indexes...>(m_Vector, *this,
                                                           Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::bit_and, Indexes...>
  operator&(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::bit_and, Indexes...>(
        m_Vector, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::bit_and, Indexes...>
  operator&(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::bit_and, Indexes...>(m_Vector, *this,
                                                           Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::bit_or, Indexes...>
  operator|(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::bit_or, Indexes...>(
        m_Vector, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::bit_or, Indexes...>
  operator|(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::bit_or, Indexes...>(m_Vector, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, std::bit_xor, Indexes...>
  operator^(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, std::bit_xor, Indexes...>(
        m_Vector, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, std::bit_xor, Indexes...>
  operator^(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, std::bit_xor, Indexes...>(m_Vector, *this,
                                                           Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, RShift, Indexes...> operator>>(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, RShift, Indexes...>(m_Vector, *this,
                                                       GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, RShift, Indexes...>
  operator>>(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, RShift, Indexes...>(m_Vector, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewLHOp<GetScalarOp<T>, LShift, Indexes...> operator<<(const T &Rhs) const {
    return NewLHOp<GetScalarOp<T>, LShift, Indexes...>(m_Vector, *this,
                                                       GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewLHOp<RhsOperation, LShift, Indexes...>
  operator<<(const RhsOperation &Rhs) const {
    return NewLHOp<RhsOperation, LShift, Indexes...>(m_Vector, *this, Rhs);
  }

  template <typename T1, typename T2, typename T3, template <typename> class T4,
            int... T5,
            typename = typename std::enable_if<sizeof...(T5) ==
                                               getNumElements()>::type>
  SwizzleOp &operator=(const SwizzleOp<T1, T2, T3, T4, T5...> &Rhs) {
    std::array<int, getNumElements()> Idxs{Indexes...};
    for (size_t I = 0; I < Idxs.size(); ++I) {
      m_Vector->setValue(Idxs[I], Rhs.getValue(I));
    }
    return *this;
  }

  template <typename T1, typename T2, typename T3, template <typename> class T4,
            int... T5,
            typename = typename std::enable_if<sizeof...(T5) ==
                                               getNumElements()>::type>
  SwizzleOp &operator=(SwizzleOp<T1, T2, T3, T4, T5...> &&Rhs) {
    std::array<int, getNumElements()> Idxs{Indexes...};
    for (size_t I = 0; I < Idxs.size(); ++I) {
      m_Vector->setValue(Idxs[I], Rhs.getValue(I));
    }
    return *this;
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, EqualTo, Indexes...> operator==(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, EqualTo, Indexes...>(__null, *this,
                                                         GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, EqualTo, Indexes...>
  operator==(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, EqualTo, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, NotEqualTo, Indexes...>
  operator!=(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, NotEqualTo, Indexes...>(
        __null, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, NotEqualTo, Indexes...>
  operator!=(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, NotEqualTo, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, GreaterEqualTo, Indexes...>
  operator>=(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, GreaterEqualTo, Indexes...>(
        __null, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, GreaterEqualTo, Indexes...>
  operator>=(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, GreaterEqualTo, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, LessEqualTo, Indexes...>
  operator<=(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, LessEqualTo, Indexes...>(
        __null, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, LessEqualTo, Indexes...>
  operator<=(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, LessEqualTo, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, GreaterThan, Indexes...>
  operator>(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, GreaterThan, Indexes...>(
        __null, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, GreaterThan, Indexes...>
  operator>(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, GreaterThan, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, LessThan, Indexes...> operator<(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, LessThan, Indexes...>(__null, *this,
                                                          GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, LessThan, Indexes...>
  operator<(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, LessThan, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, LogicalAnd, Indexes...>
  operator&&(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, LogicalAnd, Indexes...>(
        __null, *this, GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, LogicalAnd, Indexes...>
  operator&&(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, LogicalAnd, Indexes...>(__null, *this, Rhs);
  }

  template <typename T, typename = EnableIfScalarType<T>>
  NewRelOp<GetScalarOp<T>, LogicalOr, Indexes...>
  operator||(const T &Rhs) const {
    return NewRelOp<GetScalarOp<T>, LogicalOr, Indexes...>(__null, *this,
                                                           GetScalarOp<T>(Rhs));
  }

  template <typename RhsOperation,
            typename = EnableIfNoScalarType<RhsOperation>>
  NewRelOp<RhsOperation, LogicalOr, Indexes...>
  operator||(const RhsOperation &Rhs) const {
    return NewRelOp<RhsOperation, LogicalOr, Indexes...>(__null, *this, Rhs);
  }


private:





  template <int Index>
  struct Indexer {
    static constexpr int IDXs[sizeof...(Indexes)] = {Indexes...};
    static constexpr int value = IDXs[Index >= getNumElements() ? 0 : Index];
  };

public:





# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/swizzles.def" 1 3
# 78 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/swizzles.def" 3
template <int N = getNumElements()> typename std::enable_if<(N <= 4), DataT &>::type x() { return (*m_Vector)[0]; } template <int N = getNumElements()> typename std::enable_if<(N <= 4), const DataT &>::type x() const { return (*m_Vector)[0]; }
template <int N = getNumElements()> typename std::enable_if<(N == 2 || N == 3 || N == 4), DataT &>::type y() { return (*m_Vector)[1]; } template <int N = getNumElements()> typename std::enable_if<(N == 2 || N == 3 || N == 4), const DataT &>::type y() const { return (*m_Vector)[1]; }
template <int N = getNumElements()> typename std::enable_if<(N == 3 || N == 4), DataT &>::type z() { return (*m_Vector)[2]; } template <int N = getNumElements()> typename std::enable_if<(N == 3 || N == 4), const DataT &>::type z() const { return (*m_Vector)[2]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type w() { return (*m_Vector)[3]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type w() const { return (*m_Vector)[3]; }


template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type r() { return (*m_Vector)[0]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type r() const { return (*m_Vector)[0]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type g() { return (*m_Vector)[1]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type g() const { return (*m_Vector)[1]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type b() { return (*m_Vector)[2]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type b() const { return (*m_Vector)[2]; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), DataT &>::type a() { return (*m_Vector)[3]; } template <int N = getNumElements()> typename std::enable_if<(N == 4), const DataT &>::type a() const { return (*m_Vector)[3]; }


template <int N = getNumElements()> typename std::enable_if<(N > 0), DataT &>::type s0() { return (*m_Vector)[0]; } template <int N = getNumElements()> typename std::enable_if<(N > 0), const DataT &>::type s0() const { return (*m_Vector)[0]; }
template <int N = getNumElements()> typename std::enable_if<(N > 1), DataT &>::type s1() { return (*m_Vector)[1]; } template <int N = getNumElements()> typename std::enable_if<(N > 1), const DataT &>::type s1() const { return (*m_Vector)[1]; }
template <int N = getNumElements()> typename std::enable_if<(N > 2), DataT &>::type s2() { return (*m_Vector)[2]; } template <int N = getNumElements()> typename std::enable_if<(N > 2), const DataT &>::type s2() const { return (*m_Vector)[2]; }
template <int N = getNumElements()> typename std::enable_if<(N > 2), DataT &>::type s3() { return (*m_Vector)[3]; } template <int N = getNumElements()> typename std::enable_if<(N > 2), const DataT &>::type s3() const { return (*m_Vector)[3]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s4() { return (*m_Vector)[4]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s4() const { return (*m_Vector)[4]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s5() { return (*m_Vector)[5]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s5() const { return (*m_Vector)[5]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s6() { return (*m_Vector)[6]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s6() const { return (*m_Vector)[6]; }
template <int N = getNumElements()> typename std::enable_if<(N > 4), DataT &>::type s7() { return (*m_Vector)[7]; } template <int N = getNumElements()> typename std::enable_if<(N > 4), const DataT &>::type s7() const { return (*m_Vector)[7]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type s8() { return (*m_Vector)[8]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type s8() const { return (*m_Vector)[8]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type s9() { return (*m_Vector)[9]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type s9() const { return (*m_Vector)[9]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sA() { return (*m_Vector)[10]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sA() const { return (*m_Vector)[10]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sB() { return (*m_Vector)[11]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sB() const { return (*m_Vector)[11]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sC() { return (*m_Vector)[12]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sC() const { return (*m_Vector)[12]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sD() { return (*m_Vector)[13]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sD() const { return (*m_Vector)[13]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sE() { return (*m_Vector)[14]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sE() const { return (*m_Vector)[14]; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), DataT &>::type sF() { return (*m_Vector)[15]; } template <int N = getNumElements()> typename std::enable_if<(N == 16), const DataT &>::type sF() const { return (*m_Vector)[15]; }
# 787 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/swizzles.def" 3
template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<0>::value>>::type lo() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<0>::value>>::type lo() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<0>::value, Indexer<1>::value>>::type lo() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value>>::type lo() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value>>::type lo() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value, Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type lo() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<0>::value, Indexer<1>::value, Indexer<2>::value, Indexer<3>::value, Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type lo() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<1>::value>>::type hi() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<1>::value>>::type hi() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<2>::value, Indexer<3>::value>>::type hi() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type hi() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<4>::value, Indexer<5>::value, Indexer<6>::value, Indexer<7>::value>>::type hi() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<8>::value, Indexer<9>::value, Indexer<10>::value, Indexer<11>::value, Indexer<12>::value, Indexer<13>::value, Indexer<14>::value, Indexer<15>::value>>::type hi() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<8>::value, Indexer<9>::value, Indexer<10>::value, Indexer<11>::value, Indexer<12>::value, Indexer<13>::value, Indexer<14>::value, Indexer<15>::value>>::type hi() const { return m_Vector; }

template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<1>::value>>::type odd() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<1>::value>>::type odd() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<1>::value, Indexer<3>::value>>::type odd() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value>>::type odd() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value>>::type odd() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value, Indexer<9>::value, Indexer<11>::value, Indexer<13>::value, Indexer<15>::value>>::type odd() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<1>::value, Indexer<3>::value, Indexer<5>::value, Indexer<7>::value, Indexer<9>::value, Indexer<11>::value, Indexer<13>::value, Indexer<15>::value>>::type odd() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 2), Swizzle< Indexer<0>::value>>::type even() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 2), ConstSwizzle< Indexer<0>::value>>::type even() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 3), Swizzle< Indexer<0>::value, Indexer<2>::value>>::type even() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 3), ConstSwizzle< Indexer<0>::value, Indexer<2>::value>>::type even() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 4), Swizzle< Indexer<0>::value, Indexer<2>::value>>::type even() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 4), ConstSwizzle< Indexer<0>::value, Indexer<2>::value>>::type even() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 8), Swizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value>>::type even() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 8), ConstSwizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value>>::type even() const { return m_Vector; }
template <int N = getNumElements()> typename std::enable_if<(N == 16), Swizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value, Indexer<8>::value, Indexer<10>::value, Indexer<12>::value, Indexer<14>::value>>::type even() { return m_Vector; } template <int N = getNumElements()> typename std::enable_if<(N == 16), ConstSwizzle< Indexer<0>::value, Indexer<2>::value, Indexer<4>::value, Indexer<6>::value, Indexer<8>::value, Indexer<10>::value, Indexer<12>::value, Indexer<14>::value>>::type even() const { return m_Vector; }
# 1804 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 2 3





  template <access::address_space Space>
  void load(size_t offset, multi_ptr<DataT, Space> ptr) {
    vec_t Tmp;
    Tmp.template load(offset, ptr);
    *this = Tmp;
  }

  template <typename convertT, rounding_mode roundingMode>
  vec<convertT, sizeof...(Indexes)> convert() const {

    vec_t Tmp = *this;
    return Tmp.template convert<convertT, roundingMode>();
  }

  template <typename asT>
  typename std::enable_if<asT::getNumElements() == getNumElements(), asT>::type
  as() const {

    vec_t Tmp = *this;
    return Tmp.template as<asT>();
  }

private:
  SwizzleOp(const SwizzleOp &Rhs)
      : m_Vector(Rhs.m_Vector), m_LeftOperation(Rhs.m_LeftOperation),
        m_RightOperation(Rhs.m_RightOperation) {}

  SwizzleOp(VecT *Vector, OperationLeftT LeftOperation,
            OperationRightT RightOperation)
      : m_Vector(Vector), m_LeftOperation(LeftOperation),
        m_RightOperation(RightOperation) {}

  SwizzleOp(VecT *Vector) : m_Vector(Vector) {}

  SwizzleOp(SwizzleOp &&Rhs)
      : m_Vector(Rhs.m_Vector), m_LeftOperation(std::move(Rhs.m_LeftOperation)),
        m_RightOperation(std::move(Rhs.m_RightOperation)) {}





  template <int IdxNum = getNumElements()>
  CommonDataT getValue(EnableIfOneIndex<IdxNum, size_t> Index) const {
    if (std::is_same<OperationCurrentT<DataT>, GetOp<DataT>>::value) {
      std::array<int, getNumElements()> Idxs{Indexes...};
      return m_Vector->getValue(Idxs[Index]);
    }
    auto Op = OperationCurrentT<CommonDataT>();
    return Op(m_LeftOperation.getValue(Index),
              m_RightOperation.getValue(Index));
  }

  template <int IdxNum = getNumElements()>
  DataT getValue(EnableIfMultipleIndexes<IdxNum, size_t> Index) const {
    if (std::is_same<OperationCurrentT<DataT>, GetOp<DataT>>::value) {
      std::array<int, getNumElements()> Idxs{Indexes...};
      return m_Vector->getValue(Idxs[Index]);
    }
    auto Op = OperationCurrentT<DataT>();
    return Op(m_LeftOperation.getValue(Index),
              m_RightOperation.getValue(Index));
  }

  template <template <typename> class Operation, typename RhsOperation>
  void operatorHelper(const RhsOperation &Rhs) {
    Operation<DataT> Op;
    std::array<int, getNumElements()> Idxs{Indexes...};
    for (size_t I = 0; I < Idxs.size(); ++I) {
      DataT Res = Op(m_Vector->getValue(Idxs[I]), Rhs.getValue(I));
      m_Vector->setValue(Idxs[I], Res);
    }
  }


  VecT *m_Vector;

  OperationLeftT m_LeftOperation;
  OperationRightT m_RightOperation;


  template <typename T1, int T2> friend class cl::sycl::vec;

  template <typename T1, typename T2, typename T3, template <typename> class T4,
            int... T5>
  friend class SwizzleOp;
};
}
# 1940 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator +(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) + Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator +(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs + Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator +( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs + Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator -(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) - Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator -(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs - Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator -( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs - Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator *(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) * Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator *(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs * Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator *( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs * Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator /(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) / Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator /(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs / Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator /( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs / Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator &(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) & Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator &(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs & Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator &( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs & Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator |(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) | Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator |(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs | Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator |( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs | Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator ^(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) ^ Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator ^(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs ^ Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator ^( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs ^ Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator >>(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) >> Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator >>(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs >> Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator >>( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs >> Tmp; }
template <typename T, int Num> typename std::enable_if< std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value, vec<T, Num>>::type operator <<(const T &Lhs, const vec<T, Num> &Rhs) { return vec<T, Num>(Lhs) << Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<T1, Num>>::type operator <<(const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs << Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<T, Num> operator <<( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs << Tmp; }
# 1995 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator ==(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) == Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator ==( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs == Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator ==( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs == Tmp; }
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator !=(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) != Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator !=( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs != Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator !=( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs != Tmp; }
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator >(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) > Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator >( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs > Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator >( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs > Tmp; }
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator <(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) < Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator <( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs < Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator <( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs < Tmp; }
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator >=(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) >= Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator >=( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs >= Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator >=( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs >= Tmp; }
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator <=(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) <= Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator <=( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs <= Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator <=( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs <= Tmp; }

template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator &&(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) && Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator &&( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs && Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator &&( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs && Tmp; }
template <typename T, typename DataT, int Num> typename std::enable_if< std::is_convertible<T, DataT>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<DataT>, Num>>::type operator ||(const T &Lhs, const vec<DataT, Num> &Rhs) { return vec<T, Num>(static_cast<T>(Lhs)) || Rhs; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T, typename T1 = typename VecT::element_type, int Num = sizeof...(Indexes)> typename std::enable_if< std::is_convertible<T, T1>::value && (std::is_fundamental<T>::value || std::is_same<typename std::remove_const<T>::type, half>::value), vec<detail::rel_t<T1>, Num>>::type operator ||( const T &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T1, Num> Tmp = Rhs; return Lhs || Tmp; } template <typename VecT, typename OperationLeftT, typename OperationRightT, template <typename> class OperationCurrentT, int... Indexes, typename T = typename VecT::element_type, int Num = sizeof...(Indexes)> vec<detail::rel_t<T>, Num> operator ||( const vec<T, Num> &Lhs, const detail::SwizzleOp<VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...> &Rhs) { vec<T, Num> Tmp = Rhs; return Lhs || Tmp; }


}
}
# 2037 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
using __char_t = cl::sycl::cl_char; using __char2_vec_t = cl::sycl::cl_char __attribute__((ext_vector_type(2))); using __char3_vec_t = cl::sycl::cl_char __attribute__((ext_vector_type(3))); using __char4_vec_t = cl::sycl::cl_char __attribute__((ext_vector_type(4))); using __char8_vec_t = cl::sycl::cl_char __attribute__((ext_vector_type(8))); using __char16_vec_t = cl::sycl::cl_char __attribute__((ext_vector_type(16)));;
using __schar_t = cl::sycl::schar; using __schar2_vec_t = cl::sycl::schar __attribute__((ext_vector_type(2))); using __schar3_vec_t = cl::sycl::schar __attribute__((ext_vector_type(3))); using __schar4_vec_t = cl::sycl::schar __attribute__((ext_vector_type(4))); using __schar8_vec_t = cl::sycl::schar __attribute__((ext_vector_type(8))); using __schar16_vec_t = cl::sycl::schar __attribute__((ext_vector_type(16)));;
using __uchar_t = cl::sycl::cl_uchar; using __uchar2_vec_t = cl::sycl::cl_uchar __attribute__((ext_vector_type(2))); using __uchar3_vec_t = cl::sycl::cl_uchar __attribute__((ext_vector_type(3))); using __uchar4_vec_t = cl::sycl::cl_uchar __attribute__((ext_vector_type(4))); using __uchar8_vec_t = cl::sycl::cl_uchar __attribute__((ext_vector_type(8))); using __uchar16_vec_t = cl::sycl::cl_uchar __attribute__((ext_vector_type(16)));;
using __short_t = cl::sycl::cl_short; using __short2_vec_t = cl::sycl::cl_short __attribute__((ext_vector_type(2))); using __short3_vec_t = cl::sycl::cl_short __attribute__((ext_vector_type(3))); using __short4_vec_t = cl::sycl::cl_short __attribute__((ext_vector_type(4))); using __short8_vec_t = cl::sycl::cl_short __attribute__((ext_vector_type(8))); using __short16_vec_t = cl::sycl::cl_short __attribute__((ext_vector_type(16)));;
using __ushort_t = cl::sycl::cl_ushort; using __ushort2_vec_t = cl::sycl::cl_ushort __attribute__((ext_vector_type(2))); using __ushort3_vec_t = cl::sycl::cl_ushort __attribute__((ext_vector_type(3))); using __ushort4_vec_t = cl::sycl::cl_ushort __attribute__((ext_vector_type(4))); using __ushort8_vec_t = cl::sycl::cl_ushort __attribute__((ext_vector_type(8))); using __ushort16_vec_t = cl::sycl::cl_ushort __attribute__((ext_vector_type(16)));;
using __int_t = cl::sycl::cl_int; using __int2_vec_t = cl::sycl::cl_int __attribute__((ext_vector_type(2))); using __int3_vec_t = cl::sycl::cl_int __attribute__((ext_vector_type(3))); using __int4_vec_t = cl::sycl::cl_int __attribute__((ext_vector_type(4))); using __int8_vec_t = cl::sycl::cl_int __attribute__((ext_vector_type(8))); using __int16_vec_t = cl::sycl::cl_int __attribute__((ext_vector_type(16)));;
using __uint_t = cl::sycl::cl_uint; using __uint2_vec_t = cl::sycl::cl_uint __attribute__((ext_vector_type(2))); using __uint3_vec_t = cl::sycl::cl_uint __attribute__((ext_vector_type(3))); using __uint4_vec_t = cl::sycl::cl_uint __attribute__((ext_vector_type(4))); using __uint8_vec_t = cl::sycl::cl_uint __attribute__((ext_vector_type(8))); using __uint16_vec_t = cl::sycl::cl_uint __attribute__((ext_vector_type(16)));;
using __long_t = cl::sycl::cl_long; using __long2_vec_t = cl::sycl::cl_long __attribute__((ext_vector_type(2))); using __long3_vec_t = cl::sycl::cl_long __attribute__((ext_vector_type(3))); using __long4_vec_t = cl::sycl::cl_long __attribute__((ext_vector_type(4))); using __long8_vec_t = cl::sycl::cl_long __attribute__((ext_vector_type(8))); using __long16_vec_t = cl::sycl::cl_long __attribute__((ext_vector_type(16)));;
using __ulong_t = cl::sycl::cl_ulong; using __ulong2_vec_t = cl::sycl::cl_ulong __attribute__((ext_vector_type(2))); using __ulong3_vec_t = cl::sycl::cl_ulong __attribute__((ext_vector_type(3))); using __ulong4_vec_t = cl::sycl::cl_ulong __attribute__((ext_vector_type(4))); using __ulong8_vec_t = cl::sycl::cl_ulong __attribute__((ext_vector_type(8))); using __ulong16_vec_t = cl::sycl::cl_ulong __attribute__((ext_vector_type(16)));;
using __longlong_t = cl::sycl::longlong; using __longlong2_vec_t = cl::sycl::longlong __attribute__((ext_vector_type(2))); using __longlong3_vec_t = cl::sycl::longlong __attribute__((ext_vector_type(3))); using __longlong4_vec_t = cl::sycl::longlong __attribute__((ext_vector_type(4))); using __longlong8_vec_t = cl::sycl::longlong __attribute__((ext_vector_type(8))); using __longlong16_vec_t = cl::sycl::longlong __attribute__((ext_vector_type(16)));;
using __ulonglong_t = cl::sycl::ulonglong; using __ulonglong2_vec_t = cl::sycl::ulonglong __attribute__((ext_vector_type(2))); using __ulonglong3_vec_t = cl::sycl::ulonglong __attribute__((ext_vector_type(3))); using __ulonglong4_vec_t = cl::sycl::ulonglong __attribute__((ext_vector_type(4))); using __ulonglong8_vec_t = cl::sycl::ulonglong __attribute__((ext_vector_type(8))); using __ulonglong16_vec_t = cl::sycl::ulonglong __attribute__((ext_vector_type(16)));;


using __float_t = cl::sycl::cl_float; using __float2_vec_t = cl::sycl::cl_float __attribute__((ext_vector_type(2))); using __float3_vec_t = cl::sycl::cl_float __attribute__((ext_vector_type(3))); using __float4_vec_t = cl::sycl::cl_float __attribute__((ext_vector_type(4))); using __float8_vec_t = cl::sycl::cl_float __attribute__((ext_vector_type(8))); using __float16_vec_t = cl::sycl::cl_float __attribute__((ext_vector_type(16)));;
using __double_t = cl::sycl::cl_double; using __double2_vec_t = cl::sycl::cl_double __attribute__((ext_vector_type(2))); using __double3_vec_t = cl::sycl::cl_double __attribute__((ext_vector_type(3))); using __double4_vec_t = cl::sycl::cl_double __attribute__((ext_vector_type(4))); using __double8_vec_t = cl::sycl::cl_double __attribute__((ext_vector_type(8))); using __double16_vec_t = cl::sycl::cl_double __attribute__((ext_vector_type(16)));;
# 2063 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
using __half_t = cl::sycl::detail::half_impl::StorageT;
using __half2_vec_t = cl::sycl::detail::half_impl::Vec2StorageT;
using __half3_vec_t = cl::sycl::detail::half_impl::Vec3StorageT;
using __half4_vec_t = cl::sycl::detail::half_impl::Vec4StorageT;
using __half8_vec_t = cl::sycl::detail::half_impl::Vec8StorageT;
using __half16_vec_t = cl::sycl::detail::half_impl::Vec16StorageT;


inline namespace cl {
namespace sycl {
namespace detail {


template <typename T, typename T8, typename T16, typename T32, typename T64>
using select_apply_cl_t =
  conditional_t<sizeof(T) == 1, T8,
  conditional_t<sizeof(T) == 2, T16,
  conditional_t<sizeof(T) == 4, T32, T64>>>;
}
# 2245 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
namespace detail { template <> class BaseCLTypeConverter<char, 2> { public: using DataType = __char2_vec_t; }; template <> class BaseCLTypeConverter<char, 3> { public: using DataType = __char3_vec_t; }; template <> class BaseCLTypeConverter<char, 4> { public: using DataType = __char4_vec_t; }; template <> class BaseCLTypeConverter<char, 8> { public: using DataType = __char8_vec_t; }; template <> class BaseCLTypeConverter<char, 16> { public: using DataType = __char16_vec_t; }; template <> class BaseCLTypeConverter<char, 1> { public: using DataType = char; }; }
namespace detail { template <> class BaseCLTypeConverter<schar, 2> { public: using DataType = detail::select_apply_cl_t< schar, __char2_vec_t, __short2_vec_t, __int2_vec_t, __long2_vec_t>; }; template <> class BaseCLTypeConverter<schar, 3> { public: using DataType = detail::select_apply_cl_t< schar, __char3_vec_t, __short3_vec_t, __int3_vec_t, __long3_vec_t>; }; template <> class BaseCLTypeConverter<schar, 4> { public: using DataType = detail::select_apply_cl_t< schar, __char4_vec_t, __short4_vec_t, __int4_vec_t, __long4_vec_t>; }; template <> class BaseCLTypeConverter<schar, 8> { public: using DataType = detail::select_apply_cl_t< schar, __char8_vec_t, __short8_vec_t, __int8_vec_t, __long8_vec_t>; }; template <> class BaseCLTypeConverter<schar, 16> { public: using DataType = detail::select_apply_cl_t< schar, __char16_vec_t, __short16_vec_t, __int16_vec_t, __long16_vec_t>; }; template <> class BaseCLTypeConverter<schar, 1> { public: using DataType = schar; }; }
namespace detail { template <> class BaseCLTypeConverter<bool, 2> { public: using DataType = detail::select_apply_cl_t< bool, __char2_vec_t, __short2_vec_t, __int2_vec_t, __long2_vec_t>; }; template <> class BaseCLTypeConverter<bool, 3> { public: using DataType = detail::select_apply_cl_t< bool, __char3_vec_t, __short3_vec_t, __int3_vec_t, __long3_vec_t>; }; template <> class BaseCLTypeConverter<bool, 4> { public: using DataType = detail::select_apply_cl_t< bool, __char4_vec_t, __short4_vec_t, __int4_vec_t, __long4_vec_t>; }; template <> class BaseCLTypeConverter<bool, 8> { public: using DataType = detail::select_apply_cl_t< bool, __char8_vec_t, __short8_vec_t, __int8_vec_t, __long8_vec_t>; }; template <> class BaseCLTypeConverter<bool, 16> { public: using DataType = detail::select_apply_cl_t< bool, __char16_vec_t, __short16_vec_t, __int16_vec_t, __long16_vec_t>; }; template <> class BaseCLTypeConverter<bool, 1> { public: using DataType = bool; }; }
namespace detail { template <> class BaseCLTypeConverter<uchar, 2> { public: using DataType = detail::select_apply_cl_t<uchar, __uchar2_vec_t, __ushort2_vec_t, __uint2_vec_t, __ulong2_vec_t>; }; template <> class BaseCLTypeConverter<uchar, 3> { public: using DataType = detail::select_apply_cl_t<uchar, __uchar3_vec_t, __ushort3_vec_t, __uint3_vec_t, __ulong3_vec_t>; }; template <> class BaseCLTypeConverter<uchar, 4> { public: using DataType = detail::select_apply_cl_t<uchar, __uchar4_vec_t, __ushort4_vec_t, __uint4_vec_t, __ulong4_vec_t>; }; template <> class BaseCLTypeConverter<uchar, 8> { public: using DataType = detail::select_apply_cl_t<uchar, __uchar8_vec_t, __ushort8_vec_t, __uint8_vec_t, __ulong8_vec_t>; }; template <> class BaseCLTypeConverter<uchar, 16> { public: using DataType = detail::select_apply_cl_t<uchar, __uchar16_vec_t, __ushort16_vec_t, __uint16_vec_t, __ulong16_vec_t>; }; template <> class BaseCLTypeConverter<uchar, 1> { public: using DataType = uchar; }; }
namespace detail { template <> class BaseCLTypeConverter<short, 2> { public: using DataType = detail::select_apply_cl_t<short, __char2_vec_t, __short2_vec_t, __int2_vec_t, __long2_vec_t>; }; template <> class BaseCLTypeConverter<short, 3> { public: using DataType = detail::select_apply_cl_t<short, __char3_vec_t, __short3_vec_t, __int3_vec_t, __long3_vec_t>; }; template <> class BaseCLTypeConverter<short, 4> { public: using DataType = detail::select_apply_cl_t<short, __char4_vec_t, __short4_vec_t, __int4_vec_t, __long4_vec_t>; }; template <> class BaseCLTypeConverter<short, 8> { public: using DataType = detail::select_apply_cl_t<short, __char8_vec_t, __short8_vec_t, __int8_vec_t, __long8_vec_t>; }; template <> class BaseCLTypeConverter<short, 16> { public: using DataType = detail::select_apply_cl_t<short, __char16_vec_t, __short16_vec_t, __int16_vec_t, __long16_vec_t>; }; template <> class BaseCLTypeConverter<short, 1> { public: using DataType = short; }; }
namespace detail { template <> class BaseCLTypeConverter<ushort, 2> { public: using DataType = detail::select_apply_cl_t<ushort, __uchar2_vec_t, __ushort2_vec_t, __uint2_vec_t, __ulong2_vec_t>; }; template <> class BaseCLTypeConverter<ushort, 3> { public: using DataType = detail::select_apply_cl_t<ushort, __uchar3_vec_t, __ushort3_vec_t, __uint3_vec_t, __ulong3_vec_t>; }; template <> class BaseCLTypeConverter<ushort, 4> { public: using DataType = detail::select_apply_cl_t<ushort, __uchar4_vec_t, __ushort4_vec_t, __uint4_vec_t, __ulong4_vec_t>; }; template <> class BaseCLTypeConverter<ushort, 8> { public: using DataType = detail::select_apply_cl_t<ushort, __uchar8_vec_t, __ushort8_vec_t, __uint8_vec_t, __ulong8_vec_t>; }; template <> class BaseCLTypeConverter<ushort, 16> { public: using DataType = detail::select_apply_cl_t<ushort, __uchar16_vec_t, __ushort16_vec_t, __uint16_vec_t, __ulong16_vec_t>; }; template <> class BaseCLTypeConverter<ushort, 1> { public: using DataType = ushort; }; }
namespace detail { template <> class BaseCLTypeConverter<int, 2> { public: using DataType = detail::select_apply_cl_t<int, __char2_vec_t, __short2_vec_t, __int2_vec_t, __long2_vec_t>; }; template <> class BaseCLTypeConverter<int, 3> { public: using DataType = detail::select_apply_cl_t<int, __char3_vec_t, __short3_vec_t, __int3_vec_t, __long3_vec_t>; }; template <> class BaseCLTypeConverter<int, 4> { public: using DataType = detail::select_apply_cl_t<int, __char4_vec_t, __short4_vec_t, __int4_vec_t, __long4_vec_t>; }; template <> class BaseCLTypeConverter<int, 8> { public: using DataType = detail::select_apply_cl_t<int, __char8_vec_t, __short8_vec_t, __int8_vec_t, __long8_vec_t>; }; template <> class BaseCLTypeConverter<int, 16> { public: using DataType = detail::select_apply_cl_t<int, __char16_vec_t, __short16_vec_t, __int16_vec_t, __long16_vec_t>; }; template <> class BaseCLTypeConverter<int, 1> { public: using DataType = int; }; }
namespace detail { template <> class BaseCLTypeConverter<uint, 2> { public: using DataType = detail::select_apply_cl_t<uint, __uchar2_vec_t, __ushort2_vec_t, __uint2_vec_t, __ulong2_vec_t>; }; template <> class BaseCLTypeConverter<uint, 3> { public: using DataType = detail::select_apply_cl_t<uint, __uchar3_vec_t, __ushort3_vec_t, __uint3_vec_t, __ulong3_vec_t>; }; template <> class BaseCLTypeConverter<uint, 4> { public: using DataType = detail::select_apply_cl_t<uint, __uchar4_vec_t, __ushort4_vec_t, __uint4_vec_t, __ulong4_vec_t>; }; template <> class BaseCLTypeConverter<uint, 8> { public: using DataType = detail::select_apply_cl_t<uint, __uchar8_vec_t, __ushort8_vec_t, __uint8_vec_t, __ulong8_vec_t>; }; template <> class BaseCLTypeConverter<uint, 16> { public: using DataType = detail::select_apply_cl_t<uint, __uchar16_vec_t, __ushort16_vec_t, __uint16_vec_t, __ulong16_vec_t>; }; template <> class BaseCLTypeConverter<uint, 1> { public: using DataType = uint; }; }
namespace detail { template <> class BaseCLTypeConverter<long, 2> { public: using DataType = detail::select_apply_cl_t<long, __char2_vec_t, __short2_vec_t, __int2_vec_t, __long2_vec_t>; }; template <> class BaseCLTypeConverter<long, 3> { public: using DataType = detail::select_apply_cl_t<long, __char3_vec_t, __short3_vec_t, __int3_vec_t, __long3_vec_t>; }; template <> class BaseCLTypeConverter<long, 4> { public: using DataType = detail::select_apply_cl_t<long, __char4_vec_t, __short4_vec_t, __int4_vec_t, __long4_vec_t>; }; template <> class BaseCLTypeConverter<long, 8> { public: using DataType = detail::select_apply_cl_t<long, __char8_vec_t, __short8_vec_t, __int8_vec_t, __long8_vec_t>; }; template <> class BaseCLTypeConverter<long, 16> { public: using DataType = detail::select_apply_cl_t<long, __char16_vec_t, __short16_vec_t, __int16_vec_t, __long16_vec_t>; }; template <> class BaseCLTypeConverter<long, 1> { public: using DataType = long; }; }
namespace detail { template <> class BaseCLTypeConverter<ulong, 2> { public: using DataType = detail::select_apply_cl_t<ulong, __uchar2_vec_t, __ushort2_vec_t, __uint2_vec_t, __ulong2_vec_t>; }; template <> class BaseCLTypeConverter<ulong, 3> { public: using DataType = detail::select_apply_cl_t<ulong, __uchar3_vec_t, __ushort3_vec_t, __uint3_vec_t, __ulong3_vec_t>; }; template <> class BaseCLTypeConverter<ulong, 4> { public: using DataType = detail::select_apply_cl_t<ulong, __uchar4_vec_t, __ushort4_vec_t, __uint4_vec_t, __ulong4_vec_t>; }; template <> class BaseCLTypeConverter<ulong, 8> { public: using DataType = detail::select_apply_cl_t<ulong, __uchar8_vec_t, __ushort8_vec_t, __uint8_vec_t, __ulong8_vec_t>; }; template <> class BaseCLTypeConverter<ulong, 16> { public: using DataType = detail::select_apply_cl_t<ulong, __uchar16_vec_t, __ushort16_vec_t, __uint16_vec_t, __ulong16_vec_t>; }; template <> class BaseCLTypeConverter<ulong, 1> { public: using DataType = ulong; }; }
namespace detail { template <> class BaseCLTypeConverter<longlong, 2> { public: using DataType = __long2_vec_t; }; template <> class BaseCLTypeConverter<longlong, 3> { public: using DataType = __long3_vec_t; }; template <> class BaseCLTypeConverter<longlong, 4> { public: using DataType = __long4_vec_t; }; template <> class BaseCLTypeConverter<longlong, 8> { public: using DataType = __long8_vec_t; }; template <> class BaseCLTypeConverter<longlong, 16> { public: using DataType = __long16_vec_t; }; template <> class BaseCLTypeConverter<longlong, 1> { public: using DataType = longlong; }; }
namespace detail { template <> class BaseCLTypeConverter<ulonglong, 2> { public: using DataType = __ulong2_vec_t; }; template <> class BaseCLTypeConverter<ulonglong, 3> { public: using DataType = __ulong3_vec_t; }; template <> class BaseCLTypeConverter<ulonglong, 4> { public: using DataType = __ulong4_vec_t; }; template <> class BaseCLTypeConverter<ulonglong, 8> { public: using DataType = __ulong8_vec_t; }; template <> class BaseCLTypeConverter<ulonglong, 16> { public: using DataType = __ulong16_vec_t; }; template <> class BaseCLTypeConverter<ulonglong, 1> { public: using DataType = ulonglong; }; }
namespace detail { template <> class BaseCLTypeConverter<half, 2> { public: using DataType = __half2_vec_t; }; template <> class BaseCLTypeConverter<half, 3> { public: using DataType = __half3_vec_t; }; template <> class BaseCLTypeConverter<half, 4> { public: using DataType = __half4_vec_t; }; template <> class BaseCLTypeConverter<half, 8> { public: using DataType = __half8_vec_t; }; template <> class BaseCLTypeConverter<half, 16> { public: using DataType = __half16_vec_t; }; template <> class BaseCLTypeConverter<half, 1> { public: using DataType = __half_t; }; }
namespace detail { template <> class BaseCLTypeConverter<float, 2> { public: using DataType = detail::select_apply_cl_t<float, std::false_type, __half2_vec_t, __float2_vec_t, __double2_vec_t>; }; template <> class BaseCLTypeConverter<float, 3> { public: using DataType = detail::select_apply_cl_t<float, std::false_type, __half3_vec_t, __float3_vec_t, __double3_vec_t>; }; template <> class BaseCLTypeConverter<float, 4> { public: using DataType = detail::select_apply_cl_t<float, std::false_type, __half4_vec_t, __float4_vec_t, __double4_vec_t>; }; template <> class BaseCLTypeConverter<float, 8> { public: using DataType = detail::select_apply_cl_t<float, std::false_type, __half8_vec_t, __float8_vec_t, __double8_vec_t>; }; template <> class BaseCLTypeConverter<float, 16> { public: using DataType = detail::select_apply_cl_t<float, std::false_type, __half16_vec_t, __float16_vec_t, __double16_vec_t>; }; template <> class BaseCLTypeConverter<float, 1> { public: using DataType = float; }; }
namespace detail { template <> class BaseCLTypeConverter<double, 2> { public: using DataType = detail::select_apply_cl_t<double, std::false_type, __half2_vec_t, __float2_vec_t, __double2_vec_t>; }; template <> class BaseCLTypeConverter<double, 3> { public: using DataType = detail::select_apply_cl_t<double, std::false_type, __half3_vec_t, __float3_vec_t, __double3_vec_t>; }; template <> class BaseCLTypeConverter<double, 4> { public: using DataType = detail::select_apply_cl_t<double, std::false_type, __half4_vec_t, __float4_vec_t, __double4_vec_t>; }; template <> class BaseCLTypeConverter<double, 8> { public: using DataType = detail::select_apply_cl_t<double, std::false_type, __half8_vec_t, __float8_vec_t, __double8_vec_t>; }; template <> class BaseCLTypeConverter<double, 16> { public: using DataType = detail::select_apply_cl_t<double, std::false_type, __half16_vec_t, __float16_vec_t, __double16_vec_t>; }; template <> class BaseCLTypeConverter<double, 1> { public: using DataType = double; }; }
# 2274 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/types.hpp" 3
}
}
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/buffer_impl.hpp" 2 3






inline namespace cl {
namespace sycl {

template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder,
          typename PropertyListT>
class accessor;
template <typename T, int Dimensions, typename AllocatorT, typename Enable>
class buffer;
template <typename DataT, int Dimensions, access::mode AccessMode>
class host_accessor;

using buffer_allocator = detail::sycl_memory_object_allocator;

namespace detail {

class __attribute__((visibility("default"))) buffer_impl final : public SYCLMemObjT {
  using BaseT = SYCLMemObjT;
  using typename BaseT::MemObjType;

public:
  buffer_impl(size_t SizeInBytes, size_t, const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : BaseT(SizeInBytes, Props, std::move(Allocator)) {

    if (Props.has_property<sycl::property::buffer::use_host_ptr>())
      throw sycl::invalid_object_error(
          "The use_host_ptr property requires host pointer to be provided",
          PI_INVALID_OPERATION);
  }

  buffer_impl(void *HostData, size_t SizeInBytes, size_t RequiredAlign,
              const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : BaseT(SizeInBytes, Props, std::move(Allocator)) {

    if (Props.has_property<
            sycl::ext::oneapi::property::buffer::use_pinned_host_memory>())
      throw sycl::invalid_object_error(
          "The use_pinned_host_memory cannot be used with host pointer",
          PI_INVALID_OPERATION);

    BaseT::handleHostData(HostData, RequiredAlign);
  }

  buffer_impl(const void *HostData, size_t SizeInBytes, size_t RequiredAlign,
              const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : BaseT(SizeInBytes, Props, std::move(Allocator)) {

    if (Props.has_property<
            sycl::ext::oneapi::property::buffer::use_pinned_host_memory>())
      throw sycl::invalid_object_error(
          "The use_pinned_host_memory cannot be used with host pointer",
          PI_INVALID_OPERATION);

    BaseT::handleHostData(HostData, RequiredAlign);
  }

  template <typename T>
  buffer_impl(const shared_ptr_class<T> &HostData, const size_t SizeInBytes,
              size_t RequiredAlign, const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : BaseT(SizeInBytes, Props, std::move(Allocator)) {

    if (Props.has_property<
            sycl::ext::oneapi::property::buffer::use_pinned_host_memory>())
      throw sycl::invalid_object_error(
          "The use_pinned_host_memory cannot be used with host pointer",
          PI_INVALID_OPERATION);

    BaseT::handleHostData(HostData, RequiredAlign);
  }

  template <typename T>
  using EnableIfNotConstIterator =
      enable_if_t<!iterator_to_const_type_t<T>::value, T>;

  template <class InputIterator>
  buffer_impl(EnableIfNotConstIterator<InputIterator> First, InputIterator Last,
              const size_t SizeInBytes, size_t RequiredAlign,
              const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : BaseT(SizeInBytes, Props, std::move(Allocator)) {

    if (Props.has_property<sycl::property::buffer::use_host_ptr>())
      throw sycl::invalid_object_error(
          "Buffer constructor from a pair of iterator values cannot have the "
          "use_host_ptr property.",
          PI_INVALID_OPERATION);

    BaseT::handleHostData(First, Last, RequiredAlign);
  }

  template <typename T>
  using EnableIfConstIterator =
      enable_if_t<iterator_to_const_type_t<T>::value, T>;

  template <class InputIterator>
  buffer_impl(EnableIfConstIterator<InputIterator> First, InputIterator Last,
              const size_t SizeInBytes, size_t RequiredAlign,
              const property_list &Props,
              unique_ptr_class<SYCLMemObjAllocator> Allocator)
      : BaseT(SizeInBytes, Props, std::move(Allocator)) {

    if (Props.has_property<sycl::property::buffer::use_host_ptr>())
      throw sycl::invalid_object_error(
          "Buffer constructor from a pair of iterator values cannot have the "
          "use_host_ptr property.",
          PI_INVALID_OPERATION);

    BaseT::handleHostData(First, Last, RequiredAlign);
  }

  buffer_impl(cl_mem MemObject, const context &SyclContext,
              const size_t SizeInBytes,
              unique_ptr_class<SYCLMemObjAllocator> Allocator,
              event AvailableEvent)
      : BaseT(MemObject, SyclContext, SizeInBytes, std::move(AvailableEvent),
              std::move(Allocator)) {}

  void *allocateMem(ContextImplPtr Context, bool InitFromUserData,
                    void *HostPtr, RT::PiEvent &OutEventToWait) override;

  MemObjType getType() const override { return MemObjType::BUFFER; }

  ~buffer_impl() {
    try {
      BaseT::updateHostMemory();
    } catch (...) {
    }
  }

  void resize(size_t size) { BaseT::MSizeInBytes = size; }
};

}
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/buffer.hpp" 2 3






inline namespace cl {
namespace sycl {

class handler;
class queue;
template <int dimensions> class range;
# 34 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/buffer.hpp" 3
template <typename T, int dimensions = 1,
          typename AllocatorT = cl::sycl::buffer_allocator,
          typename = typename std::enable_if<(dimensions > 0) &&
                                             (dimensions <= 3)>::type>
class buffer {
public:
  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;
  using allocator_type = AllocatorT;
  template <int dims>
  using EnableIfOneDimension = typename std::enable_if<1 == dims>::type;

  template <class Container>
  using EnableIfContiguous =
      detail::void_t<detail::enable_if_t<std::is_convertible<
                         detail::remove_pointer_t<decltype(
                             std::declval<Container>().data())> (*)[],
                         const T (*)[]>::value>,
                     decltype(std::declval<Container>().size())>;
  template <class It>
  using EnableIfItInputIterator = detail::enable_if_t<
      std::is_convertible<typename std::iterator_traits<It>::iterator_category,
                          std::input_iterator_tag>::value>;
  template <typename ItA, typename ItB>
  using EnableIfSameNonConstIterators =
      typename std::enable_if<std::is_same<ItA, ItB>::value &&
                              !std::is_const<ItA>::value, ItA>::type;

  buffer(const range<dimensions> &bufferRange,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)), propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>());
  }

  buffer(const range<dimensions> &bufferRange, AllocatorT allocator,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)), propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            allocator));
  }

  buffer(T *hostData, const range<dimensions> &bufferRange,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        hostData, get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)),
        propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>());
  }

  buffer(T *hostData, const range<dimensions> &bufferRange,
         AllocatorT allocator, const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        hostData, get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)),
        propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            allocator));
  }

  template <typename _T = T>
  buffer(EnableIfSameNonConstIterators<T, _T> const *hostData,
         const range<dimensions> &bufferRange,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        hostData, get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)),
        propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>());
  }

  template <typename _T = T>
  buffer(EnableIfSameNonConstIterators<T, _T> const *hostData,
         const range<dimensions> &bufferRange, AllocatorT allocator,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        hostData, get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)),
        propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            allocator));
  }

  buffer(const shared_ptr_class<T> &hostData,
         const range<dimensions> &bufferRange, AllocatorT allocator,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        hostData, get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)),
        propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            allocator));
  }

  buffer(const shared_ptr_class<T> &hostData,
         const range<dimensions> &bufferRange,
         const property_list &propList = {})
      : Range(bufferRange) {
    impl = std::make_shared<detail::buffer_impl>(
        hostData, get_count() * sizeof(T), detail::getNextPowerOfTwo(sizeof(T)),
        propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>());
  }

  template <class InputIterator, int N = dimensions,
            typename = EnableIfOneDimension<N>,
            typename = EnableIfItInputIterator<InputIterator>>
  buffer(InputIterator first, InputIterator last, AllocatorT allocator,
         const property_list &propList = {})
      : Range(range<1>(std::distance(first, last))) {
    impl = std::make_shared<detail::buffer_impl>(
        first, last, get_count() * sizeof(T),
        detail::getNextPowerOfTwo(sizeof(T)), propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            allocator));
  }

  template <class InputIterator, int N = dimensions,
            typename = EnableIfOneDimension<N>,
            typename = EnableIfItInputIterator<InputIterator>>
  buffer(InputIterator first, InputIterator last,
         const property_list &propList = {})
      : Range(range<1>(std::distance(first, last))) {
    impl = std::make_shared<detail::buffer_impl>(
        first, last, get_count() * sizeof(T),
        detail::getNextPowerOfTwo(sizeof(T)), propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>());
  }


  template <class Container, int N = dimensions,
            typename = EnableIfOneDimension<N>,
            typename = EnableIfContiguous<Container>>
  buffer(Container &container, AllocatorT allocator,
         const property_list &propList = {})
      : Range(range<1>(container.size())) {
    impl = std::make_shared<detail::buffer_impl>(
        container.data(), get_count() * sizeof(T),
        detail::getNextPowerOfTwo(sizeof(T)), propList,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            allocator));
  }


  template <class Container, int N = dimensions,
            typename = EnableIfOneDimension<N>,
            typename = EnableIfContiguous<Container>>
  buffer(Container &container, const property_list &propList = {})
      : buffer(container, {}, propList) {}

  buffer(buffer<T, dimensions, AllocatorT> &b, const id<dimensions> &baseIndex,
         const range<dimensions> &subRange)
      : impl(b.impl), Range(subRange),
        OffsetInBytes(getOffsetInBytes<T>(baseIndex, b.Range)),
        IsSubBuffer(true) {
    if (b.is_sub_buffer())
      throw cl::sycl::invalid_object_error(
          "Cannot create sub buffer from sub buffer.", PI_INVALID_VALUE);
    if (isOutOfBounds(baseIndex, subRange, b.Range))
      throw cl::sycl::invalid_object_error(
          "Requested sub-buffer size exceeds the size of the parent buffer",
          PI_INVALID_VALUE);
    if (!isContiguousRegion(baseIndex, subRange, b.Range))
      throw cl::sycl::invalid_object_error(
          "Requested sub-buffer region is not contiguous", PI_INVALID_VALUE);
  }

  template <int N = dimensions, typename = EnableIfOneDimension<N>>
  buffer(cl_mem MemObject, const context &SyclContext,
         event AvailableEvent = {})
      : Range{0} {

    size_t BufSize = detail::SYCLMemObjT::getBufSizeForContext(
        detail::getSyclObjImpl(SyclContext), MemObject);

    Range[0] = BufSize / sizeof(T);
    impl = std::make_shared<detail::buffer_impl>(
        MemObject, SyclContext, BufSize,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        AvailableEvent);
  }

  buffer(const buffer &rhs) = default;

  buffer(buffer &&rhs) = default;

  buffer &operator=(const buffer &rhs) = default;

  buffer &operator=(buffer &&rhs) = default;

  ~buffer() = default;

  bool operator==(const buffer &rhs) const { return impl == rhs.impl; }

  bool operator!=(const buffer &rhs) const { return !(*this == rhs); }





  range<dimensions> get_range() const { return Range; }

  size_t get_count() const { return Range.size(); }

  size_t get_size() const { return get_count() * sizeof(T); }

  AllocatorT get_allocator() const {
    return impl->template get_allocator<AllocatorT>();
  }

  template <access::mode Mode,
            access::target Target = access::target::global_buffer>
  accessor<T, dimensions, Mode, Target, access::placeholder::false_t,
           ONEAPI::accessor_property_list<>>
  get_access(handler &CommandGroupHandler) {
    return accessor<T, dimensions, Mode, Target, access::placeholder::false_t,
                    ONEAPI::accessor_property_list<>>(*this,
                                                      CommandGroupHandler);
  }

  template <access::mode mode>
  accessor<T, dimensions, mode, access::target::host_buffer,
           access::placeholder::false_t, ONEAPI::accessor_property_list<>>
  get_access() {
    return accessor<T, dimensions, mode, access::target::host_buffer,
                    access::placeholder::false_t,
                    ONEAPI::accessor_property_list<>>(*this);
  }

  template <access::mode mode,
            access::target target = access::target::global_buffer>
  accessor<T, dimensions, mode, target, access::placeholder::false_t,
           ONEAPI::accessor_property_list<>>
  get_access(handler &commandGroupHandler, range<dimensions> accessRange,
             id<dimensions> accessOffset = {}) {
    return accessor<T, dimensions, mode, target, access::placeholder::false_t,
                    ONEAPI::accessor_property_list<>>(
        *this, commandGroupHandler, accessRange, accessOffset);
  }

  template <access::mode mode>
  accessor<T, dimensions, mode, access::target::host_buffer,
           access::placeholder::false_t, ONEAPI::accessor_property_list<>>
  get_access(range<dimensions> accessRange, id<dimensions> accessOffset = {}) {
    return accessor<T, dimensions, mode, access::target::host_buffer,
                    access::placeholder::false_t,
                    ONEAPI::accessor_property_list<>>(*this, accessRange,
                                                      accessOffset);
  }



  template <typename... Ts> auto get_access(Ts... args) {
    return accessor{*this, args...};
  }

  template <typename... Ts>
  auto get_access(handler &commandGroupHandler, Ts... args) {
    return accessor{*this, commandGroupHandler, args...};
  }

  template <typename... Ts> auto get_host_access(Ts... args) {
    return host_accessor{*this, args...};
  }

  template <typename... Ts>
  auto get_host_access(handler &commandGroupHandler, Ts... args) {
    return host_accessor{*this, commandGroupHandler, args...};
  }



  template <typename Destination = std::nullptr_t>
  void set_final_data(Destination finalData = nullptr) {
    impl->set_final_data(finalData);
  }

  void set_write_back(bool flag = true) { impl->set_write_back(flag); }

  bool is_sub_buffer() const { return IsSubBuffer; }

  template <typename ReinterpretT, int ReinterpretDim>
  buffer<ReinterpretT, ReinterpretDim, AllocatorT>
  reinterpret(range<ReinterpretDim> reinterpretRange) const {
    if (sizeof(ReinterpretT) * reinterpretRange.size() != get_size())
      throw cl::sycl::invalid_object_error(
          "Total size in bytes represented by the type and range of the "
          "reinterpreted SYCL buffer does not equal the total size in bytes "
          "represented by the type and range of this SYCL buffer",
          PI_INVALID_VALUE);

    return buffer<ReinterpretT, ReinterpretDim, AllocatorT>(
        impl, reinterpretRange, OffsetInBytes, IsSubBuffer);
  }

  template <typename propertyT> bool has_property() const {
    return impl->template has_property<propertyT>();
  }

  template <typename propertyT> propertyT get_property() const {
    return impl->template get_property<propertyT>();
  }

private:
  shared_ptr_class<detail::buffer_impl> impl;
  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);
  template <typename A, int dims, typename C, typename Enable>
  friend class buffer;
  template <typename DataT, int dims, access::mode mode, access::target target,
            access::placeholder isPlaceholder, typename PropertyListT>
  friend class accessor;
  range<dimensions> Range;


  size_t OffsetInBytes = 0;
  bool IsSubBuffer = false;


  buffer(shared_ptr_class<detail::buffer_impl> Impl,
         range<dimensions> reinterpretRange, size_t reinterpretOffset,
         bool isSubBuffer)
      : impl(Impl), Range(reinterpretRange), OffsetInBytes(reinterpretOffset),
        IsSubBuffer(isSubBuffer){};

  template <typename Type, int N>
  size_t getOffsetInBytes(const id<N> &offset, const range<N> &range) {
    return detail::getLinearIndex(offset, range) * sizeof(Type);
  }

  bool isOutOfBounds(const id<dimensions> &offset,
                     const range<dimensions> &newRange,
                     const range<dimensions> &parentRange) {
    bool outOfBounds = false;
    for (int i = 0; i < dimensions; ++i)
      outOfBounds |= newRange[i] + offset[i] > parentRange[i];

    return outOfBounds;
  }

  bool isContiguousRegion(const id<1> &, const range<1> &, const range<1> &) {

    return true;
  }

  bool isContiguousRegion(const id<2> &offset, const range<2> &newRange,
                          const range<2> &parentRange) {






    if (offset[1])
      return newRange[0] == 1;
    return newRange[1] == parentRange[1];
  }

  bool isContiguousRegion(const id<3> &offset, const range<3> &newRange,
                          const range<3> &parentRange) {
# 407 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/buffer.hpp" 3
    if (offset[2])
      return newRange[0] == 1 && newRange[1] == 1;
    if (offset[1])
      return newRange[0] == 1 && newRange[2] == parentRange[2];
    return newRange[1] == parentRange[1] && newRange[2] == parentRange[2];
  }
};


template <class InputIterator, class AllocatorT>
buffer(InputIterator, InputIterator, AllocatorT, const property_list & = {})
    ->buffer<typename std::iterator_traits<InputIterator>::value_type, 1,
             AllocatorT>;
template <class InputIterator>
buffer(InputIterator, InputIterator, const property_list & = {})
    ->buffer<typename std::iterator_traits<InputIterator>::value_type, 1>;
template <class Container, class AllocatorT>
buffer(Container &, AllocatorT, const property_list & = {})
    ->buffer<typename Container::value_type, 1, AllocatorT>;
template <class Container>
buffer(Container &, const property_list & = {})
    ->buffer<typename Container::value_type, 1>;
template <class T, int dimensions, class AllocatorT>
buffer(const T *, const range<dimensions> &, AllocatorT,
       const property_list & = {})
    ->buffer<T, dimensions, AllocatorT>;
template <class T, int dimensions>
buffer(const T *, const range<dimensions> &, const property_list & = {})
    ->buffer<T, dimensions>;


}
}

namespace std {
template <typename T, int dimensions, typename AllocatorT>
struct hash<cl::sycl::buffer<T, dimensions, AllocatorT>> {
  size_t
  operator()(const cl::sycl::buffer<T, dimensions, AllocatorT> &b) const {
    return hash<std::shared_ptr<cl::sycl::detail::buffer_impl>>()(
        cl::sycl::detail::getSyclObjImpl(b));
  }
};
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/accessor_impl.hpp" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/accessor_impl.hpp" 3
inline namespace cl {
namespace sycl {
namespace INTEL {
namespace gpu {

class AccessorPrivateProxy;
}
}
}
}

inline namespace cl {
namespace sycl {
namespace detail {

class Command;






template <int Dims> class AccessorImplDevice {
public:
  AccessorImplDevice() = default;
  AccessorImplDevice(id<Dims> Offset, range<Dims> AccessRange,
                     range<Dims> MemoryRange)
      : Offset(Offset), AccessRange(AccessRange), MemRange(MemoryRange) {}

  id<Dims> Offset;
  range<Dims> AccessRange;
  range<Dims> MemRange;

  bool operator==(const AccessorImplDevice &Rhs) const {
    return (Offset == Rhs.Offset && AccessRange == Rhs.AccessRange &&
            MemRange == Rhs.MemRange);
  }
};

template <int Dims> class LocalAccessorBaseDevice {
public:
  LocalAccessorBaseDevice(sycl::range<Dims> Size)
      : AccessRange(Size),
        MemRange(InitializedVal<Dims, range>::template get<0>()) {}


  range<Dims> AccessRange;
  range<Dims> MemRange;
  id<Dims> Offset;

  bool operator==(const LocalAccessorBaseDevice &Rhs) const {
    return (AccessRange == Rhs.AccessRange);
  }
};






constexpr bool IsESIMDAccInit = false;




class __attribute__((visibility("default"))) AccessorImplHost {
public:
  AccessorImplHost(id<3> Offset, range<3> AccessRange, range<3> MemoryRange,
                   access::mode AccessMode, detail::SYCLMemObjI *SYCLMemObject,
                   int Dims, int ElemSize, int OffsetInBytes = 0,
                   bool IsSubBuffer = false, bool IsESIMDAcc = IsESIMDAccInit)
      : MOffset(Offset), MAccessRange(AccessRange), MMemoryRange(MemoryRange),
        MAccessMode(AccessMode), MSYCLMemObj(SYCLMemObject), MDims(Dims),
        MElemSize(ElemSize), MOffsetInBytes(OffsetInBytes),
        MIsSubBuffer(IsSubBuffer) {
    MIsESIMDAcc =
        IsESIMDAcc && (SYCLMemObject->getType() == SYCLMemObjI::BUFFER);
  }

  ~AccessorImplHost();

  AccessorImplHost(const AccessorImplHost &Other)
      : MOffset(Other.MOffset), MAccessRange(Other.MAccessRange),
        MMemoryRange(Other.MMemoryRange), MAccessMode(Other.MAccessMode),
        MSYCLMemObj(Other.MSYCLMemObj), MDims(Other.MDims),
        MElemSize(Other.MElemSize), MOffsetInBytes(Other.MOffsetInBytes),
        MIsSubBuffer(Other.MIsSubBuffer), MIsESIMDAcc(Other.MIsESIMDAcc) {}
# 115 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/accessor_impl.hpp" 3
  void resize(size_t GlobalSize);

  id<3> MOffset;

  range<3> MAccessRange;

  range<3> MMemoryRange;
  access::mode MAccessMode;

  detail::SYCLMemObjI *MSYCLMemObj;

  unsigned int MDims;
  unsigned int MElemSize;
  unsigned int MOffsetInBytes;
  bool MIsSubBuffer;

  void *MData = nullptr;

  Command *MBlockedCmd = nullptr;

  bool PerWI = false;


  bool MIsESIMDAcc;
};

using AccessorImplPtr = shared_ptr_class<AccessorImplHost>;

class AccessorBaseHost {
public:
  AccessorBaseHost(id<3> Offset, range<3> AccessRange, range<3> MemoryRange,
                   access::mode AccessMode, detail::SYCLMemObjI *SYCLMemObject,
                   int Dims, int ElemSize, int OffsetInBytes = 0,
                   bool IsSubBuffer = false) {
    impl = shared_ptr_class<AccessorImplHost>(new AccessorImplHost(
        Offset, AccessRange, MemoryRange, AccessMode, SYCLMemObject, Dims,
        ElemSize, OffsetInBytes, IsSubBuffer,
        IsESIMDAccInit && (SYCLMemObject->getType() == SYCLMemObjI::BUFFER)));
  }

protected:
  id<3> &getOffset() { return impl->MOffset; }
  range<3> &getAccessRange() { return impl->MAccessRange; }
  range<3> &getMemoryRange() { return impl->MMemoryRange; }
  void *getPtr() { return impl->MData; }
  unsigned int getElemSize() const { return impl->MElemSize; }

  const id<3> &getOffset() const { return impl->MOffset; }
  const range<3> &getAccessRange() const { return impl->MAccessRange; }
  const range<3> &getMemoryRange() const { return impl->MMemoryRange; }
  void *getPtr() const { return const_cast<void *>(impl->MData); }

  template <class Obj>
  friend decltype(Obj::impl) getSyclObjImpl(const Obj &SyclObject);

  template <typename, int, access::mode, access::target, access::placeholder,
            typename>
  friend class accessor;

  AccessorImplPtr impl;

private:
  friend class sycl::INTEL::gpu::AccessorPrivateProxy;
};

class __attribute__((visibility("default"))) LocalAccessorImplHost {
public:
  LocalAccessorImplHost(sycl::range<3> Size, int Dims, int ElemSize)
      : MSize(Size), MDims(Dims), MElemSize(ElemSize),
        MMem(Size[0] * Size[1] * Size[2] * ElemSize) {}

  sycl::range<3> MSize;
  int MDims;
  int MElemSize;
  std::vector<char> MMem;
};

using LocalAccessorImplPtr = shared_ptr_class<LocalAccessorImplHost>;

class LocalAccessorBaseHost {
public:
  LocalAccessorBaseHost(sycl::range<3> Size, int Dims, int ElemSize) {
    impl = shared_ptr_class<LocalAccessorImplHost>(
        new LocalAccessorImplHost(Size, Dims, ElemSize));
  }
  sycl::range<3> &getSize() { return impl->MSize; }
  const sycl::range<3> &getSize() const { return impl->MSize; }
  void *getPtr() { return impl->MMem.data(); }
  void *getPtr() const {
    return const_cast<void *>(reinterpret_cast<void *>(impl->MMem.data()));
  }

  int getNumOfDims() { return impl->MDims; }
  int getElementSize() { return impl->MElemSize; }

protected:
  template <class Obj>
  friend decltype(Obj::impl) getSyclObjImpl(const Obj &SyclObject);

  shared_ptr_class<LocalAccessorImplHost> impl;
};

using Requirement = AccessorImplHost;

void __attribute__((visibility("default"))) addHostAccessorAndWait(Requirement *Req);



template <typename MayBeTag1, typename MayBeTag2>
constexpr access::mode deduceAccessMode() {



  if constexpr (std::is_same<MayBeTag1,
                             mode_tag_t<access::mode::read>>::value ||
                std::is_same<MayBeTag2,
                             mode_tag_t<access::mode::read>>::value) {
    return access::mode::read;
  }

  if constexpr (std::is_same<MayBeTag1,
                             mode_tag_t<access::mode::write>>::value ||
                std::is_same<MayBeTag2,
                             mode_tag_t<access::mode::write>>::value) {
    return access::mode::write;
  }

  if constexpr (
      std::is_same<MayBeTag1,
                   mode_target_tag_t<access::mode::read,
                                     access::target::constant_buffer>>::value ||
      std::is_same<MayBeTag2,
                   mode_target_tag_t<access::mode::read,
                                     access::target::constant_buffer>>::value) {
    return access::mode::read;
  }

  return access::mode::read_write;
}

template <typename MayBeTag1, typename MayBeTag2>
constexpr access::target deduceAccessTarget(access::target defaultTarget) {
  if constexpr (
      std::is_same<MayBeTag1,
                   mode_target_tag_t<access::mode::read,
                                     access::target::constant_buffer>>::value ||
      std::is_same<MayBeTag2,
                   mode_target_tag_t<access::mode::read,
                                     access::target::constant_buffer>>::value) {
    return access::target::constant_buffer;
  }

  return defaultTarget;
}



}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/handler_proxy.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/handler_proxy.hpp" 3
inline namespace cl {
namespace sycl {

class handler;

namespace detail {

class AccessorBaseHost;

__attribute__((visibility("default"))) void associateWithHandler(handler &, AccessorBaseHost *,
                                        access::target);
}
}
}
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/builtins.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/builtins.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/boolean.hpp" 1 3
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/boolean.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {

template <int Num> struct Assigner {
  template <typename R, typename T> static void assign(R &r, const T x) {
    Assigner<Num - 1>::assign(r, x);
    r.template swizzle<Num>() = x.value[Num];
  }

  template <typename R, typename T, typename ET>
  static void init(R &r, const T x) {
    Assigner<Num - 1>::template init<R, T, ET>(r, x);
    ET v = x.template swizzle<Num>();
    r.value[Num] = msbIsSet(v) * (-1);
  }
};

template <> struct Assigner<0> {
  template <typename R, typename T> static void assign(R &r, const T x) {
    r.template swizzle<0>() = x.value[0];
  }
  template <typename R, typename T, typename ET>
  static void init(R &r, const T x) {
    ET v = x.template swizzle<0>();
    r.value[0] = msbIsSet(v) * (-1);
  }
};

template <int N> struct Boolean {
  static_assert(((N == 2) || (N == 3) || (N == 4) || (N == 8) || (N == 16)),
                "Invalid size");

  using element_type = int8_t;





  using DataType = element_type[N];


  Boolean() : value{0} {}

  Boolean(std::initializer_list<element_type> l) {
    for (size_t I = 0; I < N; ++I) {
      value[I] = *(l.begin() + I) ? -1 : 0;
    }
  }

  Boolean(const Boolean &rhs) {
    for (size_t I = 0; I < N; ++I) {
      value[I] = rhs.value[I];
    }
  }

  template <typename T> Boolean(const T rhs) {
    static_assert(is_vgeninteger<T>::value, "Invalid constructor");
    Assigner<N - 1>::template init<Boolean<N>, T, typename T::element_type>(
        *this, rhs);
  }
# 91 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/boolean.hpp" 3
  template <typename T> operator T() const {
    static_assert(is_vgeninteger<T>::value, "Invalid conversion");
    T r;
    Assigner<N - 1>::assign(r, *this);
    return r;
  }

private:
  template <int Num> friend struct Assigner;
  alignas(detail::vector_alignment<element_type, N>::value) DataType value;
};

template <> struct Boolean<1> {
  Boolean() = default;


  template <typename T> Boolean(T val) : value(val) {
    static_assert(is_sgeninteger<T>::value, "Invalid constructor");
  }


  template <typename T> operator T() const {
    static_assert(is_sgeninteger<T>::value, "Invalid conversion");
    return value;
  }
# 124 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/boolean.hpp" 3
private:
  alignas(1) bool value = false;
};

}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/builtins.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/builtins.hpp" 1 3
# 106 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/builtins.hpp" 3
inline namespace cl {
namespace __host_std {


template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_acos(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret acos(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = acos(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_acosh(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret acosh(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = acosh(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_acospi(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret acospi(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = acospi(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_asin(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret asin(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = asin(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_asinh(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret asinh(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = asinh(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_asinpi(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret asinpi(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = asinpi(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_atan(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret atan(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = atan(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_atan2(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret atan2(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = atan2(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_atanh(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret atanh(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = atanh(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_atanpi(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret atanpi(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = atanpi(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_atan2pi(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret atan2pi(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = atan2pi(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_cbrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret cbrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = cbrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_ceil(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret ceil(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = ceil(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_copysign(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret copysign(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = copysign(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_cos(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret cos(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = cos(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_cosh(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret cosh(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = cosh(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_cospi(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret cospi(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = cospi(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_erfc(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret erfc(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = erfc(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_erf(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret erf(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = erf(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_exp(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret exp(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = exp(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_exp2(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret exp2(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = exp2(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_exp10(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret exp10(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = exp10(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_expm1(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret expm1(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = expm1(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_fabs(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret fabs(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = fabs(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fdim(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fdim(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fdim(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_floor(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret floor(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = floor(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_fma(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret fma(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = fma(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fmax(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fmax(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fmax(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fmin(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fmin(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fmin(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fmod(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fmod(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fmod(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fract(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fract(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fract(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_frexp(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret frexp(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = frexp(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_hypot(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret hypot(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = hypot(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_ilogb(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret ilogb(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = ilogb(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_ldexp(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret ldexp(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = ldexp(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_lgamma(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret lgamma(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = lgamma(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_lgamma_r(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret lgamma_r(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = lgamma_r(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_log(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret log(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = log(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_log2(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret log2(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = log2(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_log10(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret log10(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = log10(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_log1p(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret log1p(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = log1p(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_logb(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret logb(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = logb(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_mad(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret mad(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = mad(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_maxmag(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret maxmag(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = maxmag(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_minmag(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret minmag(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = minmag(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_modf(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret modf(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = modf(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_nan(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret nan(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = nan(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_nextafter(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret nextafter(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = nextafter(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_pow(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret pow(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = pow(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_pown(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret pown(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = pown(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_powr(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret powr(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = powr(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_remainder(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret remainder(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = remainder(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_remquo(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret remquo(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = remquo(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_rint(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret rint(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = rint(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_rootn(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret rootn(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = rootn(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_round(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret round(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = round(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_rsqrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret rsqrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = rsqrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_sin(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret sin(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = sin(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_sincos(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret sincos(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = sincos(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_sinh(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret sinh(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = sinh(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_sinpi(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret sinpi(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = sinpi(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_sqrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret sqrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = sqrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_tan(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret tan(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = tan(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_tanh(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret tanh(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = tanh(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_tanpi(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret tanpi(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = tanpi(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_tgamma(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret tgamma(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = tgamma(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_trunc(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret trunc(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = trunc(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_cos(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_cos(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_cos(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_native_divide(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret native_divide(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = native_divide(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_exp(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_exp(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_exp(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_exp2(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_exp2(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_exp2(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_exp10(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_exp10(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_exp10(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_log(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_log(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_log(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_log2(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_log2(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_log2(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_log10(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_log10(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_log10(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_native_powr(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret native_powr(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = native_powr(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_recip(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_recip(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_recip(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_rsqrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_rsqrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_rsqrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_sin(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_sin(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_sin(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_sqrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_sqrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_sqrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_native_tan(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret native_tan(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = native_tan(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_cos(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_cos(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_cos(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_half_divide(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret half_divide(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = half_divide(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_exp(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_exp(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_exp(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_exp2(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_exp2(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_exp2(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_exp10(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_exp10(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_exp10(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_log(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_log(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_log(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_log2(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_log2(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_log2(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_log10(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_log10(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_log10(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_half_powr(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret half_powr(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = half_powr(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_recip(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_recip(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_recip(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_rsqrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_rsqrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_rsqrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_sin(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_sin(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_sin(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_sqrt(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_sqrt(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_sqrt(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_half_tan(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret half_tan(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = half_tan(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }

template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_s_abs(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret s_abs(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = s_abs(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_u_abs(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret u_abs(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = u_abs(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_abs_diff(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_abs_diff(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_abs_diff(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_abs_diff(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_abs_diff(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_abs_diff(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_add_sat(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_add_sat(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_add_sat(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_add_sat(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_add_sat(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_add_sat(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_hadd(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_hadd(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_hadd(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_hadd(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_hadd(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_hadd(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_rhadd(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_rhadd(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_rhadd(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_rhadd(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_rhadd(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_rhadd(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_s_clamp(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret s_clamp(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = s_clamp(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_u_clamp(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret u_clamp(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = u_clamp(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_clz(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret clz(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = clz(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_ctz(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret ctz(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = ctz(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_s_mad_hi(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret s_mad_hi(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = s_mad_hi(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_u_mad_hi(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret u_mad_hi(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = u_mad_hi(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_u_mad_sat(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret u_mad_sat(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = u_mad_sat(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_s_mad_sat(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret s_mad_sat(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = s_mad_sat(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_max(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_max(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_max(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_max(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_max(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_max(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_min(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_min(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_min(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_min(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_min(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_min(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_mul_hi(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_mul_hi(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_mul_hi(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_mul_hi(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_mul_hi(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_mul_hi(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_rotate(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret rotate(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = rotate(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_sub_sat(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_sub_sat(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_sub_sat(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_sub_sat(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_sub_sat(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_sub_sat(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_upsample(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_upsample(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_upsample(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_upsample(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_upsample(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_upsample(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_popcount(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret popcount(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = popcount(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_s_mad24(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret s_mad24(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = s_mad24(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_u_mad24(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret u_mad24(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = u_mad24(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_s_mul24(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret s_mul24(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = s_mul24(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_u_mul24(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret u_mul24(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = u_mul24(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }

template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_fclamp(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret fclamp(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = fclamp(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_degrees(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret degrees(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = degrees(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fmax_common(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fmax_common(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fmax_common(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fmin_common(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fmin_common(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fmin_common(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_mix(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret mix(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = mix(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_radians(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret radians(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = radians(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_step(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret step(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = step(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_smoothstep(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret smoothstep(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = smoothstep(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_sign(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret sign(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = sign(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }

template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_cross(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret cross(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = cross(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_Dot(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret Dot(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = Dot(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename T> inline __attribute__((always_inline)) T __invoke_FMul(T v1, T v2) { using Type = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Type FMul(Type, Type); Type arg1 = cl::sycl::detail::convertDataToType<T, Type>(v1); Type arg2 = cl::sycl::detail::convertDataToType<T, Type>(v2); Type ret = FMul(arg1, arg2); return cl::sycl::detail::convertDataToType<Type, T>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_distance(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret distance(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = distance(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_length(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret length(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = length(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_normalize(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret normalize(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = normalize(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2> inline __attribute__((always_inline)) R __invoke_fast_distance(T1 t1, T2 t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; extern Ret fast_distance(Arg1, Arg2); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Ret ret = fast_distance(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_fast_length(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret fast_length(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = fast_length(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_fast_normalize(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret fast_normalize(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = fast_normalize(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }

template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_FOrdEqual(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret FOrdEqual(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = FOrdEqual(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_FUnordNotEqual(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret FUnordNotEqual(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = FUnordNotEqual(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_FOrdGreaterThan(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret FOrdGreaterThan(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = FOrdGreaterThan(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_FOrdGreaterThanEqual(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret FOrdGreaterThanEqual(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = FOrdGreaterThanEqual(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }

template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_FOrdLessThan(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret FOrdLessThan(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = FOrdLessThan(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_FOrdLessThanEqual(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret FOrdLessThanEqual(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = FOrdLessThanEqual(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_LessOrGreater(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret LessOrGreater(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = LessOrGreater(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_IsFinite(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret IsFinite(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = IsFinite(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_IsInf(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret IsInf(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = IsInf(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_IsNan(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret IsNan(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = IsNan(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_IsNormal(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret IsNormal(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = IsNormal(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_Ordered(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret Ordered(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = Ordered(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T> inline __attribute__((always_inline)) R __invoke_Unordered(T t1, T t2) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg = cl::sycl::detail::ConvertToOpenCLType_t<T>; extern Ret Unordered(Arg, Arg); Arg arg1 = cl::sycl::detail::convertDataToType<T, Arg>(t1); Arg arg2 = cl::sycl::detail::convertDataToType<T, Arg>(t2); Ret ret = Unordered(arg1, arg2); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_SignBitSet(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret SignBitSet(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = SignBitSet(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_Any(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret Any(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = Any(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1> inline __attribute__((always_inline)) R __invoke_All(T1 t1) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; extern Ret All(Arg1); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Ret ret = All(arg1); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_bitselect(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret bitselect(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = bitselect(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }
template <typename R, typename T1, typename T2, typename T3> inline __attribute__((always_inline)) R __invoke_select(T1 t1, T2 t2, T3 t3) { using Ret = cl::sycl::detail::ConvertToOpenCLType_t<R>; using Arg1 = cl::sycl::detail::ConvertToOpenCLType_t<T1>; using Arg2 = cl::sycl::detail::ConvertToOpenCLType_t<T2>; using Arg3 = cl::sycl::detail::ConvertToOpenCLType_t<T3>; extern Ret select(Arg1, Arg2, Arg3); Arg1 arg1 = cl::sycl::detail::convertDataToType<T1, Arg1>(t1); Arg2 arg2 = cl::sycl::detail::convertDataToType<T2, Arg2>(t2); Arg3 arg3 = cl::sycl::detail::convertDataToType<T3, Arg3>(t3); Ret ret = select(arg1, arg2, arg3); return cl::sycl::detail::convertDataToType<Ret, R>(ret); }

}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/builtins.hpp" 2 3







inline namespace cl {
namespace sycl {



namespace __sycl_std = __host_std;




template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> acos(T x) {
  return __sycl_std::__invoke_acos<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> acosh(T x) {
  return __sycl_std::__invoke_acosh<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> acospi(T x) {
  return __sycl_std::__invoke_acospi<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> asin(T x) {
  return __sycl_std::__invoke_asin<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> asinh(T x) {
  return __sycl_std::__invoke_asinh<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> asinpi(T x) {
  return __sycl_std::__invoke_asinpi<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> atan(T y_over_x) {
  return __sycl_std::__invoke_atan<T>(y_over_x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> atan2(T y, T x) {
  return __sycl_std::__invoke_atan2<T>(y, x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> atanh(T x) {
  return __sycl_std::__invoke_atanh<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> atanpi(T x) {
  return __sycl_std::__invoke_atanpi<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> atan2pi(T y,
                                                              T x) {
  return __sycl_std::__invoke_atan2pi<T>(y, x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> cbrt(T x) {
  return __sycl_std::__invoke_cbrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> ceil(T x) {
  return __sycl_std::__invoke_ceil<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> copysign(T x,
                                                               T y) {
  return __sycl_std::__invoke_copysign<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> cos(T x) {
  return __sycl_std::__invoke_cos<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> cosh(T x) {
  return __sycl_std::__invoke_cosh<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> cospi(T x) {
  return __sycl_std::__invoke_cospi<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> erfc(T x) {
  return __sycl_std::__invoke_erfc<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> erf(T x) {
  return __sycl_std::__invoke_erf<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> exp(T x) {
  return __sycl_std::__invoke_exp<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> exp2(T x) {
  return __sycl_std::__invoke_exp2<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> exp10(T x) {
  return __sycl_std::__invoke_exp10<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> expm1(T x) {
  return __sycl_std::__invoke_expm1<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> fabs(T x) {
  return __sycl_std::__invoke_fabs<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> fdim(T x, T y) {
  return __sycl_std::__invoke_fdim<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> floor(T x) {
  return __sycl_std::__invoke_floor<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> fma(T a, T b,
                                                          T c) {
  return __sycl_std::__invoke_fma<T>(a, b, c);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> fmax(T x, T y) {
  return __sycl_std::__invoke_fmax<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>
fmax(T x, typename T::element_type y) {
  return __sycl_std::__invoke_fmax<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> fmin(T x, T y) {
  return __sycl_std::__invoke_fmin<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>
fmin(T x, typename T::element_type y) {
  return __sycl_std::__invoke_fmin<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> fmod(T x, T y) {
  return __sycl_std::__invoke_fmod<T>(x, y);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genfloatptr<T2>::value, T>
fract(T x, T2 iptr) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_fract<T>(x, iptr);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genintptr<T2>::value, T>
frexp(T x, T2 exp) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_frexp<T>(x, exp);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> hypot(T x, T y) {
  return __sycl_std::__invoke_hypot<T>(x, y);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::change_base_type_t<T, int> ilogb(T x) {
  return __sycl_std::__invoke_ilogb<detail::change_base_type_t<T, int>>(x);
}




template <typename T>
detail::enable_if_t<detail::is_sgenfloat<T>::value, T> ldexp(T x,
                                                             int k) {
  return __sycl_std::__invoke_ldexp<T>(x, k);
}


template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T> ldexp(T x,
                                                             int k) {
  return __sycl_std::__invoke_ldexp<T>(x, vec<int, T::get_count()>(k));
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_vgenfloat<T>::value && detail::is_intn<T2>::value, T>
ldexp(T x, T2 k) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_ldexp<T>(x, k);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> lgamma(T x) {
  return __sycl_std::__invoke_lgamma<T>(x);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genintptr<T2>::value, T>
lgamma_r(T x, T2 signp) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_lgamma_r<T>(x, signp);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> log(T x) {
  return __sycl_std::__invoke_log<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> log2(T x) {
  return __sycl_std::__invoke_log2<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> log10(T x) {
  return __sycl_std::__invoke_log10<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> log1p(T x) {
  return __sycl_std::__invoke_log1p<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> logb(T x) {
  return __sycl_std::__invoke_logb<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> mad(T a, T b,
                                                          T c) {
  return __sycl_std::__invoke_mad<T>(a, b, c);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> maxmag(T x, T y) {
  return __sycl_std::__invoke_maxmag<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> minmag(T x, T y) {
  return __sycl_std::__invoke_minmag<T>(x, y);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genfloatptr<T2>::value, T>
modf(T x, T2 iptr) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_modf<T>(x, iptr);
}

template <typename T,
          typename = detail::enable_if_t<detail::is_nan_type<T>::value, T>>
detail::nan_return_t<T> nan(T nancode) {
  return __sycl_std::__invoke_nan<detail::nan_return_t<T>>(
      detail::convert_data_type<T, detail::nan_argument_base_t<T>>()(nancode));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> nextafter(T x,
                                                                T y) {
  return __sycl_std::__invoke_nextafter<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> pow(T x, T y) {
  return __sycl_std::__invoke_pow<T>(x, y);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genint<T2>::value, T>
pown(T x, T2 y) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_pown<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> powr(T x, T y) {
  return __sycl_std::__invoke_powr<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> remainder(T x,
                                                                T y) {
  return __sycl_std::__invoke_remainder<T>(x, y);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genintptr<T2>::value, T>
remquo(T x, T y, T2 quo) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_remquo<T>(x, y, quo);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> rint(T x) {
  return __sycl_std::__invoke_rint<T>(x);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genint<T2>::value, T>
rootn(T x, T2 y) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_rootn<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> round(T x) {
  return __sycl_std::__invoke_round<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> rsqrt(T x) {
  return __sycl_std::__invoke_rsqrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> sin(T x) {
  return __sycl_std::__invoke_sin<T>(x);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloat<T>::value && detail::is_genfloatptr<T2>::value, T>
sincos(T x, T2 cosval) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_sincos<T>(x, cosval);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> sinh(T x) {
  return __sycl_std::__invoke_sinh<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> sinpi(T x) {
  return __sycl_std::__invoke_sinpi<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> sqrt(T x) {
  return __sycl_std::__invoke_sqrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> tan(T x) {
  return __sycl_std::__invoke_tan<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> tanh(T x) {
  return __sycl_std::__invoke_tanh<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> tanpi(T x) {
  return __sycl_std::__invoke_tanpi<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> tgamma(T x) {
  return __sycl_std::__invoke_tgamma<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> trunc(T x) {
  return __sycl_std::__invoke_trunc<T>(x);
}



template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> clamp(T x, T minval,
                                                            T maxval) {
  return __sycl_std::__invoke_fclamp<T>(x, minval, maxval);
}




template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>
clamp(T x, typename T::element_type minval,
      typename T::element_type maxval) {
  return __sycl_std::__invoke_fclamp<T>(x, T(minval), T(maxval));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T>
degrees(T radians) {
  return __sycl_std::__invoke_degrees<T>(radians);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> abs(T x) {
  return __sycl_std::__invoke_fabs<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T>(max)(T x, T y) {
  return __sycl_std::__invoke_fmax_common<T>(x, y);
}




template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>(max)(
    T x, typename T::element_type y) {
  return __sycl_std::__invoke_fmax_common<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T>(min)(T x, T y) {
  return __sycl_std::__invoke_fmin_common<T>(x, y);
}




template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>(min)(
    T x, typename T::element_type y) {
  return __sycl_std::__invoke_fmin_common<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> mix(T x, T y,
                                                          T a) {
  return __sycl_std::__invoke_mix<T>(x, y, a);
}




template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>
mix(T x, T y, typename T::element_type a) {
  return __sycl_std::__invoke_mix<T>(x, y, T(a));
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T>
radians(T degrees) {
  return __sycl_std::__invoke_radians<T>(degrees);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> step(T edge,
                                                           T x) {
  return __sycl_std::__invoke_step<T>(edge, x);
}




template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>
step(typename T::element_type edge, T x) {
  return __sycl_std::__invoke_step<T>(T(edge), x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T>
smoothstep(T edge0, T edge1, T x) {
  return __sycl_std::__invoke_smoothstep<T>(edge0, edge1, x);
}




template <typename T>
detail::enable_if_t<detail::is_vgenfloat<T>::value, T>
smoothstep(typename T::element_type edge0, typename T::element_type edge1,
           T x) {
  return __sycl_std::__invoke_smoothstep<T>(T(edge0), T(edge1), x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloat<T>::value, T> sign(T x) {
  return __sycl_std::__invoke_sign<T>(x);
}



template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> abs(T x) {
  return __sycl_std::__invoke_u_abs<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value,
                    detail::make_unsigned_t<T>>
abs(T x) {
  return __sycl_std::__invoke_s_abs<detail::make_unsigned_t<T>>(x);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> abs_diff(T x,
                                                                  T y) {
  return __sycl_std::__invoke_u_abs_diff<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value,
                    detail::make_unsigned_t<T>>
abs_diff(T x, T y) {
  return __sycl_std::__invoke_s_abs_diff<detail::make_unsigned_t<T>>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> add_sat(T x,
                                                                 T y) {
  return __sycl_std::__invoke_s_add_sat<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> add_sat(T x,
                                                                 T y) {
  return __sycl_std::__invoke_u_add_sat<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> hadd(T x,
                                                              T y) {
  return __sycl_std::__invoke_s_hadd<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> hadd(T x,
                                                              T y) {
  return __sycl_std::__invoke_u_hadd<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> rhadd(T x,
                                                               T y) {
  return __sycl_std::__invoke_s_rhadd<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> rhadd(T x,
                                                               T y) {
  return __sycl_std::__invoke_u_rhadd<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T>
clamp(T x, T minval, T maxval) {
  return __sycl_std::__invoke_s_clamp<T>(x, minval, maxval);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T>
clamp(T x, T minval, T maxval) {
  return __sycl_std::__invoke_u_clamp<T>(x, minval, maxval);
}


template <typename T>
detail::enable_if_t<detail::is_vigeninteger<T>::value, T>
clamp(T x, typename T::element_type minval,
      typename T::element_type maxval) {
  return __sycl_std::__invoke_s_clamp<T>(x, T(minval), T(maxval));
}


template <typename T>
detail::enable_if_t<detail::is_vugeninteger<T>::value, T>
clamp(T x, typename T::element_type minval,
      typename T::element_type maxval) {
  return __sycl_std::__invoke_u_clamp<T>(x, T(minval), T(maxval));
}


template <typename T>
detail::enable_if_t<detail::is_geninteger<T>::value, T> clz(T x) {
  return __sycl_std::__invoke_clz<T>(x);
}

namespace intel {

template <typename T>
sycl::detail::enable_if_t<sycl::detail::is_geninteger<T>::value, T>
ctz(T x) {
  return __sycl_std::__invoke_ctz<T>(x);
}
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> mad_hi(T x, T y,
                                                                T z) {
  return __sycl_std::__invoke_s_mad_hi<T>(x, y, z);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> mad_hi(T x, T y,
                                                                T z) {
  return __sycl_std::__invoke_u_mad_hi<T>(x, y, z);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> mad_sat(T a, T b,
                                                                 T c) {
  return __sycl_std::__invoke_s_mad_sat<T>(a, b, c);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> mad_sat(T a, T b,
                                                                 T c) {
  return __sycl_std::__invoke_u_mad_sat<T>(a, b, c);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T>(max)(T x,
                                                              T y) {
  return __sycl_std::__invoke_s_max<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T>(max)(T x,
                                                              T y) {
  return __sycl_std::__invoke_u_max<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_vigeninteger<T>::value, T>(max)(
    T x, typename T::element_type y) {
  return __sycl_std::__invoke_s_max<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_vugeninteger<T>::value, T>(max)(
    T x, typename T::element_type y) {
  return __sycl_std::__invoke_u_max<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T>(min)(T x,
                                                              T y) {
  return __sycl_std::__invoke_s_min<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T>(min)(T x,
                                                              T y) {
  return __sycl_std::__invoke_u_min<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_vigeninteger<T>::value, T>(min)(
    T x, typename T::element_type y) {
  return __sycl_std::__invoke_s_min<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_vugeninteger<T>::value, T>(min)(
    T x, typename T::element_type y) {
  return __sycl_std::__invoke_u_min<T>(x, T(y));
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> mul_hi(T x,
                                                                T y) {
  return __sycl_std::__invoke_s_mul_hi<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> mul_hi(T x,
                                                                T y) {
  return __sycl_std::__invoke_u_mul_hi<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_geninteger<T>::value, T> rotate(T v,
                                                               T i) {
  return __sycl_std::__invoke_rotate<T>(v, i);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger<T>::value, T> sub_sat(T x,
                                                                 T y) {
  return __sycl_std::__invoke_s_sub_sat<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger<T>::value, T> sub_sat(T x,
                                                                 T y) {
  return __sycl_std::__invoke_u_sub_sat<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger8bit<T>::value,
                    detail::make_larger_t<T>>
upsample(T hi, T lo) {
  return __sycl_std::__invoke_u_upsample<detail::make_larger_t<T>>(hi, lo);
}


template <typename T, typename T2>
detail::enable_if_t<detail::is_igeninteger8bit<T>::value &&
                        detail::is_ugeninteger8bit<T2>::value,
                    detail::make_larger_t<T>>
upsample(T hi, T2 lo) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_s_upsample<detail::make_larger_t<T>>(hi, lo);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger16bit<T>::value,
                    detail::make_larger_t<T>>
upsample(T hi, T lo) {
  return __sycl_std::__invoke_u_upsample<detail::make_larger_t<T>>(hi, lo);
}


template <typename T, typename T2>
detail::enable_if_t<detail::is_igeninteger16bit<T>::value &&
                        detail::is_ugeninteger16bit<T2>::value,
                    detail::make_larger_t<T>>
upsample(T hi, T2 lo) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_s_upsample<detail::make_larger_t<T>>(hi, lo);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger32bit<T>::value,
                    detail::make_larger_t<T>>
upsample(T hi, T lo) {
  return __sycl_std::__invoke_u_upsample<detail::make_larger_t<T>>(hi, lo);
}


template <typename T, typename T2>
detail::enable_if_t<detail::is_igeninteger32bit<T>::value &&
                        detail::is_ugeninteger32bit<T2>::value,
                    detail::make_larger_t<T>>
upsample(T hi, T2 lo) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_s_upsample<detail::make_larger_t<T>>(hi, lo);
}


template <typename T>
detail::enable_if_t<detail::is_geninteger<T>::value, T> popcount(T x) {
  return __sycl_std::__invoke_popcount<T>(x);
}



template <typename T>
detail::enable_if_t<detail::is_igeninteger32bit<T>::value, T>
mad24(T x, T y, T z) {
  return __sycl_std::__invoke_s_mad24<T>(x, y, z);
}



template <typename T>
detail::enable_if_t<detail::is_ugeninteger32bit<T>::value, T>
mad24(T x, T y, T z) {
  return __sycl_std::__invoke_u_mad24<T>(x, y, z);
}


template <typename T>
detail::enable_if_t<detail::is_igeninteger32bit<T>::value, T>
mul24(T x, T y) {
  return __sycl_std::__invoke_s_mul24<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_ugeninteger32bit<T>::value, T>
mul24(T x, T y) {
  return __sycl_std::__invoke_u_mul24<T>(x, y);
}
# 952 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/builtins.hpp" 3
template <typename T>
detail::enable_if_t<detail::is_gencrossfloat<T>::value, T> cross(T p0,
                                                                 T p1) {
  return __sycl_std::__invoke_cross<T>(p0, p1);
}




template <typename T>
detail::enable_if_t<detail::is_sgenfloat<T>::value, T> dot(T p0, T p1) {
  return p0 * p1;
}


template <typename T>
detail::enable_if_t<detail::is_vgengeofloat<T>::value, float>
dot(T p0, T p1) {
  return __sycl_std::__invoke_Dot<float>(p0, p1);
}


template <typename T>
detail::enable_if_t<detail::is_vgengeodouble<T>::value, double>
dot(T p0, T p1) {
  return __sycl_std::__invoke_Dot<double>(p0, p1);
}


template <typename T>
detail::enable_if_t<detail::is_vgengeohalf<T>::value, half> dot(T p0,
                                                                T p1) {
  return __sycl_std::__invoke_Dot<half>(p0, p1);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeofloat<T>::value, T>>
float distance(T p0, T p1) {
  return __sycl_std::__invoke_distance<float>(p0, p1);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeodouble<T>::value, T>>
double distance(T p0, T p1) {
  return __sycl_std::__invoke_distance<double>(p0, p1);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeohalf<T>::value, T>>
half distance(T p0, T p1) {
  return __sycl_std::__invoke_distance<half>(p0, p1);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeofloat<T>::value, T>>
float length(T p) {
  return __sycl_std::__invoke_length<float>(p);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeodouble<T>::value, T>>
double length(T p) {
  return __sycl_std::__invoke_length<double>(p);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeohalf<T>::value, T>>
half length(T p) {
  return __sycl_std::__invoke_length<half>(p);
}


template <typename T>
detail::enable_if_t<detail::is_gengeofloat<T>::value, T>
normalize(T p) {
  return __sycl_std::__invoke_normalize<T>(p);
}


template <typename T>
detail::enable_if_t<detail::is_gengeodouble<T>::value, T>
normalize(T p) {
  return __sycl_std::__invoke_normalize<T>(p);
}


template <typename T>
detail::enable_if_t<detail::is_gengeohalf<T>::value, T> normalize(T p) {
  return __sycl_std::__invoke_normalize<T>(p);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeofloat<T>::value, T>>
float fast_distance(T p0, T p1) {
  return __sycl_std::__invoke_fast_distance<float>(p0, p1);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeodouble<T>::value, T>>
double fast_distance(T p0, T p1) {
  return __sycl_std::__invoke_fast_distance<double>(p0, p1);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeofloat<T>::value, T>>
float fast_length(T p) {
  return __sycl_std::__invoke_fast_length<float>(p);
}


template <typename T,
          typename = detail::enable_if_t<detail::is_gengeodouble<T>::value, T>>
double fast_length(T p) {
  return __sycl_std::__invoke_fast_length<double>(p);
}


template <typename T>
detail::enable_if_t<detail::is_gengeofloat<T>::value, T>
fast_normalize(T p) {
  return __sycl_std::__invoke_fast_normalize<T>(p);
}


template <typename T>
detail::enable_if_t<detail::is_gengeodouble<T>::value, T>
fast_normalize(T p) {
  return __sycl_std::__invoke_fast_normalize<T>(p);
}







template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isequal(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_FOrdEqual<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isnotequal(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_FUnordNotEqual<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isgreater(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_FOrdGreaterThan<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isgreaterequal(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_FOrdGreaterThanEqual<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isless(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_FOrdLessThan<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> islessequal(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_FOrdLessThanEqual<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> islessgreater(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_LessOrGreater<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isfinite(T x) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_IsFinite<detail::rel_ret_t<T>>(x));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isinf(T x) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_IsInf<detail::rel_ret_t<T>>(x));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isnan(T x) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_IsNan<detail::rel_ret_t<T>>(x));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isnormal(T x) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_IsNormal<detail::rel_ret_t<T>>(x));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isordered(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_Ordered<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> isunordered(T x, T y) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_Unordered<detail::rel_ret_t<T>>(x, y));
}






template <typename T,
          typename = detail::enable_if_t<detail::is_genfloat<T>::value, T>>
detail::common_rel_ret_t<T> signbit(T x) {
  return detail::RelConverter<T>::apply(
      __sycl_std::__invoke_SignBitSet<detail::rel_ret_t<T>>(x));
}


template <typename T>
detail::enable_if_t<detail::is_sigeninteger<T>::value, int> any(T x) {
  return detail::Boolean<1>(int(detail::msbIsSet(x)));
}


template <typename T>
detail::enable_if_t<detail::is_vigeninteger<T>::value, int> any(T x) {
  return detail::rel_sign_bit_test_ret_t<T>(
      __sycl_std::__invoke_Any<detail::rel_sign_bit_test_ret_t<T>>(
          detail::rel_sign_bit_test_arg_t<T>(x)));
}


template <typename T>
detail::enable_if_t<detail::is_sigeninteger<T>::value, int> all(T x) {
  return detail::Boolean<1>(int(detail::msbIsSet(x)));
}


template <typename T>
detail::enable_if_t<detail::is_vigeninteger<T>::value, int> all(T x) {
  return detail::rel_sign_bit_test_ret_t<T>(
      __sycl_std::__invoke_All<detail::rel_sign_bit_test_ret_t<T>>(
          detail::rel_sign_bit_test_arg_t<T>(x)));
}


template <typename T>
detail::enable_if_t<detail::is_gentype<T>::value, T> bitselect(T a, T b,
                                                               T c) {
  return __sycl_std::__invoke_bitselect<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_geninteger<T>::value && detail::is_igeninteger<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_geninteger<T>::value && detail::is_ugeninteger<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloatf<T>::value && detail::is_genint<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloatf<T>::value && detail::is_ugenint<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloatd<T>::value && detail::is_igeninteger64bit<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloatd<T>::value && detail::is_ugeninteger64bit<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloath<T>::value && detail::is_igeninteger16bit<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}


template <typename T, typename T2>
detail::enable_if_t<
    detail::is_genfloath<T>::value && detail::is_ugeninteger16bit<T2>::value, T>
select(T a, T b, T2 c) {
  detail::check_vector_size<T, T2>();
  return __sycl_std::__invoke_select<T>(a, b, c);
}

namespace native {


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> cos(T x) {
  return __sycl_std::__invoke_native_cos<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> divide(T x,
                                                              T y) {
  return __sycl_std::__invoke_native_divide<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> exp(T x) {
  return __sycl_std::__invoke_native_exp<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> exp2(T x) {
  return __sycl_std::__invoke_native_exp2<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> exp10(T x) {
  return __sycl_std::__invoke_native_exp10<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> log(T x) {
  return __sycl_std::__invoke_native_log<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> log2(T x) {
  return __sycl_std::__invoke_native_log2<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> log10(T x) {
  return __sycl_std::__invoke_native_log10<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> powr(T x, T y) {
  return __sycl_std::__invoke_native_powr<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> recip(T x) {
  return __sycl_std::__invoke_native_recip<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> rsqrt(T x) {
  return __sycl_std::__invoke_native_rsqrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> sin(T x) {
  return __sycl_std::__invoke_native_sin<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> sqrt(T x) {
  return __sycl_std::__invoke_native_sqrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> tan(T x) {
  return __sycl_std::__invoke_native_tan<T>(x);
}

}
namespace half_precision {


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> cos(T x) {
  return __sycl_std::__invoke_half_cos<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> divide(T x,
                                                              T y) {
  return __sycl_std::__invoke_half_divide<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> exp(T x) {
  return __sycl_std::__invoke_half_exp<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> exp2(T x) {
  return __sycl_std::__invoke_half_exp2<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> exp10(T x) {
  return __sycl_std::__invoke_half_exp10<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> log(T x) {
  return __sycl_std::__invoke_half_log<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> log2(T x) {
  return __sycl_std::__invoke_half_log2<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> log10(T x) {
  return __sycl_std::__invoke_half_log10<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> powr(T x, T y) {
  return __sycl_std::__invoke_half_powr<T>(x, y);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> recip(T x) {
  return __sycl_std::__invoke_half_recip<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> rsqrt(T x) {
  return __sycl_std::__invoke_half_rsqrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> sin(T x) {
  return __sycl_std::__invoke_half_sin<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> sqrt(T x) {
  return __sycl_std::__invoke_half_sqrt<T>(x);
}


template <typename T>
detail::enable_if_t<detail::is_genfloatf<T>::value, T> tan(T x) {
  return __sycl_std::__invoke_half_tan<T>(x);
}

}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/image.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/image.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_impl.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_impl.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/aligned_allocator.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/aligned_allocator.hpp" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/aligned_allocator.hpp" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstring" 3
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/aligned_allocator.hpp" 2 3



inline namespace cl {
namespace sycl {
namespace detail {
template <typename T> class aligned_allocator {
public:
  using value_type = T;
  using pointer = T*;
  using const_pointer = const T*;
  using reference = T&;
  using const_reference = const T&;

public:
  template <typename U> struct rebind { typedef aligned_allocator<U> other; };

  aligned_allocator() = default;
  ~aligned_allocator() = default;

  explicit aligned_allocator(size_t Alignment) : MAlignment(Alignment) {}


  void construct(pointer Ptr, const_reference Val) {
    new (Ptr) value_type(Val);
  }


  void destroy(pointer Ptr) { Ptr->~value_type(); }

  pointer address(reference Val) const { return &Val; }
  const_pointer address(const_reference Val) { return &Val; }


  pointer allocate(size_t Size) {
    size_t NumBytes = Size * sizeof(value_type);
    NumBytes = ((NumBytes - 1) | (MAlignment - 1)) + 1;
    if (Size > NumBytes)
      throw std::bad_alloc();

    pointer Result = reinterpret_cast<pointer>(
        detail::OSUtil::alignedAlloc(MAlignment, NumBytes));
    if (!Result)
      throw std::bad_alloc();
    return Result;
  }


  void deallocate(pointer Ptr, size_t) {
    if (Ptr)
      detail::OSUtil::alignedFree(Ptr);
  }

  bool operator==(const aligned_allocator &) { return true; }
  bool operator!=(const aligned_allocator &) { return false; }

  void setAlignment(size_t Alignment) { MAlignment = Alignment; }

private:

  size_t MAlignment = 128;
};
}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_impl.hpp" 2 3




# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/aspects.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/aspects.hpp" 3
inline namespace cl {
namespace sycl {

enum class aspect {
  host,
  cpu,
  gpu,
  accelerator,
  custom,
  fp16,
  fp64,
  int64_base_atomics,
  int64_extended_atomics,
  image,
  online_compiler,
  online_linker,
  queue_profiling,
  usm_device_allocations,
  usm_host_allocations,
  usm_shared_allocations,
  usm_restricted_shared_allocations,
  usm_system_allocator
};

}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 2 3




# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/platform.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/platform.hpp" 3
inline namespace cl {
namespace sycl {



class device_selector;
class device;
namespace detail {
class platform_impl;
}




class __attribute__((visibility("default"))) platform {
public:

  platform();







  explicit platform(cl_platform_id PlatformId);
# 50 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/platform.hpp" 3
  explicit platform(const device_selector &DeviceSelector);

  platform(const platform &rhs) = default;

  platform(platform &&rhs) = default;

  platform &operator=(const platform &rhs) = default;

  platform &operator=(platform &&rhs) = default;

  bool operator==(const platform &rhs) const { return impl == rhs.impl; }

  bool operator!=(const platform &rhs) const { return !(*this == rhs); }




  cl_platform_id get() const;





  bool has_extension(const string_class &ExtensionName) const;




  bool is_host() const;
# 88 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/platform.hpp" 3
  vector_class<device>
  get_devices(info::device_type DeviceType = info::device_type::all) const;




  template <info::platform param>
  typename info::param_traits<info::platform, param>::return_type
  get_info() const;






  static vector_class<platform> get_platforms();




  backend get_backend() const noexcept;




  template <backend BackendName>
  auto get_native() const -> typename interop<BackendName, platform>::type {
    return reinterpret_cast<typename interop<BackendName, platform>::type>(
        getNative());
  }
# 127 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/platform.hpp" 3
  bool has(aspect Aspect) const;

private:
  pi_native_handle getNative() const;

  shared_ptr_class<detail::platform_impl> impl;
  platform(shared_ptr_class<detail::platform_impl> impl) : impl(impl) {}

  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);
  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);

};
}
}

namespace std {
template <> struct hash<cl::sycl::platform> {
  size_t operator()(const cl::sycl::platform &p) const {
    return hash<cl::sycl::shared_ptr_class<cl::sycl::detail::platform_impl>>()(
        cl::sycl::detail::getSyclObjImpl(p));
  }
};
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 2 3





inline namespace cl {
namespace sycl {

class device_selector;
namespace detail {
class device_impl;
}





class __attribute__((visibility("default"))) device {
public:

  device();





  explicit device(cl_device_id DeviceId);





  explicit device(const device_selector &DeviceSelector);

  bool operator==(const device &rhs) const { return impl == rhs.impl; }

  bool operator!=(const device &rhs) const { return !(*this == rhs); }

  device(const device &rhs) = default;

  device(device &&rhs) = default;

  device &operator=(const device &rhs) = default;

  device &operator=(device &&rhs) = default;





  cl_device_id get() const;




  bool is_host() const;




  bool is_cpu() const;




  bool is_gpu() const;




  bool is_accelerator() const;
# 99 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
  platform get_platform() const;
# 112 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
  template <info::partition_property prop>
  vector_class<device> create_sub_devices(size_t ComputeUnits) const;
# 125 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
  template <info::partition_property prop>
  vector_class<device>
  create_sub_devices(const vector_class<size_t> &Counts) const;
# 142 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
  template <info::partition_property prop>
  vector_class<device>
  create_sub_devices(info::partition_affinity_domain AffinityDomain) const;
# 154 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
  template <info::device param>
  typename info::param_traits<info::device, param>::return_type
  get_info() const;





  bool has_extension(const string_class &extension_name) const;
# 172 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device.hpp" 3
  static vector_class<device>
  get_devices(info::device_type deviceType = info::device_type::all);




  template <backend BackendName>
  auto get_native() const -> typename interop<BackendName, device>::type {
    return (typename interop<BackendName, device>::type)getNative();
  }







  bool has(aspect Aspect) const;

private:
  shared_ptr_class<detail::device_impl> impl;
  device(shared_ptr_class<detail::device_impl> impl) : impl(impl) {}

  pi_native_handle getNative() const;

  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);

  template <class T>
  friend
      typename std::add_pointer<typename decltype(T::impl)::element_type>::type
      detail::getRawSyclObjImpl(const T &SyclObject);

  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);
};

}
}

namespace std {
template <> struct hash<cl::sycl::device> {
  size_t operator()(const cl::sycl::device &Device) const {
    return hash<cl::sycl::shared_ptr_class<cl::sycl::detail::device_impl>>()(
        cl::sycl::detail::getSyclObjImpl(Device));
  }
};
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_impl.hpp" 2 3





inline namespace cl {
namespace sycl {


enum class image_channel_order : unsigned int;
enum class image_channel_type : unsigned int;

template <int Dimensions, typename AllocatorT> class image;
template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder,
          typename property_listT>
class accessor;
class handler;

namespace detail {


using image_allocator = aligned_allocator<byte>;


__attribute__((visibility("default"))) uint8_t getImageNumberChannels(image_channel_order Order);


__attribute__((visibility("default"))) uint8_t getImageElementSize(uint8_t NumChannels,
                                          image_channel_type Type);

__attribute__((visibility("default"))) RT::PiMemImageChannelOrder
convertChannelOrder(image_channel_order Order);

__attribute__((visibility("default"))) image_channel_order
convertChannelOrder(RT::PiMemImageChannelOrder Order);

__attribute__((visibility("default"))) RT::PiMemImageChannelType
convertChannelType(image_channel_type Type);

__attribute__((visibility("default"))) image_channel_type
convertChannelType(RT::PiMemImageChannelType Type);


template <typename T>
using is_validImageDataT = typename detail::is_contained<
    T, type_list<cl_int4, cl_uint4, cl_float4, cl_half4>>::type;

template <typename DataT>
using EnableIfImgAccDataT =
    typename std::enable_if<is_validImageDataT<DataT>::value, DataT>::type;

template <int Dimensions>
class __attribute__((visibility("default"))) image_impl final : public SYCLMemObjT {
  using BaseT = SYCLMemObjT;
  using typename BaseT::MemObjType;

private:
  template <bool B>
  using EnableIfPitchT =
      typename std::enable_if<B, range<Dimensions - 1>>::type;
  static_assert(Dimensions >= 1 || Dimensions <= 3,
                "Dimensions of cl::sycl::image can be 1, 2 or 3");

  void setPitches() {
    size_t WHD[3] = {1, 1, 1};
    for (int I = 0; I < Dimensions; I++)
      WHD[I] = MRange[I];
    MRowPitch = MElementSize * WHD[0];
    MSlicePitch = MRowPitch * WHD[1];
    BaseT::MSizeInBytes = MSlicePitch * WHD[2];
  }

  template <bool B = (Dimensions > 1)>
  void setPitches(const EnableIfPitchT<B> Pitch) {
    MRowPitch = Pitch[0];
    MSlicePitch =
        (Dimensions == 3) ? Pitch[1] : MRowPitch;

    size_t NumSlices =
        (Dimensions == 3) ? MRange[2] : MRange[1];
    BaseT::MSizeInBytes = MSlicePitch * NumSlices;
  }

public:
  image_impl(image_channel_order Order, image_channel_type Type,
             const range<Dimensions> &ImageRange,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : image_impl((void *)nullptr, Order, Type, ImageRange,
                   std::move(Allocator), PropList) {}

  template <bool B = (Dimensions > 1)>
  image_impl(image_channel_order Order, image_channel_type Type,
             const range<Dimensions> &ImageRange,
             const EnableIfPitchT<B> &Pitch,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : image_impl((void *)nullptr, Order, Type, ImageRange, Pitch,
                   std::move(Allocator), PropList) {}

  image_impl(void *HData, image_channel_order Order, image_channel_type Type,
             const range<Dimensions> &ImageRange,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : BaseT(PropList, std::move(Allocator)), MRange(ImageRange),
        MOrder(Order), MType(Type),
        MNumChannels(getImageNumberChannels(MOrder)),
        MElementSize(getImageElementSize(MNumChannels, MType)) {
    setPitches();
    BaseT::handleHostData(HData, detail::getNextPowerOfTwo(MElementSize));
  }

  image_impl(const void *HData, image_channel_order Order,
             image_channel_type Type, const range<Dimensions> &ImageRange,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : BaseT(PropList, std::move(Allocator)), MRange(ImageRange),
        MOrder(Order), MType(Type),
        MNumChannels(getImageNumberChannels(MOrder)),
        MElementSize(getImageElementSize(MNumChannels, MType)) {
    setPitches();
    BaseT::handleHostData(HData, detail::getNextPowerOfTwo(MElementSize));
  }

  template <bool B = (Dimensions > 1)>
  image_impl(void *HData, image_channel_order Order, image_channel_type Type,
             const range<Dimensions> &ImageRange,
             const EnableIfPitchT<B> &Pitch,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : BaseT(PropList, std::move(Allocator)), MRange(ImageRange),
        MOrder(Order), MType(Type),
        MNumChannels(getImageNumberChannels(MOrder)),
        MElementSize(getImageElementSize(MNumChannels, MType)) {
    setPitches(Pitch);
    BaseT::handleHostData(HData, detail::getNextPowerOfTwo(MElementSize));
  }

  image_impl(shared_ptr_class<void> &HData, image_channel_order Order,
             image_channel_type Type, const range<Dimensions> &ImageRange,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : BaseT(PropList, std::move(Allocator)), MRange(ImageRange),
        MOrder(Order), MType(Type),
        MNumChannels(getImageNumberChannels(MOrder)),
        MElementSize(getImageElementSize(MNumChannels, MType)) {
    setPitches();
    BaseT::handleHostData(HData, detail::getNextPowerOfTwo(MElementSize));
  }


  template <bool B = (Dimensions > 1)>
  image_impl(shared_ptr_class<void> &HData, image_channel_order Order,
             image_channel_type Type, const range<Dimensions> &ImageRange,
             const EnableIfPitchT<B> &Pitch,
             unique_ptr_class<SYCLMemObjAllocator> Allocator,
             const property_list &PropList = {})
      : BaseT(PropList, std::move(Allocator)), MRange(ImageRange),
        MOrder(Order), MType(Type),
        MNumChannels(getImageNumberChannels(MOrder)),
        MElementSize(getImageElementSize(MNumChannels, MType)) {
    setPitches(Pitch);
    BaseT::handleHostData(HData, detail::getNextPowerOfTwo(MElementSize));
  }

  image_impl(cl_mem MemObject, const context &SyclContext, event AvailableEvent,
             unique_ptr_class<SYCLMemObjAllocator> Allocator);



  range<Dimensions> get_range() const { return MRange; }



  template <bool B = (Dimensions == 2)>
  typename std::enable_if<B, range<1>>::type get_pitch() const {
    range<1> Temp = range<1>(MRowPitch);
    return Temp;
  }



  template <bool B = (Dimensions == 3)>
  typename std::enable_if<B, range<2>>::type get_pitch() const {
    range<2> Temp = range<2>(MRowPitch, MSlicePitch);
    return Temp;
  }


  size_t get_count() const { return MRange.size(); }

  void *allocateMem(ContextImplPtr Context, bool InitFromUserData,
                    void *HostPtr, RT::PiEvent &OutEventToWait) override;

  MemObjType getType() const override { return MemObjType::IMAGE; }




  size_t getElementSize() const { return MElementSize; };

  image_channel_order getChannelOrder() const { return MOrder; }

  image_channel_type getChannelType() const { return MType; }

  size_t getRowPitch() const { return MRowPitch; }

  size_t getSlicePitch() const { return MSlicePitch; }

  ~image_impl() {
    try {
      BaseT::updateHostMemory();
    } catch (...) {
    }
  }

private:
  vector_class<device> getDevices(const ContextImplPtr Context);

  RT::PiMemObjectType getImageType() {
    if (Dimensions == 1)
      return (MIsArrayImage ? PI_MEM_TYPE_IMAGE1D_ARRAY : PI_MEM_TYPE_IMAGE1D);
    if (Dimensions == 2)
      return (MIsArrayImage ? PI_MEM_TYPE_IMAGE2D_ARRAY : PI_MEM_TYPE_IMAGE2D);
    return PI_MEM_TYPE_IMAGE3D;
  }

  RT::PiMemImageDesc getImageDesc(bool InitFromHostPtr) {
    RT::PiMemImageDesc Desc;
    Desc.image_type = getImageType();
    Desc.image_width = MRange[0];
    Desc.image_height = Dimensions > 1 ? MRange[1] : 1;
    Desc.image_depth = Dimensions > 2 ? MRange[2] : 1;

    Desc.image_array_size = 0;

    Desc.image_row_pitch = InitFromHostPtr ? MRowPitch : 0;
    Desc.image_slice_pitch = InitFromHostPtr ? MSlicePitch : 0;

    Desc.num_mip_levels = 0;
    Desc.num_samples = 0;
    Desc.buffer = nullptr;
    return Desc;
  }

  bool checkImageDesc(const RT::PiMemImageDesc &Desc, ContextImplPtr Context,
                      void *UserPtr);

  RT::PiMemImageFormat getImageFormat() {
    RT::PiMemImageFormat Format;
    Format.image_channel_order = detail::convertChannelOrder(MOrder);
    Format.image_channel_data_type = detail::convertChannelType(MType);
    return Format;
  }

  bool checkImageFormat(const RT::PiMemImageFormat &Format,
                        ContextImplPtr Context);

  bool MIsArrayImage = false;
  range<Dimensions> MRange;
  image_channel_order MOrder;
  image_channel_type MType;
  uint8_t MNumChannels = 0;
  size_t MElementSize = 0;
  size_t MRowPitch = 0;
  size_t MSlicePitch = 0;
};
}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/image.hpp" 2 3





inline namespace cl {
namespace sycl {

enum class image_channel_order : unsigned int {
  a,
  r,
  rx,
  rg,
  rgx,
  ra,
  rgb,
  rgbx,
  rgba,
  argb,
  bgra,
  intensity,
  luminance,
  abgr
};

enum class image_channel_type : unsigned int {
  snorm_int8,
  snorm_int16,
  unorm_int8,
  unorm_int16,
  unorm_short_565,
  unorm_short_555,
  unorm_int_101010,
  signed_int8,
  signed_int16,
  signed_int32,
  unsigned_int8,
  unsigned_int16,
  unsigned_int32,
  fp16,
  fp32
};

using byte = unsigned char;

using image_allocator = detail::aligned_allocator<byte>;
# 71 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/image.hpp" 3
template <int Dimensions = 1, typename AllocatorT = cl::sycl::image_allocator>
class image {
public:
  image(image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }

  image(image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range, AllocatorT Allocator,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }


  template <bool B = (Dimensions > 1)>
  image(image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range,
        const typename std::enable_if<B, range<Dimensions - 1>>::type &Pitch,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        Order, Type, Range, Pitch,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }


  template <bool B = (Dimensions > 1)>
  image(image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range,
        const typename std::enable_if<B, range<Dimensions - 1>>::type &Pitch,
        AllocatorT Allocator, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        Order, Type, Range, Pitch,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }

  image(void *HostPointer, image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }

  image(void *HostPointer, image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range, AllocatorT Allocator,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }

  image(const void *HostPointer, image_channel_order Order,
        image_channel_type Type, const range<Dimensions> &Range,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }

  image(const void *HostPointer, image_channel_order Order,
        image_channel_type Type, const range<Dimensions> &Range,
        AllocatorT Allocator, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }


  template <bool B = (Dimensions > 1)>
  image(void *HostPointer, image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range,
        const typename std::enable_if<B, range<Dimensions - 1>>::type &Pitch,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range, Pitch,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }


  template <bool B = (Dimensions > 1)>
  image(void *HostPointer, image_channel_order Order, image_channel_type Type,
        const range<Dimensions> &Range,
        const typename std::enable_if<B, range<Dimensions - 1>>::type &Pitch,
        AllocatorT Allocator, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range, Pitch,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }

  image(shared_ptr_class<void> &HostPointer, image_channel_order Order,
        image_channel_type Type, const range<Dimensions> &Range,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }

  image(shared_ptr_class<void> &HostPointer, image_channel_order Order,
        image_channel_type Type, const range<Dimensions> &Range,
        AllocatorT Allocator, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }


  template <bool B = (Dimensions > 1)>
  image(shared_ptr_class<void> &HostPointer, image_channel_order Order,
        image_channel_type Type, const range<Dimensions> &Range,
        const typename std::enable_if<B, range<Dimensions - 1>>::type &Pitch,
        const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range, Pitch,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(),
        PropList);
  }


  template <bool B = (Dimensions > 1)>
  image(shared_ptr_class<void> &HostPointer, image_channel_order Order,
        image_channel_type Type, const range<Dimensions> &Range,
        const typename std::enable_if<B, range<Dimensions - 1>>::type &Pitch,
        AllocatorT Allocator, const property_list &PropList = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        HostPointer, Order, Type, Range, Pitch,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>(
            Allocator),
        PropList);
  }

  image(cl_mem ClMemObject, const context &SyclContext,
        event AvailableEvent = {}) {
    impl = std::make_shared<detail::image_impl<Dimensions>>(
        ClMemObject, SyclContext, AvailableEvent,
        make_unique_ptr<detail::SYCLMemObjAllocatorHolder<AllocatorT>>());
  }



  image(const image &rhs) = default;

  image(image &&rhs) = default;

  image &operator=(const image &rhs) = default;

  image &operator=(image &&rhs) = default;

  ~image() = default;

  bool operator==(const image &rhs) const { return impl == rhs.impl; }

  bool operator!=(const image &rhs) const { return !(*this == rhs); }


  template <typename propertyT> bool has_property() const {
    return impl->template has_property<propertyT>();
  }

  template <typename propertyT> propertyT get_property() const {
    return impl->template get_property<propertyT>();
  }

  range<Dimensions> get_range() const { return impl->get_range(); }


  template <bool B = (Dimensions > 1)>
  typename std::enable_if<B, range<Dimensions - 1>>::type get_pitch() const {
    return impl->get_pitch();
  }


  size_t get_size() const { return impl->getSize(); }


  size_t get_count() const { return impl->get_count(); }


  AllocatorT get_allocator() const {
    return impl->template get_allocator<AllocatorT>();
  }

  template <typename DataT, access::mode AccessMode>
  accessor<detail::EnableIfImgAccDataT<DataT>, Dimensions, AccessMode,
           access::target::image, access::placeholder::false_t,
           ONEAPI::accessor_property_list<>>
  get_access(handler &commandGroupHandler) {
    return accessor<DataT, Dimensions, AccessMode, access::target::image,
                    access::placeholder::false_t,
                    ONEAPI::accessor_property_list<>>(*this,
                                                      commandGroupHandler);
  }

  template <typename DataT, access::mode AccessMode>
  accessor<detail::EnableIfImgAccDataT<DataT>, Dimensions, AccessMode,
           access::target::host_image, access::placeholder::false_t,
           ONEAPI::accessor_property_list<>>
  get_access() {
    return accessor<DataT, Dimensions, AccessMode, access::target::host_image,
                    access::placeholder::false_t,
                    ONEAPI::accessor_property_list<>>(*this);
  }

  template <typename Destination = std::nullptr_t>
  void set_final_data(Destination finalData = nullptr) {
    impl->set_final_data(finalData);
  }

  void set_write_back(bool flag = true) { impl->set_write_back(flag); }

private:
  shared_ptr_class<detail::image_impl<Dimensions>> impl;

  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);
};

}
}

namespace std {
template <int Dimensions, typename AllocatorT>
struct hash<cl::sycl::image<Dimensions, AllocatorT>> {
  size_t operator()(const cl::sycl::image<Dimensions, AllocatorT> &I) const {
    return hash<std::shared_ptr<cl::sycl::detail::image_impl<Dimensions>>>()(
        cl::sycl::detail::getSyclObjImpl(I));
  }
};
}
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/sampler.hpp" 1 3
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/sampler.hpp" 3
inline namespace cl {
namespace sycl {
enum class addressing_mode : unsigned int {
  mirrored_repeat = 0x1134,
  repeat = 0x1133,
  clamp_to_edge = 0x1131,
  clamp = 0x1132,
  none = 0x1130
};

enum class filtering_mode : unsigned int {
  nearest = 0x1140,
  linear = 0x1141
};

enum class coordinate_normalization_mode : unsigned int {
  normalized = 1,
  unnormalized = 0
};

namespace detail {
template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder>
class image_accessor;
}

namespace detail {
# 56 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/sampler.hpp" 3
class sampler_impl;

}






class __attribute__((visibility("default"))) sampler {
public:
  sampler(coordinate_normalization_mode normalizationMode,
          addressing_mode addressingMode, filtering_mode filteringMode,
          const property_list &propList = {});

  sampler(cl_sampler clSampler, const context &syclContext);

  sampler(const sampler &rhs) = default;

  sampler(sampler &&rhs) = default;

  sampler &operator=(const sampler &rhs) = default;

  sampler &operator=(sampler &&rhs) = default;

  bool operator==(const sampler &rhs) const;

  bool operator!=(const sampler &rhs) const;




  template <typename propertyT> bool has_property() const;







  template <typename propertyT> propertyT get_property() const;

  addressing_mode get_addressing_mode() const;

  filtering_mode get_filtering_mode() const;

  coordinate_normalization_mode get_coordinate_normalization_mode() const;

private:
# 115 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/sampler.hpp" 3
  std::shared_ptr<detail::sampler_impl> impl;
  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);

  template <typename DataT, int Dimensions, cl::sycl::access::mode AccessMode,
            cl::sycl::access::target AccessTarget, access::placeholder IsPlaceholder>
  friend class detail::image_accessor;
};
}
}

namespace std {
template <> struct hash<cl::sycl::sampler> {
  size_t operator()(const cl::sycl::sampler &s) const {




    return hash<std::shared_ptr<cl::sycl::detail::sampler_impl>>()(
        cl::sycl::detail::getSyclObjImpl(s));

  }
};
}
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cmath" 3
# 23 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 2 3


inline namespace cl {
namespace sycl {
namespace detail {

template <typename T>
using IsValidCoordType =
    typename is_contained<T, type_list<cl_int, cl_float>>::type;



template <typename T>
detail::enable_if_t<IsValidCoordType<T>::value, T>
UnnormalizeCoordinates(const T &Coords, const range<3> &Range) {
  return Coords * Range[0];
}

template <typename T>
detail::enable_if_t<IsValidCoordType<T>::value, vec<T, 2>>
UnnormalizeCoordinates(const vec<T, 2> &Coords, const range<3> &Range) {
  return {Coords.x() * Range[0], Coords.y() * Range[1]};
}

template <typename T>
detail::enable_if_t<IsValidCoordType<T>::value, vec<T, 4>>
UnnormalizeCoordinates(const vec<T, 4> &Coords, const range<3> &Range) {
  return {Coords.x() * Range[0], Coords.y() * Range[1], Coords.z() * Range[2],
          0};
}



template <typename T>
detail::enable_if_t<IsValidCoordType<T>::value, cl_float4>
convertToFloat4(T Coords) {
  return {static_cast<float>(Coords), 0.f, 0.f, 0.f};
}

template <typename T>
detail::enable_if_t<IsValidCoordType<T>::value, cl_float4>
convertToFloat4(vec<T, 2> Coords) {
  return {static_cast<float>(Coords.x()), static_cast<float>(Coords.y()), 0.f,
          0.f};
}

template <typename T>
detail::enable_if_t<IsValidCoordType<T>::value, cl_float4>
convertToFloat4(vec<T, 4> Coords) {
  return {static_cast<float>(Coords.x()), static_cast<float>(Coords.y()),
          static_cast<float>(Coords.z()), 0.f};
}




template <typename T>
detail::enable_if_t<std::is_integral<T>::value, size_t>
getImageOffset(const T &Coords, const id<3>, const uint8_t ElementSize) {
  return Coords * ElementSize;
}

template <typename T>
detail::enable_if_t<std::is_integral<T>::value, size_t>
getImageOffset(const vec<T, 2> &Coords, const id<3> ImgPitch,
               const uint8_t ElementSize) {
  return Coords.x() * ElementSize + Coords.y() * ImgPitch[0];
}

template <typename T>
detail::enable_if_t<std::is_integral<T>::value, size_t>
getImageOffset(const vec<T, 4> &Coords, const id<3> ImgPitch,
               const uint8_t ElementSize) {
  return Coords.x() * ElementSize + Coords.y() * ImgPitch[0] +
         Coords.z() * ImgPitch[1];
}



__attribute__((visibility("default"))) cl_int4 getPixelCoordNearestFiltMode(cl_float4,
                                                   const addressing_mode,
                                                   const range<3>);



__attribute__((visibility("default"))) cl_int8 getPixelCoordLinearFiltMode(cl_float4,
                                                  const addressing_mode,
                                                  const range<3>, cl_float4 &);


__attribute__((visibility("default"))) bool isOutOfRange(const cl_int4 PixelCoord,
                                const addressing_mode SmplAddrMode,
                                const range<3> ImgRange);



__attribute__((visibility("default"))) cl_float4
getBorderColor(const image_channel_order ImgChannelOrder);





template <typename T>
vec<T, 4> readPixel(T *Ptr, const image_channel_order ChannelOrder,
                    const image_channel_type ChannelType) {
  vec<T, 4> Pixel(0);

  switch (ChannelOrder) {
  case image_channel_order::a:
    Pixel.w() = Ptr[0];
    break;
  case image_channel_order::r:
  case image_channel_order::rx:
    Pixel.x() = Ptr[0];
    Pixel.w() = 1;
    break;
  case image_channel_order::intensity:
    Pixel.x() = Ptr[0];
    Pixel.y() = Ptr[0];
    Pixel.z() = Ptr[0];
    Pixel.w() = Ptr[0];
    break;
  case image_channel_order::luminance:
    Pixel.x() = Ptr[0];
    Pixel.y() = Ptr[0];
    Pixel.z() = Ptr[0];
    Pixel.w() = 1.0;
    break;
  case image_channel_order::rg:
  case image_channel_order::rgx:
    Pixel.x() = Ptr[0];
    Pixel.y() = Ptr[1];
    Pixel.w() = 1.0;
    break;
  case image_channel_order::ra:
    Pixel.x() = Ptr[0];
    Pixel.w() = Ptr[1];
    break;
  case image_channel_order::rgb:
  case image_channel_order::rgbx:
    if (ChannelType == image_channel_type::unorm_short_565 ||
        ChannelType == image_channel_type::unorm_short_555 ||
        ChannelType == image_channel_type::unorm_int_101010) {
      Pixel.x() = Ptr[0];
    } else {
      Pixel.x() = Ptr[0];
      Pixel.y() = Ptr[1];
      Pixel.z() = Ptr[2];
      Pixel.w() = 1.0;
    }
    break;
  case image_channel_order::rgba:
    Pixel.x() = Ptr[0];
    Pixel.y() = Ptr[1];
    Pixel.z() = Ptr[2];
    Pixel.w() = Ptr[3];
    break;
  case image_channel_order::argb:
    Pixel.w() = Ptr[0];
    Pixel.x() = Ptr[1];
    Pixel.y() = Ptr[2];
    Pixel.z() = Ptr[3];
    break;
  case image_channel_order::bgra:
    Pixel.z() = Ptr[0];
    Pixel.y() = Ptr[1];
    Pixel.x() = Ptr[2];
    Pixel.w() = Ptr[3];
    break;
  case image_channel_order::abgr:
    Pixel.w() = Ptr[0];
    Pixel.z() = Ptr[1];
    Pixel.y() = Ptr[2];
    Pixel.x() = Ptr[3];
    break;
  }

  return Pixel;
}





template <typename T>
void writePixel(const vec<T, 4> Pixel, T *Ptr,
                const image_channel_order ChannelOrder,
                const image_channel_type ChannelType) {


  switch (ChannelOrder) {
  case image_channel_order::a:
    Ptr[0] = Pixel.w();
    break;
  case image_channel_order::r:
  case image_channel_order::rx:
  case image_channel_order::intensity:
  case image_channel_order::luminance:
    Ptr[0] = Pixel.x();
    break;
  case image_channel_order::rg:
  case image_channel_order::rgx:
    Ptr[0] = Pixel.x();
    Ptr[1] = Pixel.y();
    break;
  case image_channel_order::ra:
    Ptr[0] = Pixel.x();
    Ptr[1] = Pixel.w();
    break;
  case image_channel_order::rgb:
  case image_channel_order::rgbx:
    if (ChannelType == image_channel_type::unorm_short_565 ||
        ChannelType == image_channel_type::unorm_short_555 ||
        ChannelType == image_channel_type::unorm_int_101010) {
      Ptr[0] = Pixel.x();
    } else {
      Ptr[0] = Pixel.x();
      Ptr[1] = Pixel.y();
      Ptr[2] = Pixel.z();
    }
    break;
  case image_channel_order::rgba:
    Ptr[0] = Pixel.x();
    Ptr[1] = Pixel.y();
    Ptr[2] = Pixel.z();
    Ptr[3] = Pixel.w();
    break;
  case image_channel_order::argb:
    Ptr[0] = Pixel.w();
    Ptr[1] = Pixel.x();
    Ptr[2] = Pixel.y();
    Ptr[3] = Pixel.z();
    break;
  case image_channel_order::bgra:
    Ptr[0] = Pixel.z();
    Ptr[1] = Pixel.y();
    Ptr[2] = Pixel.x();
    Ptr[3] = Pixel.w();
    break;
  case image_channel_order::abgr:
    Ptr[0] = Pixel.w();
    Ptr[1] = Pixel.z();
    Ptr[2] = Pixel.y();
    Ptr[3] = Pixel.x();
    break;
  }
}
# 279 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 3
template <typename ChannelType>
void convertReadData(const vec<ChannelType, 4> PixelData,
                     const image_channel_type ImageChannelType,
                     vec<cl_uint, 4> &RetData) {

  switch (ImageChannelType) {
  case image_channel_type::unsigned_int8:
  case image_channel_type::unsigned_int16:
  case image_channel_type::unsigned_int32:
    RetData = PixelData.template convert<cl_uint>();
    break;
  default:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of read data - cl_uint4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  }
}

template <typename ChannelType>
void convertReadData(const vec<ChannelType, 4> PixelData,
                     const image_channel_type ImageChannelType,
                     vec<cl_int, 4> &RetData) {

  switch (ImageChannelType) {
  case image_channel_type::signed_int8:
  case image_channel_type::signed_int16:
  case image_channel_type::signed_int32:
    RetData = PixelData.template convert<cl_int>();
    break;
  default:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of read data - cl_int4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  }
}

template <typename ChannelType>
void convertReadData(const vec<ChannelType, 4> PixelData,
                     const image_channel_type ImageChannelType,
                     vec<cl_float, 4> &RetData) {

  switch (ImageChannelType) {
  case image_channel_type::snorm_int8:

    RetData = (PixelData.template convert<cl_float>()) / 127.0f;
    RetData = cl::sycl::fmax(RetData, -1);
    break;
  case image_channel_type::snorm_int16:

    RetData = (PixelData.template convert<cl_float>()) / 32767.0f;
    RetData = cl::sycl::fmax(RetData, -1);
    break;
  case image_channel_type::unorm_int8:

    RetData = (PixelData.template convert<cl_float>()) / 255.0f;
    break;
  case image_channel_type::unorm_int16:

    RetData = (PixelData.template convert<cl_float>()) / 65535.0f;
    break;
  case image_channel_type::unorm_short_565: {





    vec<cl_ushort, 4> Temp(PixelData.x());
    vec<cl_ushort, 4> MaskBits(0xF800 , 0x07E0 ,
                               0x001F , 0x0000);
    vec<cl_ushort, 4> ShiftBits(11, 5, 0, 0);
    vec<cl_float, 4> DivisorToNormalise(31.0f, 63.0f, 31.0f, 1);
    Temp = (Temp & MaskBits) >> ShiftBits;
    RetData = (Temp.template convert<cl_float>()) / DivisorToNormalise;
    break;
  }
  case image_channel_type::unorm_short_555: {






    vec<cl_ushort, 4> Temp(PixelData.x());
    vec<cl_ushort, 4> MaskBits(0x7C00 , 0x03E0 ,
                               0x001F , 0x0000);
    vec<cl_ushort, 4> ShiftBits(10, 5, 0, 0);
    Temp = (Temp & MaskBits) >> ShiftBits;
    RetData = (Temp.template convert<cl_float>()) / 31.0f;
    break;
  }
  case image_channel_type::unorm_int_101010: {


    vec<cl_uint, 4> Temp(PixelData.x());
    vec<cl_uint, 4> MaskBits(0x3FF00000 ,
                             0x000FFC00 ,
                             0x000003FF , 0x00000000);
    vec<cl_uint, 4> ShiftBits(20, 10, 0, 0);
    Temp = (Temp & MaskBits) >> ShiftBits;
    RetData = (Temp.template convert<cl_float>()) / 1023.0f;
    break;
  }
  case image_channel_type::signed_int8:
  case image_channel_type::signed_int16:
  case image_channel_type::signed_int32:
  case image_channel_type::unsigned_int8:
  case image_channel_type::unsigned_int16:
  case image_channel_type::unsigned_int32:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of read data - cl_float4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  case image_channel_type::fp16:


    RetData = PixelData.template convert<cl_float>();
    break;
  case image_channel_type::fp32:
    RetData = PixelData.template convert<cl_float>();
    break;
  }
}

template <typename ChannelType>
void convertReadData(const vec<ChannelType, 4> PixelData,
                     const image_channel_type ImageChannelType,
                     vec<cl_half, 4> &RetData) {
  vec<cl_float, 4> RetDataFloat;
  switch (ImageChannelType) {
  case image_channel_type::snorm_int8:

    RetDataFloat = (PixelData.template convert<cl_float>()) / 127.0f;
    RetDataFloat = cl::sycl::fmax(RetDataFloat, -1);
    break;
  case image_channel_type::snorm_int16:

    RetDataFloat = (PixelData.template convert<cl_float>()) / 32767.0f;
    RetDataFloat = cl::sycl::fmax(RetDataFloat, -1);
    break;
  case image_channel_type::unorm_int8:

    RetDataFloat = (PixelData.template convert<cl_float>()) / 255.0f;
    break;
  case image_channel_type::unorm_int16:

    RetDataFloat = (PixelData.template convert<cl_float>()) / 65535.0f;
    break;
  case image_channel_type::unorm_short_565:
  case image_channel_type::unorm_short_555:
  case image_channel_type::unorm_int_101010:

    throw cl::sycl::feature_not_supported(
        "Currently unsupported datatype conversion from image_channel_type "
        "to cl_half4.",
        PI_INVALID_OPERATION);
  case image_channel_type::signed_int8:
  case image_channel_type::signed_int16:
  case image_channel_type::signed_int32:
  case image_channel_type::unsigned_int8:
  case image_channel_type::unsigned_int16:
  case image_channel_type::unsigned_int32:



    throw cl::sycl::invalid_parameter_error(
        "Datatype to read- cl_half4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  case image_channel_type::fp16:
    RetData = PixelData.template convert<cl_half>();
    return;
  case image_channel_type::fp32:
    throw cl::sycl::invalid_parameter_error(
        "Datatype to read - cl_half4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  }
  RetData = RetDataFloat.template convert<cl_half>();
}







template <typename ChannelType>
vec<ChannelType, 4>
convertWriteData(const vec<cl_uint, 4> WriteData,
                 const image_channel_type ImageChannelType) {
  switch (ImageChannelType) {
  case image_channel_type::unsigned_int8: {

    cl_uint MinVal = min_v<cl_uchar>();
    cl_uint MaxVal = max_v<cl_uchar>();
    vec<cl_uint, 4> PixelData = cl::sycl::clamp(WriteData, MinVal, MaxVal);
    return PixelData.convert<ChannelType>();
  }
  case image_channel_type::unsigned_int16: {

    cl_uint MinVal = min_v<cl_ushort>();
    cl_uint MaxVal = max_v<cl_ushort>();
    vec<cl_uint, 4> PixelData = cl::sycl::clamp(WriteData, MinVal, MaxVal);
    return PixelData.convert<ChannelType>();
  }
  case image_channel_type::unsigned_int32:

    return WriteData.convert<ChannelType>();
  default:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of data to write - cl_uint4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  }
}

template <typename ChannelType>
vec<ChannelType, 4>
convertWriteData(const vec<cl_int, 4> WriteData,
                 const image_channel_type ImageChannelType) {

  switch (ImageChannelType) {
  case image_channel_type::signed_int8: {

    cl_int MinVal = min_v<cl_char>();
    cl_int MaxVal = max_v<cl_char>();
    vec<cl_int, 4> PixelData = cl::sycl::clamp(WriteData, MinVal, MaxVal);
    return PixelData.convert<ChannelType>();
  }
  case image_channel_type::signed_int16: {

    cl_int MinVal = min_v<cl_short>();
    cl_int MaxVal = max_v<cl_short>();
    vec<cl_int, 4> PixelData = cl::sycl::clamp(WriteData, MinVal, MaxVal);
    return PixelData.convert<ChannelType>();
  }
  case image_channel_type::signed_int32:
    return WriteData.convert<ChannelType>();
  default:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of data to write - cl_int4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  }
}

template <typename ChannelType>
vec<ChannelType, 4> processFloatDataToPixel(vec<cl_float, 4> WriteData,
                                            float MulFactor) {
  vec<cl_float, 4> Temp = WriteData * MulFactor;
  vec<cl_int, 4> TempInInt = Temp.convert<int, rounding_mode::rte>();
  vec<cl_int, 4> TempInIntSaturated =
      cl::sycl::clamp(TempInInt, min_v<ChannelType>(), max_v<ChannelType>());
  return TempInIntSaturated.convert<ChannelType>();
}

template <typename ChannelType>
vec<ChannelType, 4>
convertWriteData(const vec<cl_float, 4> WriteData,
                 const image_channel_type ImageChannelType) {

  vec<ChannelType, 4> PixelData;

  switch (ImageChannelType) {
  case image_channel_type::snorm_int8:

    return processFloatDataToPixel<ChannelType>(WriteData, 127.0f);
  case image_channel_type::snorm_int16:

    return processFloatDataToPixel<ChannelType>(WriteData, 32767.0f);
  case image_channel_type::unorm_int8:

    return processFloatDataToPixel<ChannelType>(WriteData, 255.0f);
  case image_channel_type::unorm_int16:

    return processFloatDataToPixel<ChannelType>(WriteData, 65535.0f);
  case image_channel_type::unorm_short_565:

    throw cl::sycl::feature_not_supported(
        "Currently unsupported datatype conversion from image_channel_type "
        "to cl_float4.",
        PI_INVALID_OPERATION);
  case image_channel_type::unorm_short_555:




    {
      vec<cl_ushort, 4> PixelData =
          processFloatDataToPixel<cl_ushort>(WriteData, 32.0f);
      PixelData = cl::sycl::min(PixelData, static_cast<ChannelType>(0x1f));





      PixelData.x() =
          (PixelData.x() << 10) | (PixelData.y() << 5) | PixelData.z();
      return PixelData.convert<ChannelType>();
    }
  case image_channel_type::unorm_int_101010:



    {
      vec<cl_uint, 4> PixelData =
          processFloatDataToPixel<cl_uint>(WriteData, 1023.0f);
      PixelData = cl::sycl::min(PixelData, static_cast<ChannelType>(0x3ff));
      PixelData.x() =
          (PixelData.x() << 20) | (PixelData.y() << 10) | PixelData.z();
      return PixelData.convert<ChannelType>();
    }
  case image_channel_type::signed_int8:
  case image_channel_type::signed_int16:
  case image_channel_type::signed_int32:
  case image_channel_type::unsigned_int8:
  case image_channel_type::unsigned_int16:
  case image_channel_type::unsigned_int32:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of data to write - cl_float4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  case image_channel_type::fp16:


    return WriteData.convert<ChannelType>();
  case image_channel_type::fp32:
    return WriteData.convert<ChannelType>();
  }
}

template <typename ChannelType>
vec<ChannelType, 4>
convertWriteData(const vec<cl_half, 4> WriteData,
                 const image_channel_type ImageChannelType) {
  vec<cl_float, 4> WriteDataFloat = WriteData.convert<cl_float>();
  switch (ImageChannelType) {
  case image_channel_type::snorm_int8:

    return processFloatDataToPixel<ChannelType>(WriteDataFloat, 127.0f);
  case image_channel_type::snorm_int16:

    return processFloatDataToPixel<ChannelType>(WriteDataFloat, 32767.0f);
  case image_channel_type::unorm_int8:

    return processFloatDataToPixel<ChannelType>(WriteDataFloat, 255.0f);
  case image_channel_type::unorm_int16:

    return processFloatDataToPixel<ChannelType>(WriteDataFloat, 65535.0f);
  case image_channel_type::unorm_short_565:
  case image_channel_type::unorm_short_555:
  case image_channel_type::unorm_int_101010:

    throw cl::sycl::feature_not_supported(
        "Currently unsupported datatype conversion from image_channel_type "
        "to cl_half4.",
        PI_INVALID_OPERATION);
  case image_channel_type::signed_int8:
  case image_channel_type::signed_int16:
  case image_channel_type::signed_int32:
  case image_channel_type::unsigned_int8:
  case image_channel_type::unsigned_int16:
  case image_channel_type::unsigned_int32:



    throw cl::sycl::invalid_parameter_error(
        "Datatype of data to write - cl_float4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  case image_channel_type::fp16:
    return WriteData.convert<ChannelType>();
  case image_channel_type::fp32:
    throw cl::sycl::invalid_parameter_error(
        "Datatype of data to write - cl_float4 is incompatible with the "
        "image_channel_type of the image.",
        PI_INVALID_VALUE);
  }
}
# 693 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 3
template <typename CoordT, typename WriteDataT>
void imageWriteHostImpl(const CoordT &Coords, const WriteDataT &Color,
                        id<3> ImgPitch, uint8_t ElementSize,
                        image_channel_type ImgChannelType,
                        image_channel_order ImgChannelOrder, void *BasePtr) {

  auto Ptr = static_cast<unsigned char *>(BasePtr) +
             getImageOffset(Coords, ImgPitch, ElementSize);

  switch (ImgChannelType) {
  case image_channel_type::snorm_int8:
    writePixel(convertWriteData<cl_char>(Color, ImgChannelType),
               reinterpret_cast<cl_char *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::snorm_int16:
    writePixel(convertWriteData<cl_short>(Color, ImgChannelType),
               reinterpret_cast<cl_short *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::unorm_int8:
    writePixel(convertWriteData<cl_uchar>(Color, ImgChannelType),
               reinterpret_cast<cl_uchar *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::unorm_int16:
    writePixel(convertWriteData<cl_ushort>(Color, ImgChannelType),
               reinterpret_cast<cl_ushort *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::unorm_short_565:
    writePixel(convertWriteData<short>(Color, ImgChannelType),
               reinterpret_cast<short *>(Ptr), ImgChannelOrder, ImgChannelType);
    break;
  case image_channel_type::unorm_short_555:
    writePixel(convertWriteData<short>(Color, ImgChannelType),
               reinterpret_cast<short *>(Ptr), ImgChannelOrder, ImgChannelType);
    break;
  case image_channel_type::unorm_int_101010:
    writePixel(convertWriteData<cl_uint>(Color, ImgChannelType),
               reinterpret_cast<cl_uint *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::signed_int8:
    writePixel(convertWriteData<cl_char>(Color, ImgChannelType),
               reinterpret_cast<cl_char *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::signed_int16:
    writePixel(convertWriteData<cl_short>(Color, ImgChannelType),
               reinterpret_cast<cl_short *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::signed_int32:
    writePixel(convertWriteData<cl_int>(Color, ImgChannelType),
               reinterpret_cast<cl_int *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::unsigned_int8:
    writePixel(convertWriteData<cl_uchar>(Color, ImgChannelType),
               reinterpret_cast<cl_uchar *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::unsigned_int16:
    writePixel(convertWriteData<cl_ushort>(Color, ImgChannelType),
               reinterpret_cast<cl_ushort *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::unsigned_int32:
    writePixel(convertWriteData<cl_uint>(Color, ImgChannelType),
               reinterpret_cast<cl_uint *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  case image_channel_type::fp16:
    writePixel(


        convertWriteData<cl_half>(Color, ImgChannelType),
        reinterpret_cast<cl_half *>(Ptr), ImgChannelOrder, ImgChannelType);
    break;
  case image_channel_type::fp32:
    writePixel(convertWriteData<cl_float>(Color, ImgChannelType),
               reinterpret_cast<cl_float *>(Ptr), ImgChannelOrder,
               ImgChannelType);
    break;
  }
}
# 795 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 3
template <typename DataT>
DataT ReadPixelData(const cl_int4 PixelCoord, const id<3> ImgPitch,
                    const image_channel_type ImageChannelType,
                    const image_channel_order ImageChannelOrder,
                    void *BasePtr, const uint8_t ElementSize) {
  DataT Color(0);
  auto Ptr = static_cast<unsigned char *>(BasePtr) +
             getImageOffset(PixelCoord, ImgPitch,
                            ElementSize);


  switch (ImageChannelType) {


  case image_channel_type::snorm_int8:
    convertReadData<cl_char>(readPixel(reinterpret_cast<cl_char *>(Ptr),
                                       ImageChannelOrder, ImageChannelType),
                             image_channel_type::snorm_int8, Color);
    break;
  case image_channel_type::snorm_int16:
    convertReadData<cl_short>(readPixel(reinterpret_cast<cl_short *>(Ptr),
                                        ImageChannelOrder, ImageChannelType),
                              image_channel_type::snorm_int16, Color);
    break;
  case image_channel_type::unorm_int8:
    convertReadData<cl_uchar>(readPixel(reinterpret_cast<cl_uchar *>(Ptr),
                                        ImageChannelOrder, ImageChannelType),
                              image_channel_type::unorm_int8, Color);
    break;
  case image_channel_type::unorm_int16:
    convertReadData<cl_ushort>(readPixel(reinterpret_cast<cl_ushort *>(Ptr),
                                         ImageChannelOrder, ImageChannelType),
                               image_channel_type::unorm_int16, Color);
    break;
  case image_channel_type::unorm_short_565:
    convertReadData<cl_ushort>(readPixel(reinterpret_cast<cl_ushort *>(Ptr),
                                         ImageChannelOrder, ImageChannelType),
                               image_channel_type::unorm_short_565, Color);
    break;
  case image_channel_type::unorm_short_555:
    convertReadData<cl_ushort>(readPixel(reinterpret_cast<cl_ushort *>(Ptr),
                                         ImageChannelOrder, ImageChannelType),
                               image_channel_type::unorm_short_555, Color);
    break;
  case image_channel_type::unorm_int_101010:
    convertReadData<cl_uint>(readPixel(reinterpret_cast<cl_uint *>(Ptr),
                                       ImageChannelOrder, ImageChannelType),
                             image_channel_type::unorm_int_101010, Color);
    break;
  case image_channel_type::signed_int8:
    convertReadData<cl_char>(readPixel(reinterpret_cast<cl_char *>(Ptr),
                                       ImageChannelOrder, ImageChannelType),
                             image_channel_type::signed_int8, Color);
    break;
  case image_channel_type::signed_int16:
    convertReadData<cl_short>(readPixel(reinterpret_cast<cl_short *>(Ptr),
                                        ImageChannelOrder, ImageChannelType),
                              image_channel_type::signed_int16, Color);
    break;
  case image_channel_type::signed_int32:
    convertReadData<cl_int>(readPixel(reinterpret_cast<cl_int *>(Ptr),
                                      ImageChannelOrder, ImageChannelType),
                            image_channel_type::signed_int32, Color);
    break;
  case image_channel_type::unsigned_int8:
    convertReadData<cl_uchar>(readPixel(reinterpret_cast<cl_uchar *>(Ptr),
                                        ImageChannelOrder, ImageChannelType),
                              image_channel_type::unsigned_int8, Color);
    break;
  case image_channel_type::unsigned_int16:
    convertReadData<cl_ushort>(readPixel(reinterpret_cast<cl_ushort *>(Ptr),
                                         ImageChannelOrder, ImageChannelType),
                               image_channel_type::unsigned_int16, Color);
    break;
  case image_channel_type::unsigned_int32:
    convertReadData<cl_uint>(readPixel(reinterpret_cast<cl_uint *>(Ptr),
                                       ImageChannelOrder, ImageChannelType),
                             image_channel_type::unsigned_int32, Color);
    break;
  case image_channel_type::fp16:
    convertReadData<cl_half>(readPixel(reinterpret_cast<cl_half *>(Ptr),
                                       ImageChannelOrder, ImageChannelType),
                             image_channel_type::fp16, Color);
    break;
  case image_channel_type::fp32:
    convertReadData<cl_float>(readPixel(reinterpret_cast<cl_float *>(Ptr),
                                        ImageChannelOrder, ImageChannelType),
                              image_channel_type::fp32, Color);
    break;
  }

  return Color;
}



template <typename DataT>
DataT getColor(const cl_int4 PixelCoord, const addressing_mode SmplAddrMode,
               const range<3> ImgRange, const id<3> ImgPitch,
               const image_channel_type ImgChannelType,
               const image_channel_order ImgChannelOrder, void *BasePtr,
               const uint8_t ElementSize) {
  DataT RetData;
  if (isOutOfRange(PixelCoord, SmplAddrMode, ImgRange)) {
    cl_float4 BorderColor = getBorderColor(ImgChannelOrder);
    RetData = BorderColor.convert<typename TryToGetElementType<DataT>::type>();
  } else {
    RetData = ReadPixelData<DataT>(PixelCoord, ImgPitch, ImgChannelType,
                                   ImgChannelOrder, BasePtr, ElementSize);
  }
  return RetData;
}






template <typename DataT>
DataT ReadPixelDataLinearFiltMode(const cl_int8 CoordValues,
                                  const cl_float4 abc,
                                  const addressing_mode SmplAddrMode,
                                  const range<3> ImgRange, id<3> ImgPitch,
                                  const image_channel_type ImgChannelType,
                                  const image_channel_order ImgChannelOrder,
                                  void *BasePtr, const uint8_t ElementSize) {
  cl_int i0 = CoordValues.s0(), j0 = CoordValues.s1(), k0 = CoordValues.s2(),
         i1 = CoordValues.s4(), j1 = CoordValues.s5(), k1 = CoordValues.s6();

  auto getColorInFloat =
      [&](cl_int4 V) {
        DataT Res = getColor<DataT>(V, SmplAddrMode,
                                    ImgRange, ImgPitch, ImgChannelType,
                                    ImgChannelOrder, BasePtr, ElementSize);
        return Res.template convert<cl_float>();
      };


  cl_float4 Ci0j0k0 = getColorInFloat(cl_int4{i0, j0, k0, 0});

  cl_float4 Ci1j0k0 = getColorInFloat(cl_int4{i1, j0, k0, 0});

  cl_float4 Ci0j1k0 = getColorInFloat(cl_int4{i0, j1, k0, 0});

  cl_float4 Ci1j1k0 = getColorInFloat(cl_int4{i1, j1, k0, 0});

  cl_float4 Ci0j0k1 = getColorInFloat(cl_int4{i0, j0, k1, 0});

  cl_float4 Ci1j0k1 = getColorInFloat(cl_int4{i1, j0, k1, 0});

  cl_float4 Ci0j1k1 = getColorInFloat(cl_int4{i0, j1, k1, 0});

  cl_float4 Ci1j1k1 = getColorInFloat(cl_int4{i1, j1, k1, 0});

  cl_float a = abc.x();
  cl_float b = abc.y();
  cl_float c = abc.z();

  Ci0j0k0 = (1 - a) * (1 - b) * (1 - c) * Ci0j0k0;
  Ci1j0k0 = a * (1 - b) * (1 - c) * Ci1j0k0;
  Ci0j1k0 = (1 - a) * b * (1 - c) * Ci0j1k0;
  Ci1j1k0 = a * b * (1 - c) * Ci1j1k0;
  Ci0j0k1 = (1 - a) * (1 - b) * c * Ci0j0k1;
  Ci1j0k1 = a * (1 - b) * c * Ci1j0k1;
  Ci0j1k1 = (1 - a) * b * c * Ci0j1k1;
  Ci1j1k1 = a * b * c * Ci1j1k1;

  cl_float4 RetData = Ci0j0k0 + Ci1j0k0 + Ci0j1k0 + Ci1j1k0 + Ci0j0k1 +
                      Ci1j0k1 + Ci0j1k1 + Ci1j1k1;






  return RetData.convert<typename TryToGetElementType<DataT>::type>();
}
# 1013 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 3
template <typename CoordT, typename DataT>
DataT imageReadSamplerHostImpl(const CoordT &Coords, const sampler &Smpl,
                                                         range<3> ImgRange,
                               id<3> ImgPitch,
                               image_channel_type ImgChannelType,
                               image_channel_order ImgChannelOrder,
                               void *BasePtr, uint8_t ElementSize) {

  coordinate_normalization_mode SmplNormMode =
      Smpl.get_coordinate_normalization_mode();
  addressing_mode SmplAddrMode = Smpl.get_addressing_mode();
  filtering_mode SmplFiltMode = Smpl.get_filtering_mode();

  CoordT Coorduvw;
  cl_float4 FloatCoorduvw;
  DataT RetData;




  switch (SmplNormMode) {
  case coordinate_normalization_mode::unnormalized:
    switch (SmplAddrMode) {
    case addressing_mode::mirrored_repeat:
    case addressing_mode::repeat:
      throw cl::sycl::feature_not_supported(
          "Sampler used with unsupported configuration of "
          "mirrored_repeat/repeat filtering mode with unnormalized "
          "coordinates. ",
          PI_INVALID_OPERATION);
    case addressing_mode::clamp_to_edge:
    case addressing_mode::clamp:
    case addressing_mode::none:

      Coorduvw = Coords;
      break;
    }
    break;
  case coordinate_normalization_mode::normalized:
    switch (SmplAddrMode) {
    case addressing_mode::mirrored_repeat:
    case addressing_mode::repeat:



      Coorduvw = Coords;
      break;
    case addressing_mode::clamp_to_edge:
    case addressing_mode::clamp:
    case addressing_mode::none:



      Coorduvw = UnnormalizeCoordinates(Coords, ImgRange);
      break;
    }
    break;
  }
# 1080 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_accessor_util.hpp" 3
  FloatCoorduvw = convertToFloat4(Coorduvw);
  switch (SmplFiltMode) {
  case filtering_mode::nearest: {

    cl_int4 PixelCoord =
        getPixelCoordNearestFiltMode(FloatCoorduvw, SmplAddrMode, ImgRange);




    RetData =
        getColor<DataT>(PixelCoord, SmplAddrMode, ImgRange, ImgPitch,
                        ImgChannelType, ImgChannelOrder, BasePtr, ElementSize);
    break;
  }
  case filtering_mode::linear: {
    cl_float4 Retabc;



    cl_int8 CoordValues = getPixelCoordLinearFiltMode(
        FloatCoorduvw, SmplAddrMode, ImgRange, Retabc);



    RetData = ReadPixelDataLinearFiltMode<DataT>(
        CoordValues, Retabc, SmplAddrMode, ImgRange, ImgPitch, ImgChannelType,
        ImgChannelOrder, BasePtr, ElementSize);

    break;
  }
  }

  return RetData;
}

}
}
}
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/image_ocl_types.hpp" 1 3
# 22 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/pointers.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/pointers.hpp" 3
inline namespace cl {
namespace sycl {

template <typename ElementType, access::address_space Space> class multi_ptr;


template <typename ElementType>
using global_ptr = multi_ptr<ElementType, access::address_space::global_space>;

template <typename ElementType>
using device_ptr =
    multi_ptr<ElementType, access::address_space::global_device_space>;

template <typename ElementType>
using host_ptr =
    multi_ptr<ElementType, access::address_space::global_host_space>;

template <typename ElementType>
using local_ptr = multi_ptr<ElementType, access::address_space::local_space>;

template <typename ElementType>
using constant_ptr =
    multi_ptr<ElementType, access::address_space::constant_space>;

template <typename ElementType>
using private_ptr =
    multi_ptr<ElementType, access::address_space::private_space>;

}
}
# 26 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/accessor_properties.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/accessor_properties.hpp" 3
inline namespace cl {
namespace sycl {
namespace property {

class noinit : public detail::DataLessProperty<detail::NoInit> {};

}



inline constexpr property::noinit noinit;
# 38 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/accessor_properties.hpp" 3
namespace INTEL {
namespace property {
struct buffer_location {
  template <int A> struct instance {
    template <int B>
    constexpr bool operator==(const buffer_location::instance<B> &) const {
      return A == B;
    }
    template <int B>
    constexpr bool operator!=(const buffer_location::instance<B> &) const {
      return A != B;
    }
  };
};
}

template <int A>
inline constexpr property::buffer_location::instance<A> buffer_location;

}
namespace ONEAPI {
namespace property {
struct no_offset {
  template <bool B = true> struct instance {
    constexpr bool operator==(const no_offset::instance<B> &) const {
      return true;
    }
    constexpr bool operator!=(const no_offset::instance<B> &) const {
      return false;
    }
  };
};
struct no_alias {
  template <bool B = true> struct instance {
    constexpr bool operator==(const no_alias::instance<B> &) const {
      return true;
    }
    constexpr bool operator!=(const no_alias::instance<B> &) const {
      return false;
    }
  };
};
}



inline constexpr property::no_offset::instance no_offset;
inline constexpr property::no_alias::instance no_alias;



template <>
struct is_compile_time_property<ONEAPI::property::no_offset> : std::true_type {
};
template <>
struct is_compile_time_property<ONEAPI::property::no_alias> : std::true_type {};
template <>
struct is_compile_time_property<INTEL::property::buffer_location>
    : std::true_type {};
}
namespace detail {
template <int I>
struct IsCompileTimePropertyInstance<
    INTEL::property::buffer_location::instance<I>> : std::true_type {};
template <>
struct IsCompileTimePropertyInstance<ONEAPI::property::no_alias::instance<>>
    : std::true_type {};
template <>
struct IsCompileTimePropertyInstance<ONEAPI::property::no_offset::instance<>>
    : std::true_type {};
}
}
}
# 27 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/property_list_conversion.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/property_list_conversion.hpp" 3
inline namespace cl {
namespace sycl {
template <typename... T>
inline property_list::operator ONEAPI::accessor_property_list<T...>() {
  return ONEAPI::accessor_property_list<T...>(MDataLessProps, MPropsWithData);
}
}
}
# 29 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 2 3
# 204 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
inline namespace cl {
namespace sycl {
namespace INTEL {
namespace gpu {

class AccessorPrivateProxy;
}
}
}
}

inline namespace cl {
namespace sycl {

template <typename DataT, int Dimensions = 1,
          access::mode AccessMode = access::mode::read_write,
          access::target AccessTarget = access::target::global_buffer,
          access::placeholder IsPlaceholder = access::placeholder::false_t,
          typename PropertyListT = ONEAPI::accessor_property_list<>>
class accessor;

namespace detail {
template <typename T>
using IsPropertyListT = typename std::is_base_of<PropertyListBase, T>;

template <typename T>
using IsRunTimePropertyListT =
    typename std::is_same<ONEAPI::accessor_property_list<>, T>;

template <typename T> struct IsCxPropertyList {
  constexpr static bool value = false;
};

template <typename... Props>
struct IsCxPropertyList<ONEAPI::accessor_property_list<Props...>> {
  constexpr static bool value = true;
};

template <> struct IsCxPropertyList<ONEAPI::accessor_property_list<>> {
  constexpr static bool value = false;
};




template <int NewDim, int DefaultValue, template <int> class T, int OldDim>
static T<NewDim> convertToArrayOfN(T<OldDim> OldObj) {
  T<NewDim> NewObj = InitializedVal<NewDim, T>::template get<0>();
  const int CopyDims = NewDim > OldDim ? OldDim : NewDim;
  for (int I = 0; I < CopyDims; ++I)
    NewObj[I] = OldObj[I];
  for (int I = CopyDims; I < NewDim; ++I)
    NewObj[I] = DefaultValue;
  return NewObj;
}

__attribute__((visibility("default"))) device getDeviceFromHandler(handler &CommandGroupHandlerRef);

template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder,
          typename PropertyListT = ONEAPI::accessor_property_list<>>
class accessor_common {
protected:
  constexpr static bool IsPlaceH = IsPlaceholder == access::placeholder::true_t;
  constexpr static access::address_space AS = TargetToAS<AccessTarget>::AS;

  constexpr static bool IsHostBuf = AccessTarget == access::target::host_buffer;

  constexpr static bool IsGlobalBuf =
      AccessTarget == access::target::global_buffer;

  constexpr static bool IsConstantBuf =
      AccessTarget == access::target::constant_buffer;

  constexpr static bool IsAccessAnyWrite =
      AccessMode == access::mode::write ||
      AccessMode == access::mode::read_write ||
      AccessMode == access::mode::discard_write ||
      AccessMode == access::mode::discard_read_write;

  constexpr static bool IsAccessReadOnly = AccessMode == access::mode::read;

  constexpr static bool IsAccessReadWrite =
      AccessMode == access::mode::read_write;

  using RefType = detail::const_if_const_AS<AS, DataT> &;
  using ConstRefType = const DataT &;
  using PtrType = detail::const_if_const_AS<AS, DataT> *;

  using AccType = accessor<DataT, Dimensions, AccessMode, AccessTarget,
                           IsPlaceholder, PropertyListT>;



  template <int SubDims> class AccessorSubscript {
    static constexpr int Dims = Dimensions;

    mutable id<Dims> MIDs;
    AccType MAccessor;

  public:
    AccessorSubscript(AccType Accessor, id<Dims> IDs)
        : MAccessor(Accessor), MIDs(IDs) {}



    AccessorSubscript(AccType Accessor, size_t Index) : MAccessor(Accessor) {
      MIDs[0] = Index;
    }

    template <int CurDims = SubDims>
    typename detail::enable_if_t<(CurDims > 1), AccessorSubscript<CurDims - 1>>
    operator[](size_t Index) {
      MIDs[Dims - CurDims] = Index;
      return AccessorSubscript<CurDims - 1>(MAccessor, MIDs);
    }

    template <int CurDims = SubDims,
              typename = detail::enable_if_t<CurDims == 1 && IsAccessAnyWrite>>
    RefType operator[](size_t Index) const {
      MIDs[Dims - CurDims] = Index;
      return MAccessor[MIDs];
    }

    template <int CurDims = SubDims,
              typename = detail::enable_if_t<CurDims == 1 && IsAccessReadOnly>>
    ConstRefType operator[](size_t Index) const {
      MIDs[Dims - SubDims] = Index;
      return MAccessor[MIDs];
    }
  };
};

template <int Dim, typename T> struct IsValidCoordDataT;
template <typename T> struct IsValidCoordDataT<1, T> {
  constexpr static bool value =
      detail::is_contained<T, detail::type_list<cl_int, cl_float>>::type::value;
};
template <typename T> struct IsValidCoordDataT<2, T> {
  constexpr static bool value =
      detail::is_contained<T,
                           detail::type_list<cl_int2, cl_float2>>::type::value;
};
template <typename T> struct IsValidCoordDataT<3, T> {
  constexpr static bool value =
      detail::is_contained<T,
                           detail::type_list<cl_int4, cl_float4>>::type::value;
};

template <typename DataT, int Dimensions, access::mode AccessMode,
          access::placeholder IsPlaceholder>
class __image_array_slice__;


template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder>
class image_accessor

    : public detail::AccessorBaseHost {
  size_t MImageCount;
  image_channel_order MImgChannelOrder;
  image_channel_type MImgChannelType;
# 381 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  template <typename T1, int T2, access::mode T3, access::placeholder T4>
  friend class __image_array_slice__;

  constexpr static bool IsHostImageAcc =
      (AccessTarget == access::target::host_image);

  constexpr static bool IsImageAcc = (AccessTarget == access::target::image);

  constexpr static bool IsImageArrayAcc =
      (AccessTarget == access::target::image_array);

  constexpr static bool IsImageAccessWriteOnly =
      (AccessMode == access::mode::write ||
       AccessMode == access::mode::discard_write);

  constexpr static bool IsImageAccessAnyWrite =
      (IsImageAccessWriteOnly || AccessMode == access::mode::read_write);

  constexpr static bool IsImageAccessReadOnly =
      (AccessMode == access::mode::read);

  constexpr static bool IsImageAccessAnyRead =
      (IsImageAccessReadOnly || AccessMode == access::mode::read_write);

  static_assert(std::is_same<DataT, cl_int4>::value ||
                      std::is_same<DataT, cl_uint4>::value ||
                      std::is_same<DataT, cl_float4>::value ||
                      std::is_same<DataT, cl_half4>::value,
                  "The data type of an image accessor must be only cl_int4, "
                  "cl_uint4, cl_float4 or cl_half4 from SYCL namespace");

  static_assert(IsImageAcc || IsHostImageAcc || IsImageArrayAcc,
                "Expected image type");

  static_assert(IsPlaceholder == access::placeholder::false_t,
                "Expected false as Placeholder value for image accessor.");

  static_assert(
      ((IsImageAcc || IsImageArrayAcc) &&
       (IsImageAccessWriteOnly || IsImageAccessReadOnly)) ||
          (IsHostImageAcc && (IsImageAccessAnyWrite || IsImageAccessAnyRead)),
      "Access modes can be only read/write/discard_write for image/image_array "
      "target accessor, or they can be only "
      "read/write/discard_write/read_write for host_image target accessor.");

  static_assert(Dimensions > 0 && Dimensions <= 3,
                "Dimensions can be 1/2/3 for image accessor.");

  template <info::device param>
  void checkDeviceFeatureSupported(const device &Device) {
    if (!Device.get_info<param>())
      throw feature_not_supported("Images are not supported by this device.",
                                  PI_INVALID_OPERATION);
  }
# 452 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  sycl::vec<int, Dimensions> getRangeInternal() const {

    throw runtime_error("image::getRangeInternal() is not implemented for host",
                        PI_INVALID_OPERATION);
    return sycl::vec<int, Dimensions>{1};
  }



private:
  friend class sycl::INTEL::gpu::AccessorPrivateProxy;





public:
  using value_type = DataT;
  using reference = DataT &;
  using const_reference = const DataT &;
# 483 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  template <
      typename AllocatorT, int Dims = Dimensions,
      typename = detail::enable_if_t<(Dims > 0 && Dims <= 3) && IsHostImageAcc>>
  image_accessor(image<Dims, AllocatorT> &ImageRef, int ImageElementSize)
# 495 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
      : AccessorBaseHost({detail::getSyclObjImpl(ImageRef)->getRowPitch(),
                          detail::getSyclObjImpl(ImageRef)->getSlicePitch(), 0},
                         detail::convertToArrayOfN<3, 1>(ImageRef.get_range()),
                         detail::convertToArrayOfN<3, 1>(ImageRef.get_range()),
                         AccessMode, detail::getSyclObjImpl(ImageRef).get(),
                         Dimensions, ImageElementSize),
        MImageCount(ImageRef.get_count()),
        MImgChannelOrder(detail::getSyclObjImpl(ImageRef)->getChannelOrder()),
        MImgChannelType(detail::getSyclObjImpl(ImageRef)->getChannelType()) {
    addHostAccessorAndWait(AccessorBaseHost::impl.get());
  }






  template <
      typename AllocatorT, int Dims = Dimensions,
      typename = detail::enable_if_t<(Dims > 0 && Dims <= 3) && IsImageAcc>>
  image_accessor(image<Dims, AllocatorT> &ImageRef,
                 handler &CommandGroupHandlerRef, int ImageElementSize)
# 526 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
      : AccessorBaseHost({detail::getSyclObjImpl(ImageRef)->getRowPitch(),
                          detail::getSyclObjImpl(ImageRef)->getSlicePitch(), 0},
                         detail::convertToArrayOfN<3, 1>(ImageRef.get_range()),
                         detail::convertToArrayOfN<3, 1>(ImageRef.get_range()),
                         AccessMode, detail::getSyclObjImpl(ImageRef).get(),
                         Dimensions, ImageElementSize),
        MImageCount(ImageRef.get_count()),
        MImgChannelOrder(detail::getSyclObjImpl(ImageRef)->getChannelOrder()),
        MImgChannelType(detail::getSyclObjImpl(ImageRef)->getChannelType()) {
    checkDeviceFeatureSupported<info::device::image_support>(
        getDeviceFromHandler(CommandGroupHandlerRef));
  }







  bool operator==(const image_accessor &Rhs) const { return Rhs.impl == impl; }







  bool operator!=(const image_accessor &Rhs) const { return !(Rhs == *this); }
# 584 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  size_t get_count() const { return MImageCount; };

  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 0)>>
  range<Dims> get_range() const {
    return detail::convertToArrayOfN<Dims, 1>(getAccessRange());
  }







  template <typename CoordT, int Dims = Dimensions,
            typename = detail::enable_if_t<
                (Dims > 0) && (IsValidCoordDataT<Dims, CoordT>::value) &&
                (detail::is_genint<CoordT>::value) &&
                ((IsImageAcc && IsImageAccessReadOnly) ||
                 (IsHostImageAcc && IsImageAccessAnyRead))>>
  DataT read(const CoordT &Coords) const {



    sampler Smpl(coordinate_normalization_mode::unnormalized,
                 addressing_mode::none, filtering_mode::nearest);
    return read<CoordT, Dims>(Coords, Smpl);

  }





  template <typename CoordT, int Dims = Dimensions,
            typename = detail::enable_if_t<
                (Dims > 0) && (IsValidCoordDataT<Dims, CoordT>::value) &&
                ((IsImageAcc && IsImageAccessReadOnly) ||
                 (IsHostImageAcc && IsImageAccessAnyRead))>>
  DataT read(const CoordT &Coords, const sampler &Smpl) const {




    return imageReadSamplerHostImpl<CoordT, DataT>(
        Coords, Smpl, getAccessRange() ,
        getOffset() , MImgChannelType, MImgChannelOrder,
        AccessorBaseHost::getPtr() ,
        AccessorBaseHost::getElemSize());

  }







  template <typename CoordT, int Dims = Dimensions,
            typename = detail::enable_if_t<
                (Dims > 0) && (detail::is_genint<CoordT>::value) &&
                (IsValidCoordDataT<Dims, CoordT>::value) &&
                ((IsImageAcc && IsImageAccessWriteOnly) ||
                 (IsHostImageAcc && IsImageAccessAnyWrite))>>
  void write(const CoordT &Coords, const DataT &Color) const {



    imageWriteHostImpl(Coords, Color, getOffset() ,
                       AccessorBaseHost::getElemSize(), MImgChannelType,
                       MImgChannelOrder,
                       AccessorBaseHost::getPtr() );

  }
};

template <typename DataT, int Dimensions, access::mode AccessMode,
          access::placeholder IsPlaceholder>
class __image_array_slice__ {

  static_assert(Dimensions < 3,
                "Image slice cannot have more then 2 dimensions");

  constexpr static int AdjustedDims = (Dimensions == 2) ? 4 : Dimensions + 1;

  template <typename CoordT,
            typename CoordElemType =
                typename detail::TryToGetElementType<CoordT>::type>
  sycl::vec<CoordElemType, AdjustedDims>
  getAdjustedCoords(const CoordT &Coords) const {
    CoordElemType LastCoord = 0;

    if (std::is_same<float, CoordElemType>::value) {
      sycl::vec<int, Dimensions + 1> Size = MBaseAcc.getRangeInternal();
      LastCoord =
          MIdx / static_cast<float>(Size.template swizzle<Dimensions>());
    } else {
      LastCoord = MIdx;
    }

    sycl::vec<CoordElemType, Dimensions> LeftoverCoords{LastCoord};
    sycl::vec<CoordElemType, AdjustedDims> AdjustedCoords{Coords,
                                                          LeftoverCoords};
    return AdjustedCoords;
  }

public:
  __image_array_slice__(
      accessor<DataT, Dimensions, AccessMode, access::target::image_array,
               IsPlaceholder, ONEAPI::accessor_property_list<>>
          BaseAcc,
      size_t Idx)
      : MBaseAcc(BaseAcc), MIdx(Idx) {}

  template <typename CoordT, int Dims = Dimensions,
            typename = detail::enable_if_t<
                (Dims > 0) && (IsValidCoordDataT<Dims, CoordT>::value)>>
  DataT read(const CoordT &Coords) const {
    return MBaseAcc.read(getAdjustedCoords(Coords));
  }

  template <typename CoordT, int Dims = Dimensions,
            typename = detail::enable_if_t<
                (Dims > 0) && IsValidCoordDataT<Dims, CoordT>::value>>
  DataT read(const CoordT &Coords, const sampler &Smpl) const {
    return MBaseAcc.read(getAdjustedCoords(Coords), Smpl);
  }

  template <typename CoordT, int Dims = Dimensions,
            typename = detail::enable_if_t<
                (Dims > 0) && IsValidCoordDataT<Dims, CoordT>::value>>
  void write(const CoordT &Coords, const DataT &Color) const {
    return MBaseAcc.write(getAdjustedCoords(Coords), Color);
  }
# 734 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  size_t get_count() const {
    return MBaseAcc.MImageCount / MBaseAcc.getAccessRange()[Dimensions];
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<(Dims == 1 || Dims == 2)>>
  range<Dims> get_range() const {
    return detail::convertToArrayOfN<Dims, 1>(MBaseAcc.getAccessRange());
  }



private:
  size_t MIdx;
  accessor<DataT, Dimensions, AccessMode, access::target::image_array,
           IsPlaceholder, ONEAPI::accessor_property_list<>>
      MBaseAcc;
};

}






template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder,
          typename PropertyListT>
class accessor :

    public detail::AccessorBaseHost,

    public detail::accessor_common<DataT, Dimensions, AccessMode, AccessTarget,
                                   IsPlaceholder, PropertyListT> {
protected:
  static_assert((AccessTarget == access::target::global_buffer ||
                 AccessTarget == access::target::constant_buffer ||
                 AccessTarget == access::target::host_buffer),
                "Expected buffer type");

  static_assert((AccessTarget == access::target::global_buffer ||
                 AccessTarget == access::target::host_buffer) ||
                (AccessTarget == access::target::constant_buffer &&
                 AccessMode == access::mode::read),
                "Access mode can be only read for constant buffers");

  static_assert(detail::IsPropertyListT<PropertyListT>::value,
                "PropertyListT must be accessor_property_list");

  using AccessorCommonT =
      detail::accessor_common<DataT, Dimensions, AccessMode, AccessTarget,
                              IsPlaceholder, PropertyListT>;

  constexpr static int AdjustedDim = Dimensions == 0 ? 1 : Dimensions;

  using AccessorCommonT::AS;
  using AccessorCommonT::IsAccessAnyWrite;
  using AccessorCommonT::IsAccessReadOnly;
  using AccessorCommonT::IsConstantBuf;
  using AccessorCommonT::IsGlobalBuf;
  using AccessorCommonT::IsHostBuf;
  using AccessorCommonT::IsPlaceH;
  template <int Dims>
  using AccessorSubscript =
      typename AccessorCommonT::template AccessorSubscript<Dims>;

  using ConcreteASPtrType = typename detail::PtrValueType<DataT, AS>::type *;

  using RefType = detail::const_if_const_AS<AS, DataT> &;
  using ConstRefType = const DataT &;
  using PtrType = detail::const_if_const_AS<AS, DataT> *;

  template <int Dims = Dimensions> size_t getLinearIndex(id<Dims> Id) const {







    size_t Result = 0;
    for (int I = 0; I < Dims; ++I)
      Result = Result * getMemoryRange()[I] + getOffset()[I] + Id[I];
    return Result;
  }

  template <typename T, int Dims> static constexpr bool IsSameAsBuffer() {
    return std::is_same<T, DataT>::value && (Dims > 0) && (Dims == Dimensions);
  }

  static access::mode getAdjustedMode(const PropertyListT &PropertyList) {
    access::mode AdjustedMode = AccessMode;

    if (PropertyList.template has_property<property::noinit>()) {
      if (AdjustedMode == access::mode::write) {
        AdjustedMode = access::mode::discard_write;
      } else if (AdjustedMode == access::mode::read_write) {
        AdjustedMode = access::mode::discard_read_write;
      }
    }

    return AdjustedMode;
  }



  template <typename TagT> static constexpr bool IsValidTag() {
    return std::is_same<TagT, mode_tag_t<AccessMode>>::value ||
           std::is_same<TagT,
                        mode_target_tag_t<AccessMode, AccessTarget>>::value;
  }
# 914 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  using AccessorBaseHost::getAccessRange;
  using AccessorBaseHost::getMemoryRange;
  using AccessorBaseHost::getOffset;

  char padding[sizeof(detail::AccessorImplDevice<AdjustedDim>) +
               sizeof(PtrType) - sizeof(detail::AccessorBaseHost)];

  PtrType getQualifiedPtr() const {
    return reinterpret_cast<PtrType>(AccessorBaseHost::getPtr());
  }



private:
  friend class sycl::INTEL::gpu::AccessorPrivateProxy;

public:
  using value_type = DataT;
  using reference = DataT &;
  using const_reference = const DataT &;
# 958 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
public:
  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                std::is_same<T, DataT>::value && Dims == 0 &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))> * = nullptr>
  accessor(buffer<T, 1, AllocatorT> &BufferRef,
           const property_list &PropertyList = {})




      : AccessorBaseHost(
                       {0, 0, 0}, detail::convertToArrayOfN<3, 1>(range<1>{1}),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), AdjustedDim, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    if (!IsPlaceH)
      addHostAccessorAndWait(AccessorBaseHost::impl.get());

  }

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                std::is_same<T, DataT>::value && Dims == 0 &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))> * = nullptr>
  accessor(
      buffer<T, 1, AllocatorT> &BufferRef,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})




      : AccessorBaseHost(
                       {0, 0, 0}, detail::convertToArrayOfN<3, 1>(range<1>{1}),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), AdjustedDim, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    if (!IsPlaceH)
      addHostAccessorAndWait(AccessorBaseHost::impl.get());

  }

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = typename detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                std::is_same<T, DataT>::value && (Dims == 0) &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(buffer<T, 1, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           const property_list &PropertyList = {})






      : AccessorBaseHost(
                       {0, 0, 0}, detail::convertToArrayOfN<3, 1>(range<1>{1}),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), Dimensions, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    detail::associateWithHandler(CommandGroupHandler, this, AccessTarget);
  }


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = typename detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                std::is_same<T, DataT>::value && (Dims == 0) &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(
      buffer<T, 1, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})






      : AccessorBaseHost(
                       {0, 0, 0}, detail::convertToArrayOfN<3, 1>(range<1>{1}),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), Dimensions, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    detail::associateWithHandler(CommandGroupHandler, this, AccessTarget);
  }


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef,
           const property_list &PropertyList = {})





      : AccessorBaseHost(
                       {0, 0, 0},
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), Dimensions, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    if (!IsPlaceH)
      addHostAccessorAndWait(AccessorBaseHost::impl.get());
  }


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})





      : AccessorBaseHost(
                       {0, 0, 0},
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), Dimensions, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    if (!IsPlaceH)
      addHostAccessorAndWait(AccessorBaseHost::impl.get());
  }




  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, TagT,
           const property_list &PropertyList = {})
      : accessor(BufferRef, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT, typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, TagT,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, PropertyList) {}


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           const property_list &PropertyList = {})






      : AccessorBaseHost(
                       {0, 0, 0},
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), Dimensions, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    detail::associateWithHandler(CommandGroupHandler, this, AccessTarget);
  }


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})






      : AccessorBaseHost(
                       {0, 0, 0},
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
            getAdjustedMode(PropertyList),
            detail::getSyclObjImpl(BufferRef).get(), Dimensions, sizeof(DataT),
            BufferRef.OffsetInBytes, BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    detail::associateWithHandler(CommandGroupHandler, this, AccessTarget);
  }




  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && !IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           TagT, const property_list &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT, typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && !IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      TagT,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef,
           range<Dimensions> AccessRange,
           const property_list &PropertyList = {})
      : accessor(BufferRef, AccessRange, {}, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, range<Dimensions> AccessRange,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, AccessRange, {}, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf)>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef,
           range<Dimensions> AccessRange, TagT,
           const property_list &PropertyList = {})
      : accessor(BufferRef, AccessRange, {}, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT, typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf)>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, range<Dimensions> AccessRange,
      TagT,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, AccessRange, {}, PropertyList) {}


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           range<Dimensions> AccessRange,
           const property_list &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, AccessRange, {},
                 PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      range<Dimensions> AccessRange,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, AccessRange, {},
                 PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && !IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           range<Dimensions> AccessRange, TagT,
           const property_list &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, AccessRange, {},
                 PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT, typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && !IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      range<Dimensions> AccessRange, TagT,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, AccessRange, {},
                 PropertyList) {}


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef,
           range<Dimensions> AccessRange, id<Dimensions> AccessOffset,
           const property_list &PropertyList = {})





      : AccessorBaseHost(detail::convertToArrayOfN<3, 0>(AccessOffset),
                         detail::convertToArrayOfN<3, 1>(AccessRange),
                         detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
                         getAdjustedMode(PropertyList),
                         detail::getSyclObjImpl(BufferRef).get(), Dimensions,
                         sizeof(DataT), BufferRef.OffsetInBytes,
                         BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    if (!IsPlaceH)
      addHostAccessorAndWait(AccessorBaseHost::impl.get());
  }


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                ((!IsPlaceH && IsHostBuf) ||
                 (IsPlaceH && (IsGlobalBuf || IsConstantBuf)))>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, range<Dimensions> AccessRange,
      id<Dimensions> AccessOffset,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})





      : AccessorBaseHost(detail::convertToArrayOfN<3, 0>(AccessOffset),
                         detail::convertToArrayOfN<3, 1>(AccessRange),
                         detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
                         getAdjustedMode(PropertyList),
                         detail::getSyclObjImpl(BufferRef).get(), Dimensions,
                         sizeof(DataT), BufferRef.OffsetInBytes,
                         BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    if (!IsPlaceH)
      addHostAccessorAndWait(AccessorBaseHost::impl.get());
  }




  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf)>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef,
           range<Dimensions> AccessRange, id<Dimensions> AccessOffset, TagT,
           const property_list &PropertyList = {})
      : accessor(BufferRef, AccessRange, AccessOffset, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT, typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf)>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, range<Dimensions> AccessRange,
      id<Dimensions> AccessOffset, TagT,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, AccessRange, AccessOffset, PropertyList) {}


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           range<Dimensions> AccessRange, id<Dimensions> AccessOffset,
           const property_list &PropertyList = {})






      : AccessorBaseHost(detail::convertToArrayOfN<3, 0>(AccessOffset),
                         detail::convertToArrayOfN<3, 1>(AccessRange),
                         detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
                         getAdjustedMode(PropertyList),
                         detail::getSyclObjImpl(BufferRef).get(), Dimensions,
                         sizeof(DataT), BufferRef.OffsetInBytes,
                         BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    detail::associateWithHandler(CommandGroupHandler, this, AccessTarget);
  }


  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() &&
                (!IsPlaceH && (IsGlobalBuf || IsConstantBuf || IsHostBuf))>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      range<Dimensions> AccessRange, id<Dimensions> AccessOffset,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})






      : AccessorBaseHost(detail::convertToArrayOfN<3, 0>(AccessOffset),
                         detail::convertToArrayOfN<3, 1>(AccessRange),
                         detail::convertToArrayOfN<3, 1>(BufferRef.get_range()),
                         getAdjustedMode(PropertyList),
                         detail::getSyclObjImpl(BufferRef).get(), Dimensions,
                         sizeof(DataT), BufferRef.OffsetInBytes,
                         BufferRef.IsSubBuffer) {
    checkDeviceAccessorBufferSize(BufferRef.get_count());
    detail::associateWithHandler(CommandGroupHandler, this, AccessTarget);
  }




  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT,
            typename = detail::enable_if_t<
                detail::IsRunTimePropertyListT<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && !IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
           range<Dimensions> AccessRange, id<Dimensions> AccessOffset, TagT,
           const property_list &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, AccessRange, AccessOffset,
                 PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename TagT, typename... PropTypes,
            typename = detail::enable_if_t<
                detail::IsCxPropertyList<PropertyListT>::value &&
                IsSameAsBuffer<T, Dims>() && IsValidTag<TagT>() && !IsPlaceH &&
                (IsGlobalBuf || IsConstantBuf || IsHostBuf)>>
  accessor(
      buffer<T, Dims, AllocatorT> &BufferRef, handler &CommandGroupHandler,
      range<Dimensions> AccessRange, id<Dimensions> AccessOffset, TagT,
      const ONEAPI::accessor_property_list<PropTypes...> &PropertyList = {})
      : accessor(BufferRef, CommandGroupHandler, AccessRange, AccessOffset,
                 PropertyList) {}


  template <typename... NewPropsT>
  accessor(
      const accessor<DataT, Dimensions, AccessMode, AccessTarget, IsPlaceholder,
                     ONEAPI::accessor_property_list<NewPropsT...>> &Other)



      : detail::AccessorBaseHost(Other)

  {
    static_assert(detail::IsCxPropertyList<PropertyListT>::value,
                  "Conversion is only available for accessor_property_list");
    static_assert(
        PropertyListT::template areSameCompileTimeProperties<NewPropsT...>(),
        "Compile-time-constant properties must be the same");
  }

  constexpr bool is_placeholder() const { return IsPlaceH; }

  size_t get_size() const { return getAccessRange().size() * sizeof(DataT); }

  size_t get_count() const { return getAccessRange().size(); }

  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 0)>>
  range<Dimensions> get_range() const {
    return detail::convertToArrayOfN<Dimensions, 1>(getAccessRange());
  }

  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 0)>>
  id<Dimensions> get_offset() const {
    return detail::convertToArrayOfN<Dimensions, 0>(getOffset());
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<Dims == 0 && IsAccessAnyWrite>>
  operator RefType() const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return *(getQualifiedPtr() + LinearIndex);
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<(Dims > 0) && IsAccessAnyWrite>>
  RefType operator[](id<Dimensions> Index) const {
    const size_t LinearIndex = getLinearIndex(Index);
    return getQualifiedPtr()[LinearIndex];
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<Dims == 0 && IsAccessReadOnly>>
  operator DataT() const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return *(getQualifiedPtr() + LinearIndex);
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<(Dims > 0) && IsAccessReadOnly, ConstRefType>
  operator[](id<Dimensions> Index) const {
    const size_t LinearIndex = getLinearIndex(Index);
    return getQualifiedPtr()[LinearIndex];
  }

  template <int Dims = Dimensions>
  operator typename detail::enable_if_t<
      Dims == 0 && AccessMode == access::mode::atomic, atomic<DataT, AS>>()
      const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return atomic<DataT, AS>(
        multi_ptr<DataT, AS>(getQualifiedPtr() + LinearIndex));
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<(Dims > 0) && AccessMode == access::mode::atomic,
                               atomic<DataT, AS>>
  operator[](id<Dimensions> Index) const {
    const size_t LinearIndex = getLinearIndex(Index);
    return atomic<DataT, AS>(
        multi_ptr<DataT, AS>(getQualifiedPtr() + LinearIndex));
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<Dims == 1 && AccessMode == access::mode::atomic,
                               atomic<DataT, AS>>
  operator[](size_t Index) const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>(Index));
    return atomic<DataT, AS>(
        multi_ptr<DataT, AS>(getQualifiedPtr() + LinearIndex));
  }

  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 1)>>
  typename AccessorCommonT::template AccessorSubscript<Dims - 1>
  operator[](size_t Index) const {
    return AccessorSubscript<Dims - 1>(*this, Index);
  }

  template <access::target AccessTarget_ = AccessTarget,
            typename = detail::enable_if_t<AccessTarget_ ==
                                           access::target::host_buffer>>
  DataT *get_pointer() const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return getQualifiedPtr() + LinearIndex;
  }

  template <access::target AccessTarget_ = AccessTarget,
            typename = detail::enable_if_t<AccessTarget_ ==
                                           access::target::global_buffer>>
  global_ptr<DataT> get_pointer() const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return global_ptr<DataT>(getQualifiedPtr() + LinearIndex);
  }

  template <access::target AccessTarget_ = AccessTarget,
            typename = detail::enable_if_t<AccessTarget_ ==
                                           access::target::constant_buffer>>
  constant_ptr<DataT> get_pointer() const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return constant_ptr<DataT>(getQualifiedPtr() + LinearIndex);
  }

  bool operator==(const accessor &Rhs) const { return impl == Rhs.impl; }
  bool operator!=(const accessor &Rhs) const { return !(*this == Rhs); }

private:
  void checkDeviceAccessorBufferSize(const size_t elemInBuffer) {
    if (!IsHostBuf && elemInBuffer == 0)
      throw cl::sycl::invalid_object_error(
          "SYCL buffer size is zero. To create a device accessor, SYCL "
          "buffer size must be greater than zero.",
          PI_INVALID_VALUE);
  }
};



template <typename DataT, int Dimensions, typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>)
    ->accessor<DataT, Dimensions, access::mode::read_write,
               target::global_buffer, access::placeholder::true_t>;

template <typename DataT, int Dimensions, typename AllocatorT,
          typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, access::mode::read_write,
               target::global_buffer, access::placeholder::true_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type1>(),
               detail::deduceAccessTarget<Type1, Type1>(target::global_buffer),
               access::placeholder::true_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type1>(),
               detail::deduceAccessTarget<Type1, Type1>(target::global_buffer),
               access::placeholder::true_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type2>(),
               detail::deduceAccessTarget<Type1, Type2>(target::global_buffer),
               access::placeholder::true_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type2>(),
               detail::deduceAccessTarget<Type1, Type2>(target::global_buffer),
               access::placeholder::true_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type2, Type3>(),
               detail::deduceAccessTarget<Type2, Type3>(target::global_buffer),
               access::placeholder::true_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type2, Type3>(),
               detail::deduceAccessTarget<Type2, Type3>(target::global_buffer),
               access::placeholder::true_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename Type4>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3, Type4)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type3, Type4>(),
               detail::deduceAccessTarget<Type3, Type4>(target::global_buffer),
               access::placeholder::true_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename Type4, typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3, Type4,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type3, Type4>(),
               detail::deduceAccessTarget<Type3, Type4>(target::global_buffer),
               access::placeholder::true_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler)
    ->accessor<DataT, Dimensions, access::mode::read_write,
               target::global_buffer, access::placeholder::false_t>;

template <typename DataT, int Dimensions, typename AllocatorT,
          typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, access::mode::read_write,
               target::global_buffer, access::placeholder::false_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type1>(),
               detail::deduceAccessTarget<Type1, Type1>(target::global_buffer),
               access::placeholder::false_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type1>(),
               detail::deduceAccessTarget<Type1, Type1>(target::global_buffer),
               access::placeholder::false_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1, Type2)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type2>(),
               detail::deduceAccessTarget<Type1, Type2>(target::global_buffer),
               access::placeholder::false_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1, Type2,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type1, Type2>(),
               detail::deduceAccessTarget<Type1, Type2>(target::global_buffer),
               access::placeholder::false_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1, Type2, Type3)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type2, Type3>(),
               detail::deduceAccessTarget<Type2, Type3>(target::global_buffer),
               access::placeholder::false_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1, Type2, Type3,
         const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type2, Type3>(),
               detail::deduceAccessTarget<Type2, Type3>(target::global_buffer),
               access::placeholder::false_t,
               ONEAPI::accessor_property_list<PropsT...>>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename Type4>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1, Type2, Type3,
         Type4)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type3, Type4>(),
               detail::deduceAccessTarget<Type3, Type4>(target::global_buffer),
               access::placeholder::false_t>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename Type4, typename... PropsT>
accessor(buffer<DataT, Dimensions, AllocatorT>, handler, Type1, Type2, Type3,
         Type4, const ONEAPI::accessor_property_list<PropsT...> &)
    ->accessor<DataT, Dimensions, detail::deduceAccessMode<Type3, Type4>(),
               detail::deduceAccessTarget<Type3, Type4>(target::global_buffer),
               access::placeholder::false_t,
               ONEAPI::accessor_property_list<PropsT...>>;





template <typename DataT, int Dimensions, access::mode AccessMode,
          access::placeholder IsPlaceholder>
class accessor<DataT, Dimensions, AccessMode, access::target::local,
               IsPlaceholder> :

    public detail::LocalAccessorBaseHost,

    public detail::accessor_common<DataT, Dimensions, AccessMode,
                                   access::target::local, IsPlaceholder> {
protected:
  constexpr static int AdjustedDim = Dimensions == 0 ? 1 : Dimensions;

  using AccessorCommonT =
      detail::accessor_common<DataT, Dimensions, AccessMode,
                              access::target::local, IsPlaceholder>;

  using AccessorCommonT::AS;
  using AccessorCommonT::IsAccessAnyWrite;
  template <int Dims>
  using AccessorSubscript =
      typename AccessorCommonT::template AccessorSubscript<Dims>;

  using ConcreteASPtrType = typename detail::PtrValueType<DataT, AS>::type *;

  using RefType = detail::const_if_const_AS<AS, DataT> &;
  using PtrType = detail::const_if_const_AS<AS, DataT> *;
# 1823 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  char padding[sizeof(detail::LocalAccessorBaseDevice<AdjustedDim>) +
               sizeof(PtrType) - sizeof(detail::LocalAccessorBaseHost)];
  using detail::LocalAccessorBaseHost::getSize;

  PtrType getQualifiedPtr() const {
    return reinterpret_cast<PtrType>(LocalAccessorBaseHost::getPtr());
  }




  template <int Dims = AdjustedDim> size_t getLinearIndex(id<Dims> Id) const {
    size_t Result = 0;
    for (int I = 0; I < Dims; ++I)
      Result = Result * getSize()[I] + Id[I];
    return Result;
  }

public:
  using value_type = DataT;
  using reference = DataT &;
  using const_reference = const DataT &;

  template <int Dims = Dimensions, typename = detail::enable_if_t<Dims == 0>>
  accessor(handler &)




      : LocalAccessorBaseHost(range<3>{1, 1, 1}, AdjustedDim, sizeof(DataT)) {
  }


  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 0)>>
  accessor(range<Dimensions> AllocationSize, handler &)




      : LocalAccessorBaseHost(detail::convertToArrayOfN<3, 1>(AllocationSize),
                              AdjustedDim, sizeof(DataT)) {
  }


  size_t get_size() const { return getSize().size() * sizeof(DataT); }

  size_t get_count() const { return getSize().size(); }

  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 0)>>
  range<Dims> get_range() const {
    return detail::convertToArrayOfN<Dims, 1>(getSize());
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<Dims == 0 && IsAccessAnyWrite>>
  operator RefType() const {
    return *getQualifiedPtr();
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<(Dims > 0) && IsAccessAnyWrite>>
  RefType operator[](id<Dimensions> Index) const {
    const size_t LinearIndex = getLinearIndex(Index);
    return getQualifiedPtr()[LinearIndex];
  }

  template <int Dims = Dimensions,
            typename = detail::enable_if_t<Dims == 1 && IsAccessAnyWrite>>
  RefType operator[](size_t Index) const {
    return getQualifiedPtr()[Index];
  }

  template <int Dims = Dimensions>
  operator typename detail::enable_if_t<
      Dims == 0 && AccessMode == access::mode::atomic, atomic<DataT, AS>>()
      const {
    return atomic<DataT, AS>(multi_ptr<DataT, AS>(getQualifiedPtr()));
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<(Dims > 0) && AccessMode == access::mode::atomic,
                               atomic<DataT, AS>>
  operator[](id<Dimensions> Index) const {
    const size_t LinearIndex = getLinearIndex(Index);
    return atomic<DataT, AS>(
        multi_ptr<DataT, AS>(getQualifiedPtr() + LinearIndex));
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<Dims == 1 && AccessMode == access::mode::atomic,
                               atomic<DataT, AS>>
  operator[](size_t Index) const {
    return atomic<DataT, AS>(multi_ptr<DataT, AS>(getQualifiedPtr() + Index));
  }

  template <int Dims = Dimensions, typename = detail::enable_if_t<(Dims > 1)>>
  typename AccessorCommonT::template AccessorSubscript<Dims - 1>
  operator[](size_t Index) const {
    return AccessorSubscript<Dims - 1>(*this, Index);
  }

  local_ptr<DataT> get_pointer() const {
    return local_ptr<DataT>(getQualifiedPtr());
  }

  bool operator==(const accessor &Rhs) const { return impl == Rhs.impl; }
  bool operator!=(const accessor &Rhs) const { return !(*this == Rhs); }
};






template <typename DataT, int Dimensions, access::mode AccessMode,
          access::placeholder IsPlaceholder>
class accessor<DataT, Dimensions, AccessMode, access::target::image,
               IsPlaceholder>
    : public detail::image_accessor<DataT, Dimensions, AccessMode,
                                    access::target::image, IsPlaceholder> {
public:
  template <typename AllocatorT>
  accessor(cl::sycl::image<Dimensions, AllocatorT> &Image,
           handler &CommandGroupHandler)
      : detail::image_accessor<DataT, Dimensions, AccessMode,
                               access::target::image, IsPlaceholder>(
            Image, CommandGroupHandler,
            (detail::getSyclObjImpl(Image))->getElementSize()) {

    detail::associateWithHandler(CommandGroupHandler, this,
                                 access::target::image);

  }
# 1970 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
};
# 1979 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
template <typename DataT, int Dimensions, access::mode AccessMode,
          access::placeholder IsPlaceholder>
class accessor<DataT, Dimensions, AccessMode, access::target::host_image,
               IsPlaceholder>
    : public detail::image_accessor<DataT, Dimensions, AccessMode,
                                    access::target::host_image, IsPlaceholder> {
public:
  template <typename AllocatorT>
  accessor(cl::sycl::image<Dimensions, AllocatorT> &Image)
      : detail::image_accessor<DataT, Dimensions, AccessMode,
                               access::target::host_image, IsPlaceholder>(
            Image, (detail::getSyclObjImpl(Image))->getElementSize()) {}
};
# 2001 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
template <typename DataT, int Dimensions, access::mode AccessMode,
          access::placeholder IsPlaceholder>
class accessor<DataT, Dimensions, AccessMode, access::target::image_array,
               IsPlaceholder>
    : public detail::image_accessor<DataT, Dimensions + 1, AccessMode,
                                    access::target::image, IsPlaceholder> {
# 2021 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
public:
  template <typename AllocatorT>
  accessor(cl::sycl::image<Dimensions + 1, AllocatorT> &Image,
           handler &CommandGroupHandler)
      : detail::image_accessor<DataT, Dimensions + 1, AccessMode,
                               access::target::image, IsPlaceholder>(
            Image, CommandGroupHandler,
            (detail::getSyclObjImpl(Image))->getElementSize()) {

    detail::associateWithHandler(CommandGroupHandler, this,
                                 access::target::image_array);

  }

  detail::__image_array_slice__<DataT, Dimensions, AccessMode, IsPlaceholder>
  operator[](size_t Index) const {
    return detail::__image_array_slice__<DataT, Dimensions, AccessMode,
                                         IsPlaceholder>(*this, Index);
  }
};

template <typename DataT, int Dimensions = 1,
          access_mode AccessMode = access_mode::read_write>
class host_accessor
    : public accessor<DataT, Dimensions, AccessMode, target::host_buffer,
                      access::placeholder::false_t> {
protected:
  using AccessorT = accessor<DataT, Dimensions, AccessMode, target::host_buffer,
                             access::placeholder::false_t>;

  constexpr static int AdjustedDim = Dimensions == 0 ? 1 : Dimensions;

  template <typename T, int Dims> static constexpr bool IsSameAsBuffer() {
    return std::is_same<T, DataT>::value && (Dims > 0) && (Dims == Dimensions);
  }



  template <typename TagT> static constexpr bool IsValidTag() {
    return std::is_same<TagT, mode_tag_t<AccessMode>>::value;
  }



  void
  __init(typename accessor<DataT, Dimensions, AccessMode, target::host_buffer,
                           access::placeholder::false_t>::ConcreteASPtrType Ptr,
         range<AdjustedDim> AccessRange, range<AdjustedDim> MemRange,
         id<AdjustedDim> Offset) {
    AccessorT::__init(Ptr, AccessRange, MemRange, Offset);
  }

public:
  host_accessor() : AccessorT() {}
# 2099 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/accessor.hpp" 3
  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = typename detail::enable_if_t<
                std::is_same<T, DataT>::value && Dims == 0>>
  host_accessor(buffer<T, 1, AllocatorT> &BufferRef,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<T, Dims, AllocatorT> &BufferRef,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                mode_tag_t<AccessMode>, const property_list &PropertyList = {})
      : host_accessor(BufferRef, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<T, Dims, AllocatorT> &BufferRef,
                handler &CommandGroupHandler,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, CommandGroupHandler, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                handler &CommandGroupHandler, mode_tag_t<AccessMode>,
                const property_list &PropertyList = {})
      : host_accessor(BufferRef, CommandGroupHandler, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                range<Dimensions> AccessRange,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, AccessRange, {}, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                range<Dimensions> AccessRange, mode_tag_t<AccessMode>,
                const property_list &PropertyList = {})
      : host_accessor(BufferRef, AccessRange, {}, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                handler &CommandGroupHandler, range<Dimensions> AccessRange,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, CommandGroupHandler, AccessRange, {},
                  PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                handler &CommandGroupHandler, range<Dimensions> AccessRange,
                mode_tag_t<AccessMode>, const property_list &PropertyList = {})
      : host_accessor(BufferRef, CommandGroupHandler, AccessRange, {},
                      PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                range<Dimensions> AccessRange, id<Dimensions> AccessOffset,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, AccessRange, AccessOffset, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                range<Dimensions> AccessRange, id<Dimensions> AccessOffset,
                mode_tag_t<AccessMode>, const property_list &PropertyList = {})
      : host_accessor(BufferRef, AccessRange, AccessOffset, PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                handler &CommandGroupHandler, range<Dimensions> AccessRange,
                id<Dimensions> AccessOffset,
                const property_list &PropertyList = {})
      : AccessorT(BufferRef, CommandGroupHandler, AccessRange, AccessOffset,
                  PropertyList) {}



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            typename = detail::enable_if_t<IsSameAsBuffer<T, Dims>()>>
  host_accessor(buffer<DataT, Dimensions, AllocatorT> &BufferRef,
                handler &CommandGroupHandler, range<Dimensions> AccessRange,
                id<Dimensions> AccessOffset, mode_tag_t<AccessMode>,
                const property_list &PropertyList = {})
      : host_accessor(BufferRef, CommandGroupHandler, AccessRange, AccessOffset,
                      PropertyList) {}


};



template <typename DataT, int Dimensions, typename AllocatorT>
host_accessor(buffer<DataT, Dimensions, AllocatorT>)
    ->host_accessor<DataT, Dimensions, access::mode::read_write>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1>
host_accessor(buffer<DataT, Dimensions, AllocatorT>, Type1)
    ->host_accessor<DataT, Dimensions,
                    detail::deduceAccessMode<Type1, Type1>()>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2>
host_accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2)
    ->host_accessor<DataT, Dimensions,
                    detail::deduceAccessMode<Type1, Type2>()>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3>
host_accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3)
    ->host_accessor<DataT, Dimensions,
                    detail::deduceAccessMode<Type2, Type3>()>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename Type4>
host_accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3, Type4)
    ->host_accessor<DataT, Dimensions,
                    detail::deduceAccessMode<Type3, Type4>()>;

template <typename DataT, int Dimensions, typename AllocatorT, typename Type1,
          typename Type2, typename Type3, typename Type4, typename Type5>
host_accessor(buffer<DataT, Dimensions, AllocatorT>, Type1, Type2, Type3, Type4,
              Type5)
    ->host_accessor<DataT, Dimensions,
                    detail::deduceAccessMode<Type4, Type5>()>;



}
}

namespace std {
template <typename DataT, int Dimensions, cl::sycl::access::mode AccessMode,
          cl::sycl::access::target AccessTarget,
          cl::sycl::access::placeholder IsPlaceholder>
struct hash<cl::sycl::accessor<DataT, Dimensions, AccessMode, AccessTarget,
                               IsPlaceholder>> {
  using AccType = cl::sycl::accessor<DataT, Dimensions, AccessMode,
                                     AccessTarget, IsPlaceholder>;

  size_t operator()(const AccType &A) const {







    auto AccImplPtr = cl::sycl::detail::getSyclObjImpl(A);
    return hash<decltype(AccImplPtr)>()(AccImplPtr);

  }
};

}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_accessor.hpp" 2 3

inline namespace cl {
namespace sycl {
namespace ONEAPI {



template <memory_order> struct order_tag_t {
  explicit order_tag_t() = default;
};
inline constexpr order_tag_t<memory_order::relaxed> relaxed_order{};
inline constexpr order_tag_t<memory_order::acquire> acquire_order{};
inline constexpr order_tag_t<memory_order::release> release_order{};
inline constexpr order_tag_t<memory_order::acq_rel> acq_rel_order{};
inline constexpr order_tag_t<memory_order::seq_cst> seq_cst_order{};

template <memory_scope> struct scope_tag_t {
  explicit scope_tag_t() = default;
};
inline constexpr scope_tag_t<memory_scope::work_item> work_item_scope{};
inline constexpr scope_tag_t<memory_scope::sub_group> sub_group_scope{};
inline constexpr scope_tag_t<memory_scope::work_group> work_group_scope{};
inline constexpr scope_tag_t<memory_scope::device> device_scope{};
inline constexpr scope_tag_t<memory_scope::system> system_scope{};



template <typename DataT, int Dimensions, memory_order DefaultOrder,
          memory_scope DefaultScope,
          access::target AccessTarget = access::target::global_buffer,
          access::placeholder IsPlaceholder = access::placeholder::false_t>
class atomic_accessor
    : public accessor<DataT, Dimensions, access::mode::read_write, AccessTarget,
                      IsPlaceholder, ONEAPI::accessor_property_list<>> {

  using AccessorT =
      accessor<DataT, Dimensions, access::mode::read_write, AccessTarget,
               IsPlaceholder, ONEAPI::accessor_property_list<>>;

private:
  using AccessorT::getLinearIndex;
  using AccessorT::getQualifiedPtr;


  multi_ptr<DataT, AccessorT::AS> get_pointer() const = delete;

protected:
  using AccessorT::AdjustedDim;

public:
  using value_type = DataT;
  using reference =
      atomic_ref<DataT, DefaultOrder, DefaultScope, AccessorT::AS>;

  using AccessorT::AccessorT;



  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            memory_order Order, memory_scope Scope>
  atomic_accessor(buffer<T, Dims, AllocatorT> &BufferRef, order_tag_t<Order>,
                  scope_tag_t<Scope>, const property_list &PropertyList = {})
      : atomic_accessor(BufferRef, PropertyList) {}

  template <typename T = DataT, int Dims = Dimensions, typename AllocatorT,
            memory_order Order, memory_scope Scope>
  atomic_accessor(buffer<T, Dims, AllocatorT> &BufferRef,
                  handler &CommandGroupHandler, order_tag_t<Order>,
                  scope_tag_t<Scope>, const property_list &PropertyList = {})
      : atomic_accessor(BufferRef, CommandGroupHandler, PropertyList) {}




  template <int Dims = Dimensions>
  operator typename detail::enable_if_t<Dims == 0, reference>() const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>());
    return reference(getQualifiedPtr()[LinearIndex]);
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<(Dims > 0), reference>
  operator[](id<Dimensions> Index) const {
    const size_t LinearIndex = getLinearIndex(Index);
    return reference(getQualifiedPtr()[LinearIndex]);
  }

  template <int Dims = Dimensions>
  typename detail::enable_if_t<Dims == 1, reference>
  operator[](size_t Index) const {
    const size_t LinearIndex = getLinearIndex(id<AdjustedDim>(Index));
    return reference(getQualifiedPtr()[LinearIndex]);
  }
};



template <typename DataT, int Dimensions, typename AllocatorT,
          memory_order Order, memory_scope Scope>
atomic_accessor(buffer<DataT, Dimensions, AllocatorT>, order_tag_t<Order>,
                scope_tag_t<Scope>, property_list = {})
    ->atomic_accessor<DataT, Dimensions, Order, Scope, target::global_buffer,
                      access::placeholder::true_t>;

template <typename DataT, int Dimensions, typename AllocatorT,
          memory_order Order, memory_scope Scope>
atomic_accessor(buffer<DataT, Dimensions, AllocatorT>, handler,
                order_tag_t<Order>, scope_tag_t<Scope>, property_list = {})
    ->atomic_accessor<DataT, Dimensions, Order, Scope, target::global_buffer,
                      access::placeholder::false_t>;



}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_fence.hpp" 1 3
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic_fence.hpp" 3
inline namespace cl {
namespace sycl {
namespace ONEAPI {
namespace detail {
using namespace cl::sycl::detail;
}

static inline void atomic_fence(memory_order order, memory_scope scope) {





  (void)scope;
  auto StdOrder = detail::getStdMemoryOrder(order);
  atomic_thread_fence(StdOrder);

}

}
}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/atomic.hpp" 2 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/experimental/builtins.hpp" 1 3
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/experimental/builtins.hpp" 3
inline namespace cl {
namespace sycl {
namespace ONEAPI {
namespace experimental {
# 61 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/experimental/builtins.hpp" 3
template <typename... Args>
int printf(const char *__format, Args... args) {



  return ::printf(__format, args...);

}

}
}
}
}
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/filter_selector.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/filter_selector.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device_selector.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device_selector.hpp" 3
inline namespace cl {
namespace sycl {


class device;







class __attribute__((visibility("default"))) device_selector {
protected:

  static constexpr int REJECT_DEVICE_SCORE = -1;

public:
  virtual ~device_selector() = default;

  virtual device select_device() const;

  virtual int operator()(const device &device) const = 0;
};






class __attribute__((visibility("default"))) default_selector : public device_selector {
public:
  int operator()(const device &dev) const override;
};






class __attribute__((visibility("default"))) gpu_selector : public device_selector {
public:
  int operator()(const device &dev) const override;
};






class __attribute__((visibility("default"))) cpu_selector : public device_selector {
public:
  int operator()(const device &dev) const override;
};






class __attribute__((visibility("default"))) accelerator_selector : public device_selector {
public:
  int operator()(const device &dev) const override;
};






class __attribute__((visibility("default"))) host_selector : public device_selector {
public:
  int operator()(const device &dev) const override;
};
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/filter_selector.hpp" 2 3






inline namespace cl {
namespace sycl {


class device;
class device_selector;

namespace ONEAPI {
namespace detail {
class filter_selector_impl;
}

class __attribute__((visibility("default"))) filter_selector : public device_selector {
public:
  filter_selector(const std::string &filter);
  int operator()(const device &dev) const override;
  void reset() const;
  device select_device() const override;

private:
  std::shared_ptr<detail::filter_selector_impl> impl;
};
}
}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/function_pointer.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/function_pointer.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/experimental/spec_constant.hpp" 1 3
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/experimental/spec_constant.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/sycl_fe_intrins.hpp" 1 3
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/experimental/spec_constant.hpp" 2 3


inline namespace cl {
namespace sycl {
class program;

namespace ONEAPI {
namespace experimental {

class spec_const_error : public compile_program_error {
  using compile_program_error::compile_program_error;
};

template <typename T, typename ID = T> class spec_constant {
public:
  spec_constant() {}

private:


  spec_constant(T Cst) : Val(Cst) {}

  T Val;

  friend class cl::sycl::program;

public:
  T get() const {




    return Val;

  }

  operator T() const {
    return get();
  }
};

}
}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/kernel_desc.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/kernel_desc.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {






enum class kernel_param_kind_t {
  kind_accessor,
  kind_std_layout,
  kind_sampler,
  kind_pointer
};


struct kernel_param_desc_t {

  kernel_param_kind_t kind;




  int info;


  int offset;
};


template <class Name> struct SpecConstantInfo {
  static constexpr const char *getName() { return ""; }
};


template <class KernelNameType> struct KernelInfo {
  static constexpr unsigned getNumParams() { return 0; }
  static const kernel_param_desc_t &getParamDesc(int) {
    static kernel_param_desc_t Dummy;
    return Dummy;
  }
  static constexpr const char *getName() { return ""; }
};
# 93 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/kernel_desc.hpp" 3
}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/kernel.hpp" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/kernel.hpp" 3
inline namespace cl {
namespace sycl {

class program;
class context;
namespace detail {
class kernel_impl;
}
# 34 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/kernel.hpp" 3
class __attribute__((visibility("default"))) kernel {
public:







  kernel(cl_kernel ClKernel, const context &SyclContext);

  kernel(const kernel &RHS) = default;

  kernel(kernel &&RHS) = default;

  kernel &operator=(const kernel &RHS) = default;

  kernel &operator=(kernel &&RHS) = default;

  bool operator==(const kernel &RHS) const { return impl == RHS.impl; }

  bool operator!=(const kernel &RHS) const { return !operator==(RHS); }
# 64 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/kernel.hpp" 3
  cl_kernel get() const;




  bool is_host() const;







  context get_context() const;







  program get_program() const;





  template <info::kernel param>
  typename info::param_traits<info::kernel, param>::return_type
  get_info() const;






  template <info::kernel_work_group param>
  typename info::param_traits<info::kernel_work_group, param>::return_type
  get_work_group_info(const device &Device) const;






  template <info::kernel_sub_group param>
  typename info::param_traits<info::kernel_sub_group, param>::return_type
  get_sub_group_info(const device &Device) const;







  template <info::kernel_sub_group param>
  typename info::param_traits<info::kernel_sub_group, param>::return_type
  get_sub_group_info(
      const device &Device,
      typename info::param_traits<info::kernel_sub_group, param>::input_type
          Value) const;

private:

  kernel(std::shared_ptr<detail::kernel_impl> Impl);

  shared_ptr_class<detail::kernel_impl> impl;

  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);
  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);
};
}
}

namespace std {
template <> struct hash<cl::sycl::kernel> {
  size_t operator()(const cl::sycl::kernel &Kernel) const {
    return hash<std::shared_ptr<cl::sycl::detail::kernel_impl>>()(
        cl::sycl::detail::getSyclObjImpl(Kernel));
  }
};
}
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 2 3



inline namespace cl {
namespace sycl {


class context;
class device;
namespace detail {
class program_impl;
}

enum class program_state { none, compiled, linked };







class __attribute__((visibility("default"))) program {
public:
  program() = delete;
# 51 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  explicit program(const context &Context, const property_list &PropList = {});
# 62 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  program(const context &Context, vector_class<device> DeviceList,
          const property_list &PropList = {});
# 77 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  program(vector_class<program> ProgramList,
          const property_list &PropList = {});
# 93 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  program(vector_class<program> ProgramList, string_class LinkOptions,
          const property_list &PropList = {});
# 107 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  program(const context &Context, cl_program ClProgram);

  program(const program &rhs) = default;

  program(program &&rhs) = default;

  program &operator=(const program &rhs) = default;

  program &operator=(program &&rhs) = default;

  bool operator==(const program &rhs) const { return impl == rhs.impl; }

  bool operator!=(const program &rhs) const { return impl != rhs.impl; }




  template <typename propertyT> bool has_property() const;







  template <typename propertyT> propertyT get_property() const;
# 141 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  cl_program get() const;


  bool is_host() const;
# 158 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  template <typename KernelT>
  void compile_with_kernel_type(string_class CompileOptions = "") {
    detail::OSModuleHandle M = detail::OSUtil::getOSModuleHandle(
        detail::KernelInfo<KernelT>::getName());
    compile_with_kernel_name(detail::KernelInfo<KernelT>::getName(),
                             CompileOptions, M);
  }
# 179 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  void compile_with_source(string_class KernelSource,
                           string_class CompileOptions = "");
# 195 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  template <typename KernelT>
  void build_with_kernel_type(string_class BuildOptions = "") {
    detail::OSModuleHandle M = detail::OSUtil::getOSModuleHandle(
        detail::KernelInfo<KernelT>::getName());
    build_with_kernel_name(detail::KernelInfo<KernelT>::getName(), BuildOptions,
                           M);
  }
# 216 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  void build_with_source(string_class KernelSource,
                         string_class BuildOptions = "");
# 230 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  void link(string_class LinkOptions = "");







  template <typename KernelT> bool has_kernel() const {
    return has_kernel(detail::KernelInfo<KernelT>::getName(),
                                              false);
  }
# 252 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  bool has_kernel(string_class KernelName) const;







  template <typename KernelT> kernel get_kernel() const {
    return get_kernel(detail::KernelInfo<KernelT>::getName(),
                                              false);
  }
# 272 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  kernel get_kernel(string_class KernelName) const;




  template <info::program param>
  typename info::param_traits<info::program, param>::return_type
  get_info() const;
# 289 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  vector_class<vector_class<char>> get_binaries() const;


  context get_context() const;


  vector_class<device> get_devices() const;
# 307 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  string_class get_compile_options() const;
# 323 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  string_class get_link_options() const;
# 333 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/program.hpp" 3
  string_class get_build_options() const;


  program_state get_state() const;






  template <typename ID, typename T>
  ONEAPI::experimental::spec_constant<T, ID> set_spec_constant(T Cst) {
    constexpr const char *Name = detail::SpecConstantInfo<ID>::getName();
    static_assert(std::is_integral<T>::value ||
                      std::is_floating_point<T>::value,
                  "unsupported specialization constant type");





    set_spec_constant_impl(Name, &Cst, sizeof(T));
    return ONEAPI::experimental::spec_constant<T, ID>(Cst);

  }




  template <backend BackendName>
  auto get_native() const -> typename interop<BackendName, program>::type {
    return reinterpret_cast<typename interop<BackendName, program>::type>(
        getNative());
  }

private:
  pi_native_handle getNative() const;
  program(shared_ptr_class<detail::program_impl> impl);







  kernel get_kernel(string_class KernelName, bool IsCreatedFromSource) const;







  bool has_kernel(string_class KernelName, bool IsCreatedFromSource) const;






  void compile_with_kernel_name(string_class KernelName,
                                string_class CompileOptions,
                                detail::OSModuleHandle M);






  void build_with_kernel_name(string_class KernelName,
                              string_class buildOptions,
                              detail::OSModuleHandle M);

  void set_spec_constant_impl(const char *Name, void *Data, size_t Size);

  shared_ptr_class<detail::program_impl> impl;

  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);
  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);
};
}
}

namespace std {
template <> struct hash<cl::sycl::program> {
  size_t operator()(const cl::sycl::program &prg) const {
    return hash<cl::sycl::shared_ptr_class<cl::sycl::detail::program_impl>>()(
        cl::sycl::detail::getSyclObjImpl(prg));
  }
};
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/function_pointer.hpp" 2 3




inline namespace cl {
namespace sycl {
namespace detail {
__attribute__((visibility("default"))) cl_ulong getDeviceFunctionPointerImpl(device &D, program &P,
                                                    const char *FuncName);
}
namespace ONEAPI {
# 34 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/function_pointer.hpp" 3
using device_func_ptr_holder_t = cl_ulong;



template <
    class FuncType,
    typename FuncPtrType = typename std::add_pointer<FuncType>::type,
    typename std::enable_if<std::is_function<FuncType>::value, int>::type = 0>
inline FuncPtrType to_device_func_ptr(device_func_ptr_holder_t FptrHolder) {
  return reinterpret_cast<FuncPtrType>(FptrHolder);
}

template <class FuncType>
using enable_if_is_function_pointer_t = typename std::enable_if<
    std::is_pointer<FuncType>::value &&
        std::is_function<typename std::remove_pointer<FuncType>::type>::value,
    int>::type;
# 69 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/function_pointer.hpp" 3
template <class FuncType, enable_if_is_function_pointer_t<FuncType> = 0>
device_func_ptr_holder_t get_device_func_ptr(FuncType F, const char *FuncName,
                                             program &P, device &D) {


  if (D.is_host()) {
    return reinterpret_cast<device_func_ptr_holder_t>(F);
  }

  if (program_state::linked != P.get_state()) {
    throw invalid_parameter_error(
        "Program must be built before passing to get_device_func_ptr",
        PI_INVALID_OPERATION);
  }

  return sycl::detail::getDeviceFunctionPointerImpl(D, P, FuncName);
}
}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/functional.hpp" 1 3
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/functional.hpp" 3
inline namespace cl {
namespace sycl {
namespace ONEAPI {

template <typename T = void> struct minimum {
  T operator()(const T &lhs, const T &rhs) const {
    return std::less<T>()(lhs, rhs) ? lhs : rhs;
  }
};


template <> struct minimum<void> {
  struct is_transparent {};
  template <typename T, typename U>
  auto operator()(T &&lhs, U &&rhs) const ->
      typename std::common_type<T &&, U &&>::type {
    return std::less<>()(std::forward<const T>(lhs), std::forward<const U>(rhs))
               ? std::forward<T>(lhs)
               : std::forward<U>(rhs);
  }
};


template <typename T = void> struct maximum {
  T operator()(const T &lhs, const T &rhs) const {
    return std::greater<T>()(lhs, rhs) ? lhs : rhs;
  }
};


template <> struct maximum<void> {
  struct is_transparent {};
  template <typename T, typename U>
  auto operator()(T &&lhs, U &&rhs) const ->
      typename std::common_type<T &&, U &&>::type {
    return std::greater<>()(std::forward<const T>(lhs),
                            std::forward<const U>(rhs))
               ? std::forward<T>(lhs)
               : std::forward<U>(rhs);
  }
};


template <typename T = void> using plus = std::plus<T>;
template <typename T = void> using multiplies = std::multiplies<T>;
template <typename T = void> using bit_or = std::bit_or<T>;
template <typename T = void> using bit_xor = std::bit_xor<T>;
template <typename T = void> using bit_and = std::bit_and<T>;

}
# 128 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/functional.hpp" 3
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/sub_group.hpp" 1 3
# 26 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/sub_group.hpp" 3
inline namespace cl {
namespace sycl {
template <typename T, access::address_space Space> class multi_ptr;

namespace detail {

namespace sub_group {


template <typename T>
using SelectBlockT = select_cl_scalar_integral_unsigned_t<T>;

template <typename T, access::address_space Space>
using AcceptableForGlobalLoadStore =
    bool_constant<!std::is_same<void, SelectBlockT<T>>::value &&
                  Space == access::address_space::global_space>;

template <typename T, access::address_space Space>
using AcceptableForLocalLoadStore =
    bool_constant<!std::is_same<void, SelectBlockT<T>>::value &&
                  Space == access::address_space::local_space>;
# 95 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/sub_group.hpp" 3
}

}

namespace ONEAPI {

struct sub_group {

  using id_type = id<1>;
  using range_type = range<1>;
  using linear_id_type = uint32_t;
  static constexpr int dimensions = 1;



  id_type get_local_id() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  linear_id_type get_local_linear_id() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  range_type get_local_range() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  range_type get_max_local_range() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  id_type get_group_id() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  linear_id_type get_group_linear_id() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  range_type get_group_range() const {



    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T>
  using EnableIfIsScalarArithmetic =
      sycl::detail::enable_if_t<sycl::detail::is_scalar_arithmetic<T>::value,
                                T>;




  template <typename T> T shuffle(T x, id_type local_id) const {



    (void)x;
    (void)local_id;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T> T shuffle_down(T x, uint32_t delta) const {



    (void)x;
    (void)delta;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T> T shuffle_up(T x, uint32_t delta) const {



    (void)x;
    (void)delta;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T> T shuffle_xor(T x, id_type value) const {



    (void)x;
    (void)value;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }




  template <typename T>
  __attribute__((deprecated("Two-input sub-group shuffles are deprecated.")))
  T shuffle(T x, T y, id_type local_id) const {




    (void)x;
    (void)y;
    (void)local_id;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T>
  __attribute__((deprecated("Two-input sub-group shuffles are deprecated.")))
  T shuffle_down(T current, T next, uint32_t delta) const {



    (void)current;
    (void)next;
    (void)delta;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T>
  __attribute__((deprecated("Two-input sub-group shuffles are deprecated.")))
  T shuffle_up(T previous, T current, uint32_t delta) const {



    (void)previous;
    (void)current;
    (void)delta;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }




  template <typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForGlobalLoadStore<T, Space>::value, T>
  load(const multi_ptr<T, Space> src) const {



    (void)src;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForLocalLoadStore<T, Space>::value, T>
  load(const multi_ptr<T, Space> src) const {



    (void)src;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <int N, typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForGlobalLoadStore<T, Space>::value &&
          N != 1,
      vec<T, N>>
  load(const multi_ptr<T, Space> src) const {



    (void)src;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <int N, typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForLocalLoadStore<T, Space>::value,
      vec<T, N>>
  load(const multi_ptr<T, Space> src) const {







    (void)src;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <int N, typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForGlobalLoadStore<T, Space>::value &&
          N == 1,
      vec<T, 1>>
  load(const multi_ptr<T, Space> src) const {



    (void)src;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForGlobalLoadStore<T, Space>::value>
  store(multi_ptr<T, Space> dst, const T &x) const {



    (void)dst;
    (void)x;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForLocalLoadStore<T, Space>::value>
  store(multi_ptr<T, Space> dst, const T &x) const {



    (void)dst;
    (void)x;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <int N, typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForGlobalLoadStore<T, Space>::value &&
      N == 1>
  store(multi_ptr<T, Space> dst, const vec<T, 1> &x) const {



    (void)dst;
    (void)x;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <int N, typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForGlobalLoadStore<T, Space>::value &&
      N != 1>
  store(multi_ptr<T, Space> dst, const vec<T, N> &x) const {



    (void)dst;
    (void)x;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <int N, typename T, access::address_space Space>
  sycl::detail::enable_if_t<
      sycl::detail::sub_group::AcceptableForLocalLoadStore<T, Space>::value>
  store(multi_ptr<T, Space> dst, const vec<T, N> &x) const {





    (void)dst;
    (void)x;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }


  void barrier() const {
# 432 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/sub_group.hpp" 3
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  __attribute__((deprecated("Sub-group barrier accepting fence_space is deprecated." "Use barrier() without a fence_space instead.")))

  void barrier(access::fence_space accessSpace) const {





    (void)accessSpace;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }


  template <typename T>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::broadcast instead.")))

  EnableIfIsScalarArithmetic<T> broadcast(T x, id<1> local_id) const {



    (void)x;
    (void)local_id;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, class BinaryOperation>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::reduce instead.")))

  EnableIfIsScalarArithmetic<T> reduce(T x, BinaryOperation op) const {





    (void)x;
    (void)op;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, class BinaryOperation>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::reduce instead.")))

  EnableIfIsScalarArithmetic<T> reduce(T x, T init, BinaryOperation op) const {



    (void)x;
    (void)init;
    (void)op;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, class BinaryOperation>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::exclusive_scan instead.")))

  EnableIfIsScalarArithmetic<T> exclusive_scan(T x, BinaryOperation op) const {





    (void)x;
    (void)op;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, class BinaryOperation>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::exclusive_scan instead.")))

  EnableIfIsScalarArithmetic<T> exclusive_scan(T x, T init,
                                               BinaryOperation op) const {
# 528 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/sub_group.hpp" 3
    (void)x;
    (void)init;
    (void)op;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, class BinaryOperation>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::inclusive_scan instead.")))

  EnableIfIsScalarArithmetic<T> inclusive_scan(T x, BinaryOperation op) const {





    (void)x;
    (void)op;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

  template <typename T, class BinaryOperation>
  __attribute__((deprecated("Collectives in the sub-group class are deprecated. Use " "sycl::ONEAPI::inclusive_scan instead.")))

  EnableIfIsScalarArithmetic<T> inclusive_scan(T x, BinaryOperation op,
                                               T init) const {






    (void)x;
    (void)op;
    (void)init;
    throw runtime_error("Sub-groups are not supported on host device.",
                        PI_INVALID_DEVICE);

  }

protected:
  template <int dimensions> friend class cl::sycl::nd_item;
  sub_group() = default;
};
}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 1 3
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/host_device_intel/backend.hpp" 1 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device_event.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/device_event.hpp" 3
inline namespace cl {
namespace sycl {






class device_event {
private:
  __ocl_event_t *m_Event;

public:
  device_event(const device_event &rhs) = default;
  device_event(device_event &&rhs) = default;
  device_event &operator=(const device_event &rhs) = default;
  device_event &operator=(device_event &&rhs) = default;

  device_event(__ocl_event_t *Event) : m_Event(Event) {}

  void wait() {
    __spirv_GroupWaitEvents(__spv::Scope::Workgroup, 1, m_Event);
  }
};

}
}
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/h_item.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/h_item.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/item.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/item.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/item_base.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/item_base.hpp" 3
inline namespace cl {
namespace sycl {
template <int dimensions> class id;
template <int dimensions> class range;

namespace detail {
template <int Dims, bool WithOffset> struct ItemBase;

template <int Dims> struct ItemBase<Dims, true> {

  bool operator==(const ItemBase &Rhs) const {
    return (Rhs.MIndex == MIndex) && (Rhs.MExtent == MExtent) &&
           (Rhs.MOffset == MOffset);
  }

  bool operator!=(const ItemBase &Rhs) const { return !((*this) == Rhs); }

  size_t get_linear_id() const {
    if (1 == Dims) {
      return MIndex[0] - MOffset[0];
    }
    if (2 == Dims) {
      return (MIndex[0] - MOffset[0]) * MExtent[1] + (MIndex[1] - MOffset[1]);
    }
    return ((MIndex[0] - MOffset[0]) * MExtent[1] * MExtent[2]) +
           ((MIndex[1] - MOffset[1]) * MExtent[2]) + (MIndex[2] - MOffset[2]);
  }

  range<Dims> MExtent;
  id<Dims> MIndex;
  id<Dims> MOffset;
};

template <int Dims> struct ItemBase<Dims, false> {

  bool operator==(const ItemBase &Rhs) const {
    return (Rhs.MIndex == MIndex) && (Rhs.MExtent == MExtent);
  }

  bool operator!=(const ItemBase &Rhs) const { return !((*this) == Rhs); }

  operator ItemBase<Dims, true>() const {
    return ItemBase<Dims, true>(MExtent, MIndex, id<Dims>{});
  }

  size_t get_linear_id() const {
    if (1 == Dims) {
      return MIndex[0];
    }
    if (2 == Dims) {
      return MIndex[0] * MExtent[1] + MIndex[1];
    }
    return (MIndex[0] * MExtent[1] * MExtent[2]) + (MIndex[1] * MExtent[2]) +
           MIndex[2];
  }

  range<Dims> MExtent;
  id<Dims> MIndex;
};

}
}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/item.hpp" 2 3






inline namespace cl {
namespace sycl {
namespace detail {
class Builder;
}
template <int dimensions> class id;
template <int dimensions> class range;





template <int dimensions = 1, bool with_offset = true> class item {





  class __private_class;

  template <bool B, typename T>
  using EnableIfT = detail::conditional_t<B, T, __private_class>;

public:
  item() = delete;

  id<dimensions> get_id() const { return MImpl.MIndex; }

  size_t __attribute__((always_inline)) get_id(int dimension) const {
    size_t Id = MImpl.MIndex[dimension];
                         ;
    return Id;
  }

  size_t __attribute__((always_inline)) operator[](int dimension) const {
    size_t Id = MImpl.MIndex[dimension];
                         ;
    return Id;
  }

  range<dimensions> get_range() const { return MImpl.MExtent; }

  size_t __attribute__((always_inline)) get_range(int dimension) const {
    size_t Id = MImpl.MExtent[dimension];
                         ;
    return Id;
  }

  operator EnableIfT<dimensions == 1, std::size_t>() const { return get_id(0); }

  template <bool has_offset = with_offset>
  detail::enable_if_t<has_offset, id<dimensions>> get_offset() const {
    return MImpl.MOffset;
  }

  template <bool has_offset = with_offset>
  detail::enable_if_t<has_offset, size_t>
      __attribute__((always_inline)) get_offset(int dimension) const {
    size_t Id = MImpl.MOffset[dimension];
                         ;
    return Id;
  }

  template <bool has_offset = with_offset>
  operator detail::enable_if_t<!has_offset, item<dimensions, true>>() const {
    return detail::Builder::createItem<dimensions, true>(
        MImpl.MExtent, MImpl.MIndex, {});
  }

  size_t __attribute__((always_inline)) get_linear_id() const {
    size_t Id = MImpl.get_linear_id();
                         ;
    return Id;
  }

  item(const item &rhs) = default;

  item(item<dimensions, with_offset> &&rhs) = default;

  item &operator=(const item &rhs) = default;

  item &operator=(item &&rhs) = default;

  bool operator==(const item &rhs) const { return rhs.MImpl == MImpl; }

  bool operator!=(const item &rhs) const { return rhs.MImpl != MImpl; }

protected:
  template <bool has_offset = with_offset>
  item(detail::enable_if_t<has_offset, const range<dimensions>> &extent,
       const id<dimensions> &index, const id<dimensions> &offset)
      : MImpl{extent, index, offset} {}

  template <bool has_offset = with_offset>
  item(detail::enable_if_t<!has_offset, const range<dimensions>> &extent,
       const id<dimensions> &index)
      : MImpl{extent, index} {}

  friend class detail::Builder;

private:
  detail::ItemBase<dimensions, with_offset> MImpl;
};

}
}
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/h_item.hpp" 2 3


inline namespace cl {
namespace sycl {

namespace detail {
class Builder;
}






template <int dimensions> class h_item {
public:
  h_item() = delete;

  h_item(const h_item &hi) = default;

  h_item &operator=(const h_item &hi) = default;


  item<dimensions, false> get_global() const { return globalItem; }

  item<dimensions, false> get_local() const { return get_logical_local(); }

  item<dimensions, false> get_logical_local() const { return logicalLocalItem; }

  item<dimensions, false> get_physical_local() const { return localItem; }

  range<dimensions> get_global_range() const {
    return get_global().get_range();
  }

  size_t get_global_range(int dimension) const {
    return get_global().get_range(dimension);
  }

  id<dimensions> get_global_id() const { return get_global().get_id(); }

  size_t get_global_id(int dimension) const {
    return get_global().get_id(dimension);
  }

  range<dimensions> get_local_range() const { return get_local().get_range(); }

  size_t get_local_range(int dimension) const {
    return get_local().get_range(dimension);
  }

  id<dimensions> get_local_id() const { return get_local().get_id(); }

  size_t get_local_id(int dimension) const {
    return get_local().get_id(dimension);
  }

  range<dimensions> get_logical_local_range() const {
    return get_logical_local().get_range();
  }

  size_t get_logical_local_range(int dimension) const {
    return get_logical_local().get_range(dimension);
  }

  id<dimensions> get_logical_local_id() const {
    return get_logical_local().get_id();
  }

  size_t get_logical_local_id(int dimension) const {
    return get_logical_local().get_id(dimension);
  }

  range<dimensions> get_physical_local_range() const {
    return get_physical_local().get_range();
  }

  size_t get_physical_local_range(int dimension) const {
    return get_physical_local().get_range(dimension);
  }

  id<dimensions> get_physical_local_id() const {
    return get_physical_local().get_id();
  }

  size_t get_physical_local_id(int dimension) const {
    return get_physical_local().get_id(dimension);
  }

  bool operator==(const h_item &rhs) const {
    return (rhs.localItem == localItem) && (rhs.globalItem == globalItem) &&
           (rhs.logicalLocalItem == logicalLocalItem);
  }

  bool operator!=(const h_item &rhs) const { return !((*this) == rhs); }

protected:
  friend class detail::Builder;
  friend class group<dimensions>;
  h_item(const item<dimensions, false> &GL, const item<dimensions, false> &L,
         const range<dimensions> &flexLocalRange)
      : globalItem(GL), localItem(L),
        logicalLocalItem(detail::Builder::createItem<dimensions, false>(
            flexLocalRange, L.get_id())) {}

  h_item(const item<dimensions, false> &GL, const item<dimensions, false> &L)
      : globalItem(GL), localItem(L),
        logicalLocalItem(detail::Builder::createItem<dimensions, false>(
            localItem.get_range(), localItem.get_id())) {}

  void setLogicalLocalID(const id<dimensions> &ID) {
    detail::Builder::updateItemIndex(logicalLocalItem, ID);
  }

private:

  item<dimensions, false> localItem;

  item<dimensions, false> globalItem;

  item<dimensions, false> logicalLocalItem;
};

}
}
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 2 3






inline namespace cl {
namespace sycl {
namespace detail {
class Builder;


static inline void workGroupBarrier() {
# 41 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 3
}

}







template <typename T, int Dimensions = 1> class private_memory {
public:

  private_memory(const group<Dimensions> &G) {



    Val.reset(new T[G.get_local_range().size()]);

    (void)G;
  }


  T &operator()(const h_item<Dimensions> &Id) {



    size_t Ind = Id.get_physical_local().get_linear_id();
    return Val.get()[Ind];




  }

private:







  std::unique_ptr<T[]> Val;

};





template <int Dimensions = 1> class group {
public:

  using id_type = id<Dimensions>;
  using range_type = range<Dimensions>;
  using linear_id_type = size_t;
  static constexpr int dimensions = Dimensions;


  group() = delete;

  id<Dimensions> get_id() const { return index; }

  size_t get_id(int dimension) const { return index[dimension]; }

  range<Dimensions> get_global_range() const { return globalRange; }

  size_t get_global_range(int dimension) const {
    return globalRange[dimension];
  }

  range<Dimensions> get_local_range() const { return localRange; }

  size_t get_local_range(int dimension) const { return localRange[dimension]; }

  range<Dimensions> get_group_range() const { return groupRange; }

  size_t get_group_range(int dimension) const {
    return get_group_range()[dimension];
  }

  size_t operator[](int dimension) const { return index[dimension]; }

  template <int dims = Dimensions>
  typename std::enable_if<(dims == 1), size_t>::type get_linear_id() const {
    return index[0];
  }

  template <int dims = Dimensions>
  typename std::enable_if<(dims == 2), size_t>::type get_linear_id() const {
    return index[0] * groupRange[1] + index[1];
  }
# 145 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 3
  template <int dims = Dimensions>
  typename std::enable_if<(dims == 3), size_t>::type get_linear_id() const {
    return (index[0] * groupRange[1] * groupRange[2]) +
           (index[1] * groupRange[2]) + index[2];
  }

  template <typename WorkItemFunctionT>
  void parallel_for_work_item(WorkItemFunctionT Func) const {


    detail::workGroupBarrier();
# 179 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 3
    id<Dimensions> GroupStartID = index * localRange;




    detail::NDLoop<dimensions>::iterate(
        localRange, [&](const id<Dimensions> &LocalID) {

          item<Dimensions, false> GlobalItem =
              detail::Builder::createItem<Dimensions, false>(
                  globalRange, GroupStartID + LocalID);
          item<Dimensions, false> LocalItem =
              detail::Builder::createItem<Dimensions, false>(localRange,
                                                             LocalID);
          h_item<Dimensions> HItem =
              detail::Builder::createHItem<Dimensions>(GlobalItem, LocalItem);
          Func(HItem);
        });





    detail::workGroupBarrier();
  }

  template <typename WorkItemFunctionT>
  void parallel_for_work_item(range<Dimensions> flexibleRange,
                              WorkItemFunctionT Func) const {
    detail::workGroupBarrier();
# 236 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 3
    id<Dimensions> GroupStartID = index * localRange;




    detail::NDLoop<Dimensions>::iterate(
        localRange, [&](const id<Dimensions> &LocalID) {

          item<Dimensions, false> GlobalItem =
              detail::Builder::createItem<Dimensions, false>(
                  globalRange, GroupStartID + LocalID);
          item<Dimensions, false> LocalItem =
              detail::Builder::createItem<Dimensions, false>(localRange,
                                                             LocalID);
          h_item<Dimensions> HItem = detail::Builder::createHItem<Dimensions>(
              GlobalItem, LocalItem, flexibleRange);

          detail::NDLoop<Dimensions>::iterate(
              LocalID, localRange, flexibleRange,
              [&](const id<Dimensions> &LogicalLocalID) {
                HItem.setLogicalLocalID(LogicalLocalID);
                Func(HItem);
              });
        });


    detail::workGroupBarrier();
  }



  template <access::mode accessMode = access::mode::read_write>
  void mem_fence(typename std::enable_if<
                     accessMode == access::mode::read ||
                     accessMode == access::mode::write ||
                     accessMode == access::mode::read_write,
                     access::fence_space>::type accessSpace =
                     access::fence_space::global_and_local) const {
    uint32_t flags = detail::getSPIRVMemorySemanticsMask(accessSpace);
# 283 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp" 3
    __spirv_MemoryBarrier(__spv::Scope::Workgroup, flags);
  }






  template <typename dataT>
  detail::enable_if_t<!detail::is_bool<dataT>::value, device_event>
  async_work_group_copy(local_ptr<dataT> dest, global_ptr<dataT> src,
                        size_t numElements, size_t srcStride) const {
    using DestT = detail::ConvertToOpenCLType_t<decltype(dest)>;
    using SrcT = detail::ConvertToOpenCLType_t<decltype(src)>;

    __ocl_event_t E = OpGroupAsyncCopyGlobalToLocal(
        __spv::Scope::Workgroup, DestT(dest.get()), SrcT(src.get()),
        numElements, srcStride, 0);
    return device_event(&E);
  }






  template <typename dataT>
  detail::enable_if_t<!detail::is_bool<dataT>::value, device_event>
  async_work_group_copy(global_ptr<dataT> dest, local_ptr<dataT> src,
                        size_t numElements, size_t destStride) const {
    using DestT = detail::ConvertToOpenCLType_t<decltype(dest)>;
    using SrcT = detail::ConvertToOpenCLType_t<decltype(src)>;

    __ocl_event_t E = OpGroupAsyncCopyLocalToGlobal(
        __spv::Scope::Workgroup, DestT(dest.get()), SrcT(src.get()),
        numElements, destStride, 0);
    return device_event(&E);
  }






  template <typename T, access::address_space DestS, access::address_space SrcS>
  detail::enable_if_t<detail::is_scalar_bool<T>::value, device_event>
  async_work_group_copy(multi_ptr<T, DestS> Dest, multi_ptr<T, SrcS> Src,
                        size_t NumElements, size_t Stride) const {
    static_assert(sizeof(bool) == sizeof(uint8_t),
                  "Async copy to/from bool memory is not supported.");
    auto DestP =
        multi_ptr<uint8_t, DestS>(reinterpret_cast<uint8_t *>(Dest.get()));
    auto SrcP =
        multi_ptr<uint8_t, SrcS>(reinterpret_cast<uint8_t *>(Src.get()));
    return async_work_group_copy(DestP, SrcP, NumElements, Stride);
  }






  template <typename T, access::address_space DestS, access::address_space SrcS>
  detail::enable_if_t<detail::is_vector_bool<T>::value, device_event>
  async_work_group_copy(multi_ptr<T, DestS> Dest, multi_ptr<T, SrcS> Src,
                        size_t NumElements, size_t Stride) const {
    static_assert(sizeof(bool) == sizeof(uint8_t),
                  "Async copy to/from bool memory is not supported.");
    using VecT = detail::change_base_type_t<T, uint8_t>;
    auto DestP = multi_ptr<VecT, DestS>(reinterpret_cast<VecT *>(Dest.get()));
    auto SrcP = multi_ptr<VecT, SrcS>(reinterpret_cast<VecT *>(Src.get()));
    return async_work_group_copy(DestP, SrcP, NumElements, Stride);
  }






  template <typename dataT>
  device_event async_work_group_copy(local_ptr<dataT> dest,
                                     global_ptr<dataT> src,
                                     size_t numElements) const {
    return async_work_group_copy(dest, src, numElements, 1);
  }






  template <typename dataT>
  device_event async_work_group_copy(global_ptr<dataT> dest,
                                     local_ptr<dataT> src,
                                     size_t numElements) const {
    return async_work_group_copy(dest, src, numElements, 1);
  }

  template <typename... eventTN>
  void wait_for(eventTN... Events) const {
    waitForHelper(Events...);
  }

  bool operator==(const group<Dimensions> &rhs) const {
    bool Result = (rhs.globalRange == globalRange) &&
                  (rhs.localRange == localRange) && (rhs.index == index);
    (static_cast <bool> (rhs.groupRange == groupRange && "inconsistent group class fields") ? void (0) : __assert_fail ("rhs.groupRange == groupRange && \"inconsistent group class fields\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp", 390, __extension__ __PRETTY_FUNCTION__));

    return Result;
  }

  bool operator!=(const group<Dimensions> &rhs) const {
    return !((*this) == rhs);
  }

private:
  range<Dimensions> globalRange;
  range<Dimensions> localRange;
  range<Dimensions> groupRange;
  id<Dimensions> index;

  void waitForHelper() const {}

  void waitForHelper(device_event Event) const {
    Event.wait();
  }

  template <typename T, typename... Ts>
  void waitForHelper(T E, Ts... Es) const {
    waitForHelper(E);
    waitForHelper(Es...);
  }

protected:
  friend class detail::Builder;
  group(const range<Dimensions> &G, const range<Dimensions> &L,
        const range<Dimensions> GroupRange, const id<Dimensions> &I)
      : globalRange(G), localRange(L), groupRange(GroupRange), index(I) {

    (static_cast <bool> (((G % L).size() == 0) && "global range is not multiple of local") ? void (0) : __assert_fail ("((G % L).size() == 0) && \"global range is not multiple of local\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp", 423, __extension__ __PRETTY_FUNCTION__));

    (static_cast <bool> ((((G / L) - GroupRange).size() == 0) && "inconsistent group constructor arguments") ? void (0) : __assert_fail ("(((G / L) - GroupRange).size() == 0) && \"inconsistent group constructor arguments\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/group.hpp", 425, __extension__ __PRETTY_FUNCTION__));

  }
};

}
}
# 19 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/nd_item.hpp" 1 3
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/nd_item.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/nd_range.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/nd_range.hpp" 3
inline namespace cl {
namespace sycl {





template <int dimensions = 1> class nd_range {
  range<dimensions> globalSize;
  range<dimensions> localSize;
  id<dimensions> offset;
  static_assert(dimensions >= 1 && dimensions <= 3,
                "nd_range can only be 1, 2, or 3 dimensional.");

public:
  nd_range(range<dimensions> globalSize, range<dimensions> localSize,
           id<dimensions> offset = id<dimensions>())
      : globalSize(globalSize), localSize(localSize), offset(offset) {}

  range<dimensions> get_global_range() const { return globalSize; }

  range<dimensions> get_local_range() const { return localSize; }

  range<dimensions> get_group_range() const { return globalSize / localSize; }

  id<dimensions> get_offset() const { return offset; }


  nd_range(const nd_range<dimensions> &rhs) = default;
  nd_range(nd_range<dimensions> &&rhs) = default;
  nd_range<dimensions> &operator=(const nd_range<dimensions> &rhs) = default;
  nd_range<dimensions> &operator=(nd_range<dimensions> &&rhs) = default;
  nd_range() = default;


  bool operator==(const nd_range<dimensions> &rhs) const {
    return (rhs.globalSize == this->globalSize) &&
           (rhs.localSize == this->localSize) && (rhs.offset == this->offset);
  }

  bool operator!=(const nd_range<dimensions> &rhs) const {
    return !(*this == rhs);
  }
};

}
}
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/nd_item.hpp" 2 3






inline namespace cl {
namespace sycl {
namespace detail {
class Builder;
}





template <int dimensions = 1> class nd_item {
public:
  nd_item() = delete;

  id<dimensions> get_global_id() const { return globalItem.get_id(); }

  size_t __attribute__((always_inline)) get_global_id(int dimension) const {
    size_t Id = globalItem.get_id(dimension);
                         ;
    return Id;
  }

  size_t __attribute__((always_inline)) get_global_linear_id() const {
    size_t Id = globalItem.get_linear_id();
                         ;
    return Id;
  }

  id<dimensions> get_local_id() const { return localItem.get_id(); }

  size_t __attribute__((always_inline)) get_local_id(int dimension) const {
    size_t Id = localItem.get_id(dimension);
                         ;
    return Id;
  }

  size_t get_local_linear_id() const {
    size_t Id = localItem.get_linear_id();
                         ;
    return Id;
  }

  group<dimensions> get_group() const { return Group; }

  ONEAPI::sub_group get_sub_group() const { return ONEAPI::sub_group(); }

  size_t __attribute__((always_inline)) get_group(int dimension) const {
    size_t Size = Group[dimension];
                           ;
    return Size;
  }

  size_t __attribute__((always_inline)) get_group_linear_id() const {
    size_t Id = Group.get_linear_id();
                         ;
    return Id;
  }

  range<dimensions> get_group_range() const {
    return Group.get_global_range() / Group.get_local_range();
  }

  size_t __attribute__((always_inline)) get_group_range(int dimension) const {
    size_t Range =
        Group.get_global_range(dimension) / Group.get_local_range(dimension);
                            ;
    return Range;
  }

  range<dimensions> get_global_range() const { return globalItem.get_range(); }

  size_t get_global_range(int dimension) const {
    return globalItem.get_range(dimension);
  }

  range<dimensions> get_local_range() const { return localItem.get_range(); }

  size_t get_local_range(int dimension) const {
    return localItem.get_range(dimension);
  }

  id<dimensions> get_offset() const { return globalItem.get_offset(); }

  nd_range<dimensions> get_nd_range() const {
    return nd_range<dimensions>(get_global_range(), get_local_range(),
                                get_offset());
  }

  void barrier(access::fence_space accessSpace =
                   access::fence_space::global_and_local) const {
# 125 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/nd_item.hpp" 3
    (void)accessSpace;
    std::cerr << "Barrier is not supported on host device.\n";
    abort();


  }



  template <access::mode accessMode = access::mode::read_write>
  void
  mem_fence(typename std::enable_if<accessMode == access::mode::read ||
                                        accessMode == access::mode::write ||
                                        accessMode == access::mode::read_write,
                                    access::fence_space>::type accessSpace =
                access::fence_space::global_and_local) const {
    (void)accessSpace;
    Group.mem_fence();
  }

  template <typename dataT>
  device_event async_work_group_copy(local_ptr<dataT> dest,
                                     global_ptr<dataT> src,
                                     size_t numElements) const {
    return Group.async_work_group_copy(dest, src, numElements);
  }

  template <typename dataT>
  device_event async_work_group_copy(global_ptr<dataT> dest,
                                     local_ptr<dataT> src,
                                     size_t numElements) const {
    return Group.async_work_group_copy(dest, src, numElements);
  }

  template <typename dataT>
  device_event async_work_group_copy(local_ptr<dataT> dest,
                                     global_ptr<dataT> src, size_t numElements,
                                     size_t srcStride) const {

    return Group.async_work_group_copy(dest, src, numElements, srcStride);
  }

  template <typename dataT>
  device_event async_work_group_copy(global_ptr<dataT> dest,
                                     local_ptr<dataT> src, size_t numElements,
                                     size_t destStride) const {
    return Group.async_work_group_copy(dest, src, numElements, destStride);
  }

  template <typename... eventTN> void wait_for(eventTN... events) const {
    Group.wait_for(events...);
  }

  nd_item<dimensions>(const nd_item<dimensions> &rhs) = default;

  nd_item<dimensions>(nd_item<dimensions> &&rhs) = default;

  nd_item<dimensions> &operator=(const nd_item<dimensions> &rhs) = default;

  nd_item<dimensions> &operator=(nd_item<dimensions> &&rhs) = default;

  bool operator==(const nd_item<dimensions> &rhs) const {
    return (rhs.localItem == this->localItem) &&
           (rhs.globalItem == this->globalItem) && (rhs.Group == this->Group);
  }

  bool operator!=(const nd_item<dimensions> &rhs) const {
    return !((*this) == rhs);
  }

protected:
  friend class detail::Builder;
  nd_item(const item<dimensions, true> &GL, const item<dimensions, false> &L,
          const group<dimensions> &GR)
      : globalItem(GL), localItem(L), Group(GR) {}

private:
  item<dimensions, true> globalItem;
  item<dimensions, false> localItem;
  group<dimensions> Group;
};
}
}
# 20 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 2 3


inline namespace cl {
namespace sycl {
namespace detail {

template <typename Group> size_t get_local_linear_range(Group g);
template <> inline size_t get_local_linear_range<group<1>>(group<1> g) {
  return g.get_local_range(0);
}
template <> inline size_t get_local_linear_range<group<2>>(group<2> g) {
  return g.get_local_range(0) * g.get_local_range(1);
}
template <> inline size_t get_local_linear_range<group<3>>(group<3> g) {
  return g.get_local_range(0) * g.get_local_range(1) * g.get_local_range(2);
}
template <>
inline size_t get_local_linear_range<ONEAPI::sub_group>(ONEAPI::sub_group g) {
  return g.get_local_range()[0];
}

template <typename Group>
typename Group::linear_id_type get_local_linear_id(Group g);
# 57 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
template <>
inline ONEAPI::sub_group::linear_id_type
get_local_linear_id<ONEAPI::sub_group>(ONEAPI::sub_group g) {
  return g.get_local_id()[0];
}

template <int Dimensions>
id<Dimensions> linear_id_to_id(range<Dimensions>, size_t linear_id);
template <> inline id<1> linear_id_to_id(range<1>, size_t linear_id) {
  return id<1>(linear_id);
}
template <> inline id<2> linear_id_to_id(range<2> r, size_t linear_id) {
  id<2> result;
  result[0] = linear_id / r[1];
  result[1] = linear_id % r[1];
  return result;
}
template <> inline id<3> linear_id_to_id(range<3> r, size_t linear_id) {
  id<3> result;
  result[0] = linear_id / (r[1] * r[2]);
  result[1] = (linear_id % (r[1] * r[2])) / r[2];
  result[2] = linear_id % r[2];
  return result;
}

template <typename T, class BinaryOperation> struct identity {};

template <typename T, typename V> struct identity<T, ONEAPI::plus<V>> {
  static constexpr T value = 0;
};

template <typename T, typename V> struct identity<T, ONEAPI::minimum<V>> {
  static constexpr T value = std::numeric_limits<T>::has_infinity
                                 ? std::numeric_limits<T>::infinity()
                                 : (std::numeric_limits<T>::max)();
};

template <typename T, typename V> struct identity<T, ONEAPI::maximum<V>> {
  static constexpr T value =
      std::numeric_limits<T>::has_infinity
          ? static_cast<T>(-std::numeric_limits<T>::infinity())
          : std::numeric_limits<T>::lowest();
};

template <typename T, typename V> struct identity<T, ONEAPI::multiplies<V>> {
  static constexpr T value = static_cast<T>(1);
};

template <typename T, typename V> struct identity<T, ONEAPI::bit_or<V>> {
  static constexpr T value = 0;
};

template <typename T, typename V> struct identity<T, ONEAPI::bit_xor<V>> {
  static constexpr T value = 0;
};

template <typename T, typename V> struct identity<T, ONEAPI::bit_and<V>> {
  static constexpr T value = ~static_cast<T>(0);
};

template <typename T>
using native_op_list =
    type_list<ONEAPI::plus<T>, ONEAPI::bit_or<T>, ONEAPI::bit_xor<T>,
              ONEAPI::bit_and<T>, ONEAPI::maximum<T>, ONEAPI::minimum<T>,
              ONEAPI::multiplies<T>>;

template <typename T, typename BinaryOperation> struct is_native_op {
  static constexpr bool value =
      is_contained<BinaryOperation, native_op_list<T>>::value ||
      is_contained<BinaryOperation, native_op_list<void>>::value;
};

template <typename Group, typename Ptr, class Function>
Function for_each(Group g, Ptr first, Ptr last, Function f) {
# 139 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  (void)first;
  (void)last;
  (void)f;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

}

namespace ONEAPI {


template <typename T>
using EnableIfIsScalarArithmetic = cl::sycl::detail::enable_if_t<
    cl::sycl::detail::is_scalar_arithmetic<T>::value, T>;

template <typename T>
using EnableIfIsVectorArithmetic = cl::sycl::detail::enable_if_t<
    cl::sycl::detail::is_vector_arithmetic<T>::value, T>;

template <typename Ptr, typename T>
using EnableIfIsPointer =
    cl::sycl::detail::enable_if_t<cl::sycl::detail::is_pointer<Ptr>::value, T>;

template <typename T>
using EnableIfIsTriviallyCopyable = cl::sycl::detail::enable_if_t<
    std::is_trivially_copyable<T>::value &&
        !cl::sycl::detail::is_vector_arithmetic<T>::value,
    T>;


template <typename T, typename BinaryOperation>
using EnableIfIsScalarArithmeticNativeOp = cl::sycl::detail::enable_if_t<
    cl::sycl::detail::is_scalar_arithmetic<T>::value &&
        cl::sycl::detail::is_native_op<T, BinaryOperation>::value,
    T>;

template <typename T, typename BinaryOperation>
using EnableIfIsVectorArithmeticNativeOp = cl::sycl::detail::enable_if_t<
    cl::sycl::detail::is_vector_arithmetic<T>::value &&
        cl::sycl::detail::is_native_op<T, BinaryOperation>::value,
    T>;


template <typename T, typename BinaryOperation>
using EnableIfIsNonNativeOp = cl::sycl::detail::enable_if_t<
    (!cl::sycl::detail::is_scalar_arithmetic<T>::value &&
     !cl::sycl::detail::is_vector_arithmetic<T>::value &&
     std::is_trivially_copyable<T>::value) ||
        !cl::sycl::detail::is_native_op<T, BinaryOperation>::value,
    T>;

template <typename Group> bool all_of(Group, bool pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");



  (void)pred;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class Predicate>
bool all_of(Group g, T x, Predicate pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");
  return all_of(g, pred(x));
}

template <typename Group, typename Ptr, class Predicate>
EnableIfIsPointer<Ptr, bool> all_of(Group g, Ptr first, Ptr last,
                                    Predicate pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");







  (void)g;
  (void)first;
  (void)last;
  (void)pred;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group> bool any_of(Group, bool pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");



  (void)pred;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class Predicate>
bool any_of(Group g, T x, Predicate pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");
  return any_of(g, pred(x));
}

template <typename Group, typename Ptr, class Predicate>
EnableIfIsPointer<Ptr, bool> any_of(Group g, Ptr first, Ptr last,
                                    Predicate pred) {
# 270 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  (void)first;
  (void)last;
  (void)pred;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group> bool none_of(Group, bool pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");



  (void)pred;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class Predicate>
bool none_of(Group g, T x, Predicate pred) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");
  return none_of(g, pred(x));
}

template <typename Group, typename Ptr, class Predicate>
EnableIfIsPointer<Ptr, bool> none_of(Group g, Ptr first, Ptr last,
                                     Predicate pred) {






  (void)g;
  (void)first;
  (void)last;
  (void)pred;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T>
EnableIfIsTriviallyCopyable<T> broadcast(Group, T x,
                                         typename Group::id_type local_id) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");



  (void)x;
  (void)local_id;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T>
EnableIfIsVectorArithmetic<T> broadcast(Group g, T x,
                                        typename Group::id_type local_id) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");







  (void)g;
  (void)x;
  (void)local_id;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T>
EnableIfIsTriviallyCopyable<T>
broadcast(Group g, T x, typename Group::linear_id_type linear_local_id) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");





  (void)g;
  (void)x;
  (void)linear_local_id;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T>
EnableIfIsVectorArithmetic<T>
broadcast(Group g, T x, typename Group::linear_id_type linear_local_id) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");







  (void)g;
  (void)x;
  (void)linear_local_id;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T>
EnableIfIsTriviallyCopyable<T> broadcast(Group g, T x) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");



  (void)g;
  (void)x;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T>
EnableIfIsVectorArithmetic<T> broadcast(Group g, T x) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");







  (void)g;
  (void)x;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsScalarArithmeticNativeOp<T, BinaryOperation>
reduce(Group, T x, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(x, x)), T>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(x, x)), float>::value),
      "Result type of binary_op must match reduction accumulation type.");





  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsVectorArithmeticNativeOp<T, BinaryOperation>
reduce(Group g, T x, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(x[0], x[0])),
                   typename T::element_type>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(x[0], x[0])), float>::value),
      "Result type of binary_op must match reduction accumulation type.");
  T result;
  for (int s = 0; s < x.get_size(); ++s) {
    result[s] = reduce(g, x[s], binary_op);
  }
  return result;
}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsNonNativeOp<T, BinaryOperation> reduce(Group g, T x,
                                                 BinaryOperation op) {
  static_assert(sycl::detail::is_sub_group<Group>::value,
                "reduce algorithm with user-defined types and operators"
                "only supports ONEAPI::sub_group class.");
  T result = x;
  for (int mask = 1; mask < g.get_max_local_range()[0]; mask *= 2) {
    T tmp = g.shuffle_xor(result, id<1>(mask));
    if ((g.get_local_id()[0] ^ mask) < g.get_local_range()[0]) {
      result = op(result, tmp);
    }
  }
  return g.shuffle(result, 0);
}

template <typename Group, typename V, typename T, class BinaryOperation>
EnableIfIsScalarArithmeticNativeOp<T, BinaryOperation>
reduce(Group g, V x, T init, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(init, x)), T>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(init, x)), float>::value),
      "Result type of binary_op must match reduction accumulation type.");



  (void)g;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename V, typename T, class BinaryOperation>
EnableIfIsVectorArithmeticNativeOp<T, BinaryOperation>
reduce(Group g, V x, T init, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(init[0], x[0])),
                   typename T::element_type>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(init[0], x[0])), float>::value),
      "Result type of binary_op must match reduction accumulation type.");







  (void)g;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename V, typename T, class BinaryOperation>
EnableIfIsNonNativeOp<T, BinaryOperation> reduce(Group g, V x, T init,
                                                 BinaryOperation op) {
  static_assert(sycl::detail::is_sub_group<Group>::value,
                "reduce algorithm with user-defined types and operators"
                "only supports ONEAPI::sub_group class.");
  T result = x;
  for (int mask = 1; mask < g.get_max_local_range()[0]; mask *= 2) {
    T tmp = g.shuffle_xor(result, id<1>(mask));
    if ((g.get_local_id()[0] ^ mask) < g.get_local_range()[0]) {
      result = op(result, tmp);
    }
  }
  return g.shuffle(op(init, result), 0);
}

template <typename Group, typename Ptr, class BinaryOperation>
EnableIfIsPointer<Ptr, typename Ptr::element_type>
reduce(Group g, Ptr first, Ptr last, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(*first, *first)),
                   typename Ptr::element_type>::value ||
          (std::is_same<typename Ptr::element_type, half>::value &&
           std::is_same<decltype(binary_op(*first, *first)), float>::value),
      "Result type of binary_op must match reduction accumulation type.");
# 573 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  (void)last;
  (void)binary_op;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename Ptr, typename T, class BinaryOperation>
EnableIfIsPointer<Ptr, T> reduce(Group g, Ptr first, Ptr last, T init,
                                 BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(init, *first)), T>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(init, *first)), float>::value),
      "Result type of binary_op must match reduction accumulation type.");
# 602 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  (void)last;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsScalarArithmeticNativeOp<T, BinaryOperation>
exclusive_scan(Group, T x, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(std::is_same<decltype(binary_op(x, x)), T>::value ||
                    (std::is_same<T, half>::value &&
                     std::is_same<decltype(binary_op(x, x)), float>::value),
                "Result type of binary_op must match scan accumulation type.");





  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsVectorArithmeticNativeOp<T, BinaryOperation>
exclusive_scan(Group g, T x, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(x[0], x[0])),
                   typename T::element_type>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(x[0], x[0])), float>::value),
      "Result type of binary_op must match scan accumulation type.");
  T result;
  for (int s = 0; s < x.get_size(); ++s) {
    result[s] = exclusive_scan(g, x[s], binary_op);
  }
  return result;
}

template <typename Group, typename V, typename T, class BinaryOperation>
EnableIfIsVectorArithmeticNativeOp<T, BinaryOperation>
exclusive_scan(Group g, V x, T init, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(init[0], x[0])),
                   typename T::element_type>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(init[0], x[0])), float>::value),
      "Result type of binary_op must match scan accumulation type.");
  T result;
  for (int s = 0; s < x.get_size(); ++s) {
    result[s] = exclusive_scan(g, x[s], init[s], binary_op);
  }
  return result;
}

template <typename Group, typename V, typename T, class BinaryOperation>
EnableIfIsScalarArithmeticNativeOp<T, BinaryOperation>
exclusive_scan(Group g, V x, T init, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(std::is_same<decltype(binary_op(init, x)), T>::value ||
                    (std::is_same<T, half>::value &&
                     std::is_same<decltype(binary_op(init, x)), float>::value),
                "Result type of binary_op must match scan accumulation type.");
# 693 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename InPtr, typename OutPtr, typename T,
          class BinaryOperation>
EnableIfIsPointer<InPtr, OutPtr>
exclusive_scan(Group g, InPtr first, InPtr last, OutPtr result, T init,
               BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(*first, *first)), T>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(*first, *first)), float>::value),
      "Result type of binary_op must match scan accumulation type.");
# 736 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  (void)last;
  (void)result;
  (void)init;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename InPtr, typename OutPtr,
          class BinaryOperation>
EnableIfIsPointer<InPtr, OutPtr> exclusive_scan(Group g, InPtr first,
                                                InPtr last, OutPtr result,
                                                BinaryOperation binary_op) {

  static_assert(
      std::is_same<decltype(binary_op(*first, *first)),
                   typename OutPtr::element_type>::value ||
          (std::is_same<typename OutPtr::element_type, half>::value &&
           std::is_same<decltype(binary_op(*first, *first)), float>::value),
      "Result type of binary_op must match scan accumulation type.");
  return exclusive_scan(g, first, last, result,
                        sycl::detail::identity<typename OutPtr::element_type,
                                               BinaryOperation>::value,
                        binary_op);
}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsVectorArithmeticNativeOp<T, BinaryOperation>
inclusive_scan(Group g, T x, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(x[0], x[0])),
                   typename T::element_type>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(x[0], x[0])), float>::value),
      "Result type of binary_op must match scan accumulation type.");
  T result;
  for (int s = 0; s < x.get_size(); ++s) {
    result[s] = inclusive_scan(g, x[s], binary_op);
  }
  return result;
}

template <typename Group, typename T, class BinaryOperation>
EnableIfIsScalarArithmeticNativeOp<T, BinaryOperation>
inclusive_scan(Group, T x, BinaryOperation binary_op) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(std::is_same<decltype(binary_op(x, x)), T>::value ||
                    (std::is_same<T, half>::value &&
                     std::is_same<decltype(binary_op(x, x)), float>::value),
                "Result type of binary_op must match scan accumulation type.");





  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename V, class BinaryOperation, typename T>
EnableIfIsScalarArithmeticNativeOp<T, BinaryOperation>
inclusive_scan(Group g, V x, BinaryOperation binary_op, T init) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(std::is_same<decltype(binary_op(init, x)), T>::value ||
                    (std::is_same<T, half>::value &&
                     std::is_same<decltype(binary_op(init, x)), float>::value),
                "Result type of binary_op must match scan accumulation type.");






  (void)g;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename V, class BinaryOperation, typename T>
EnableIfIsVectorArithmeticNativeOp<T, BinaryOperation>
inclusive_scan(Group g, V x, BinaryOperation binary_op, T init) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(init[0], x[0])), T>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(init[0], x[0])), float>::value),
      "Result type of binary_op must match scan accumulation type.");
  T result;
  for (int s = 0; s < x.get_size(); ++s) {
    result[s] = inclusive_scan(g, x[s], binary_op, init[s]);
  }
  return result;
}

template <typename Group, typename InPtr, typename OutPtr,
          class BinaryOperation, typename T>
EnableIfIsPointer<InPtr, OutPtr>
inclusive_scan(Group g, InPtr first, InPtr last, OutPtr result,
               BinaryOperation binary_op, T init) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");

  static_assert(
      std::is_same<decltype(binary_op(init, *first)), T>::value ||
          (std::is_same<T, half>::value &&
           std::is_same<decltype(binary_op(init, *first)), float>::value),
      "Result type of binary_op must match scan accumulation type.");
# 883 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/group_algorithm.hpp" 3
  (void)g;
  (void)last;
  (void)result;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

template <typename Group, typename InPtr, typename OutPtr,
          class BinaryOperation>
EnableIfIsPointer<InPtr, OutPtr> inclusive_scan(Group g, InPtr first,
                                                InPtr last, OutPtr result,
                                                BinaryOperation binary_op) {

  static_assert(
      std::is_same<decltype(binary_op(*first, *first)),
                   typename OutPtr::element_type>::value ||
          (std::is_same<typename OutPtr::element_type, half>::value &&
           std::is_same<decltype(binary_op(*first, *first)), float>::value),
      "Result type of binary_op must match scan accumulation type.");
  return inclusive_scan(g, first, last, result, binary_op,
                        sycl::detail::identity<typename OutPtr::element_type,
                                               BinaryOperation>::value);
}

template <typename Group> bool leader(Group g) {
  static_assert(sycl::detail::is_generic_group<Group>::value,
                "Group algorithms only support the sycl::group and "
                "ONEAPI::sub_group class.");





  (void)g;
  throw runtime_error("Group algorithms are not supported on host device.",
                      PI_INVALID_DEVICE);

}

}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg_types.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg_types.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/host_profiling_info.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/host_profiling_info.hpp" 3
inline namespace cl {
namespace sycl {
namespace detail {


class __attribute__((visibility("default"))) HostProfilingInfo {
  cl_ulong StartTime = 0;
  cl_ulong EndTime = 0;

public:



  cl_ulong getStartTime() const { return StartTime; }



  cl_ulong getEndTime() const { return EndTime; }


  void start();

  void end();
};
}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg_types.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/interop_handle.hpp" 1 3
# 21 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/interop_handle.hpp" 3
inline namespace cl {
namespace sycl {

namespace detail {
class AccessorBaseHost;
class ExecCGCommand;
class DispatchHostTask;
class queue_impl;
class device_impl;
class context_impl;
}

class queue;
class device;
class context;

class interop_handle {
public:






  template <backend BackendName = backend::opencl, typename DataT, int Dims,
            access::mode Mode, access::target Target, access::placeholder IsPlh>
  typename std::enable_if<
      Target == access::target::global_buffer ||
          Target == access::target::constant_buffer,
      typename interop<BackendName,
                       accessor<DataT, Dims, Mode, Target, IsPlh>>::type>::type
  get_native_mem(const accessor<DataT, Dims, Mode, Target, IsPlh> &Acc) const {

    const auto *AccBase = static_cast<const detail::AccessorBaseHost *>(&Acc);
    return getMemImpl<BackendName, DataT, Dims, Mode, Target, IsPlh>(
        detail::getSyclObjImpl(*AccBase).get());





  }

  template <backend BackendName = backend::opencl, typename DataT, int Dims,
            access::mode Mode, access::target Target, access::placeholder IsPlh>
  typename std::enable_if<
      !(Target == access::target::global_buffer ||
        Target == access::target::constant_buffer),
      typename interop<BackendName, accessor<DataT, Dims, Mode,
                                             access::target::global_buffer,
                                             IsPlh>>::type>::type
  get_native_mem(const accessor<DataT, Dims, Mode, Target, IsPlh> &) const {
    throw invalid_object_error("Getting memory object out of accessor for "
                               "specified target is not allowed",
                               PI_INVALID_MEM_OBJECT);
  }
# 87 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/interop_handle.hpp" 3
  template <backend BackendName = backend::opencl>
  auto get_native_queue() const noexcept ->
      typename interop<BackendName, queue>::type {

    return reinterpret_cast<typename interop<BackendName, queue>::type>(
        getNativeQueue());




  }




  template <backend BackendName = backend::opencl>
  auto get_native_device() const noexcept ->
      typename interop<BackendName, device>::type {

    return reinterpret_cast<typename interop<BackendName, device>::type>(
        getNativeDevice());




  }




  template <backend BackendName = backend::opencl>
  auto get_native_context() const noexcept ->
      typename interop<BackendName, context>::type {

    return reinterpret_cast<typename interop<BackendName, context>::type>(
        getNativeContext());




  }

private:
  friend class detail::ExecCGCommand;
  friend class detail::DispatchHostTask;
  using ReqToMem = std::pair<detail::Requirement *, pi_mem>;


  interop_handle(std::vector<ReqToMem> MemObjs,
                 const std::shared_ptr<detail::queue_impl> &Queue,
                 const std::shared_ptr<detail::device_impl> &Device,
                 const std::shared_ptr<detail::context_impl> &Context)
      : MQueue(Queue), MDevice(Device), MContext(Context),
        MMemObjs(std::move(MemObjs)) {}

private:
  template <backend BackendName, typename DataT, int Dims, access::mode Mode,
            access::target Target, access::placeholder IsPlh>
  auto getMemImpl(detail::Requirement *Req) const ->
      typename interop<BackendName,
                       accessor<DataT, Dims, Mode, Target, IsPlh>>::type {
# 166 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/interop_handle.hpp" 3
    return (typename interop<BackendName,
                             accessor<DataT, Dims, Mode, Target, IsPlh>>::type)(
        getNativeMem(Req));
  }

  __attribute__((visibility("default"))) pi_native_handle getNativeMem(detail::Requirement *Req) const;
  __attribute__((visibility("default"))) pi_native_handle getNativeQueue() const;
  __attribute__((visibility("default"))) pi_native_handle getNativeDevice() const;
  __attribute__((visibility("default"))) pi_native_handle getNativeContext() const;

  std::shared_ptr<detail::queue_impl> MQueue;
  std::shared_ptr<detail::device_impl> MDevice;
  std::shared_ptr<detail::context_impl> MContext;

  std::vector<ReqToMem> MMemObjs;
};

}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg_types.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/interop_handler.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/interop_handler.hpp" 3
inline namespace cl {
namespace sycl {



class interop_handler {

  template <typename DataT, int Dims, access::mode AccMode,
            access::target AccTarget, access::placeholder isPlaceholder,
            typename PropertyListT>
  friend class accessor;

public:
  using QueueImplPtr = std::shared_ptr<detail::queue_impl>;
  using ReqToMem = std::pair<detail::Requirement *, pi_mem>;

  interop_handler(std::vector<ReqToMem> MemObjs, QueueImplPtr Queue)
      : MQueue(std::move(Queue)), MMemObjs(std::move(MemObjs)) {}

  template <backend BackendName = backend::opencl>
  auto get_queue() const -> typename interop<BackendName, queue>::type {
    return reinterpret_cast<typename interop<BackendName, queue>::type>(
        GetNativeQueue());
  }

  template <backend BackendName = backend::opencl, typename DataT, int Dims,
            access::mode AccessMode, access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t>
  auto get_mem(accessor<DataT, Dims, AccessMode, AccessTarget,
                        access::placeholder::false_t>
                   Acc) const ->
      typename interop<BackendName,
                       accessor<DataT, Dims, AccessMode, AccessTarget,
                                access::placeholder::false_t>>::type {
    detail::AccessorBaseHost *AccBase = (detail::AccessorBaseHost *)&Acc;
    return getMemImpl<BackendName, DataT, Dims, AccessMode, AccessTarget,
                      access::placeholder::false_t>(
        detail::getSyclObjImpl(*AccBase).get());
  }

private:
  QueueImplPtr MQueue;
  std::vector<ReqToMem> MMemObjs;

  template <backend BackendName, typename DataT, int Dims,
            access::mode AccessMode, access::target AccessTarget,
            access::placeholder IsPlaceholder>
  auto getMemImpl(detail::Requirement *Req) const -> typename interop<
      BackendName,
      accessor<DataT, Dims, AccessMode, AccessTarget, IsPlaceholder>>::type {
    return (typename interop<BackendName,
                             accessor<DataT, Dims, AccessMode, AccessTarget,
                                      IsPlaceholder>>::type)GetNativeMem(Req);
  }

  __attribute__((visibility("default"))) pi_native_handle GetNativeMem(detail::Requirement *Req) const;
  __attribute__((visibility("default"))) pi_native_handle GetNativeQueue() const;
};

}
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg_types.hpp" 2 3




inline namespace cl {
namespace sycl {
namespace detail {


class ArgDesc {
public:
  ArgDesc(cl::sycl::detail::kernel_param_kind_t Type, void *Ptr, int Size,
          int Index)
      : MType(Type), MPtr(Ptr), MSize(Size), MIndex(Index) {}

  cl::sycl::detail::kernel_param_kind_t MType;
  void *MPtr;
  int MSize;
  int MIndex;
};



class NDRDescT {


  void setNDRangeLeftover(int Dims_) {
    for (int I = Dims_; I < 3; ++I) {
      GlobalSize[I] = 1;
      LocalSize[I] = LocalSize[0] ? 1 : 0;
      GlobalOffset[I] = 0;
      NumWorkGroups[I] = 0;
    }
  }

public:
  NDRDescT()
      : GlobalSize{0, 0, 0}, LocalSize{0, 0, 0}, NumWorkGroups{0, 0, 0} {}

  template <int Dims_> void set(sycl::range<Dims_> NumWorkItems) {
    for (int I = 0; I < Dims_; ++I) {
      GlobalSize[I] = NumWorkItems[I];
      LocalSize[I] = 0;
      GlobalOffset[I] = 0;
      NumWorkGroups[I] = 0;
    }
    setNDRangeLeftover(Dims_);
    Dims = Dims_;
  }



  template <int Dims_>
  void set(sycl::range<Dims_> NumWorkItems, sycl::id<Dims_> Offset) {
    for (int I = 0; I < Dims_; ++I) {
      GlobalSize[I] = NumWorkItems[I];
      LocalSize[I] = 0;
      GlobalOffset[I] = Offset[I];
      NumWorkGroups[I] = 0;
    }
    setNDRangeLeftover(Dims_);
    Dims = Dims_;
  }

  template <int Dims_> void set(sycl::nd_range<Dims_> ExecutionRange) {
    for (int I = 0; I < Dims_; ++I) {
      GlobalSize[I] = ExecutionRange.get_global_range()[I];
      LocalSize[I] = ExecutionRange.get_local_range()[I];
      GlobalOffset[I] = ExecutionRange.get_offset()[I];
      NumWorkGroups[I] = 0;
    }
    setNDRangeLeftover(Dims_);
    Dims = Dims_;
  }

  void set(int Dims_, sycl::nd_range<3> ExecutionRange) {
    for (int I = 0; I < Dims_; ++I) {
      GlobalSize[I] = ExecutionRange.get_global_range()[I];
      LocalSize[I] = ExecutionRange.get_local_range()[I];
      GlobalOffset[I] = ExecutionRange.get_offset()[I];
      NumWorkGroups[I] = 0;
    }
    setNDRangeLeftover(Dims_);
    Dims = Dims_;
  }

  template <int Dims_> void setNumWorkGroups(sycl::range<Dims_> N) {
    for (int I = 0; I < Dims_; ++I) {
      GlobalSize[I] = 0;

      LocalSize[I] = 0;
      GlobalOffset[I] = 0;
      NumWorkGroups[I] = N[I];
    }
    setNDRangeLeftover(Dims_);
    Dims = Dims_;
  }

  sycl::range<3> GlobalSize;
  sycl::range<3> LocalSize;
  sycl::id<3> GlobalOffset;



  sycl::range<3> NumWorkGroups;
  size_t Dims;
};


class HostKernelBase {
public:

  virtual void call(const NDRDescT &NDRDesc, HostProfilingInfo *HPI) = 0;


  virtual char *getPtr() = 0;
  virtual ~HostKernelBase() = default;
};

class InteropTask {
  std::function<void(cl::sycl::interop_handler)> MFunc;

public:
  InteropTask(function_class<void(cl::sycl::interop_handler)> Func)
      : MFunc(Func) {}
  void call(cl::sycl::interop_handler &h) { MFunc(h); }
};

class HostTask {
  std::function<void()> MHostTask;
  std::function<void(interop_handle)> MInteropTask;

public:
  HostTask() : MHostTask([]() {}) {}
  HostTask(std::function<void()> &&Func) : MHostTask(Func) {}
  HostTask(std::function<void(interop_handle)> &&Func) : MInteropTask(Func) {}

  bool isInteropTask() const { return !!MInteropTask; }

  void call() { MHostTask(); }
  void call(interop_handle handle) { MInteropTask(handle); }
};


template <class KernelType, class KernelArgType, int Dims>
class HostKernel : public HostKernelBase {
  using IDBuilder = sycl::detail::Builder;
  KernelType MKernel;

public:
  HostKernel(KernelType Kernel) : MKernel(Kernel) {}
  void call(const NDRDescT &NDRDesc, HostProfilingInfo *HPI) override {

    NDRDescT AdjustedRange = NDRDesc;

    if (NDRDesc.GlobalSize[0] == 0 && NDRDesc.NumWorkGroups[0] != 0) {






      range<3> WGsize{1, 1, 1};
      AdjustedRange.set(NDRDesc.Dims,
                        nd_range<3>(NDRDesc.NumWorkGroups * WGsize, WGsize));
    }


    if (AdjustedRange.LocalSize[0] == 0)
      for (size_t I = 0; I < AdjustedRange.Dims; ++I)
        AdjustedRange.LocalSize[I] = 1;
    if (HPI)
      HPI->start();
    runOnHost(AdjustedRange);
    if (HPI)
      HPI->end();
  }

  char *getPtr() override { return reinterpret_cast<char *>(&MKernel); }

  template <class ArgT = KernelArgType>
  typename std::enable_if<std::is_same<ArgT, void>::value>::type
  runOnHost(const NDRDescT &) {
    MKernel();
  }

  template <class ArgT = KernelArgType>
  typename std::enable_if<std::is_same<ArgT, sycl::id<Dims>>::value>::type
  runOnHost(const NDRDescT &NDRDesc) {
    sycl::range<Dims> Range(InitializedVal<Dims, range>::template get<0>());
    for (int I = 0; I < Dims; ++I)
      Range[I] = NDRDesc.GlobalSize[I];




    detail::NDLoop<Dims>::iterate(
        Range, [&](const sycl::id<Dims> &ID) { MKernel(ID); });

  }

  template <class ArgT = KernelArgType>
  typename std::enable_if<
      std::is_same<ArgT, item<Dims, false>>::value>::type
  runOnHost(const NDRDescT &NDRDesc) {
    sycl::id<Dims> ID;
    sycl::range<Dims> Range(InitializedVal<Dims, range>::template get<0>());
    for (int I = 0; I < Dims; ++I)
      Range[I] = NDRDesc.GlobalSize[I];




    detail::NDLoop<Dims>::iterate(Range, [&](const sycl::id<Dims> ID) {

      sycl::item<Dims, false> Item =
          IDBuilder::createItem<Dims, false>(Range, ID);
      MKernel(Item);
    });
  }

  template <class ArgT = KernelArgType>
  typename std::enable_if<
      std::is_same<ArgT, item<Dims, true>>::value>::type
  runOnHost(const NDRDescT &NDRDesc) {
    sycl::range<Dims> Range(InitializedVal<Dims, range>::template get<0>());
    sycl::id<Dims> Offset;
    for (int I = 0; I < Dims; ++I) {
      Range[I] = NDRDesc.GlobalSize[I];
      Offset[I] = NDRDesc.GlobalOffset[I];
    }




    detail::NDLoop<Dims>::iterate(Range, [&](const sycl::id<Dims> &ID) {

      sycl::id<Dims> OffsetID = ID + Offset;
      sycl::item<Dims, true> Item =
          IDBuilder::createItem<Dims, true>(Range, OffsetID, Offset);
      MKernel(Item);
    });
  }

  template <class ArgT = KernelArgType>
  typename std::enable_if<std::is_same<ArgT, nd_item<Dims>>::value>::type
  runOnHost(const NDRDescT &NDRDesc) {
    sycl::range<Dims> GroupSize(InitializedVal<Dims, range>::template get<0>());
    for (int I = 0; I < Dims; ++I) {
      if (NDRDesc.LocalSize[I] == 0 ||
          NDRDesc.GlobalSize[I] % NDRDesc.LocalSize[I] != 0)
        throw sycl::nd_range_error("Invalid local size for global size",
                                   PI_INVALID_WORK_GROUP_SIZE);
      GroupSize[I] = NDRDesc.GlobalSize[I] / NDRDesc.LocalSize[I];
    }

    sycl::range<Dims> LocalSize(InitializedVal<Dims, range>::template get<0>());
    sycl::range<Dims> GlobalSize(
        InitializedVal<Dims, range>::template get<0>());
    sycl::id<Dims> GlobalOffset;
    for (int I = 0; I < Dims; ++I) {
      GlobalOffset[I] = NDRDesc.GlobalOffset[I];
      LocalSize[I] = NDRDesc.LocalSize[I];
      GlobalSize[I] = NDRDesc.GlobalSize[I];
    }
# 290 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg_types.hpp" 3
    detail::NDLoop<Dims>::iterate(GroupSize, [&](const id<Dims> &GroupID) {
      sycl::group<Dims> Group = IDBuilder::createGroup<Dims>(
          GlobalSize, LocalSize, GroupSize, GroupID);

      detail::NDLoop<Dims>::iterate(LocalSize, [&](const id<Dims> &LocalID) {

        id<Dims> GlobalID = GroupID * LocalSize + LocalID + GlobalOffset;
        const sycl::item<Dims, true> GlobalItem =
            IDBuilder::createItem<Dims, true>(GlobalSize, GlobalID,
                                              GlobalOffset);
        const sycl::item<Dims, false> LocalItem =
            IDBuilder::createItem<Dims, false>(LocalSize, LocalID);
        const sycl::nd_item<Dims> NDItem =
            IDBuilder::createNDItem<Dims>(GlobalItem, LocalItem, Group);
        MKernel(NDItem);

      });

    });
  }

  template <typename ArgT = KernelArgType>
  enable_if_t<std::is_same<ArgT, cl::sycl::group<Dims>>::value>
  runOnHost(const NDRDescT &NDRDesc) {
    sycl::range<Dims> NGroups(InitializedVal<Dims, range>::template get<0>());

    for (int I = 0; I < Dims; ++I) {
      if (NDRDesc.LocalSize[I] == 0 ||
          NDRDesc.GlobalSize[I] % NDRDesc.LocalSize[I] != 0)
        throw sycl::nd_range_error("Invalid local size for global size",
                                   PI_INVALID_WORK_GROUP_SIZE);
      NGroups[I] = NDRDesc.GlobalSize[I] / NDRDesc.LocalSize[I];
    }

    sycl::range<Dims> LocalSize(InitializedVal<Dims, range>::template get<0>());
    sycl::range<Dims> GlobalSize(
        InitializedVal<Dims, range>::template get<0>());
    for (int I = 0; I < Dims; ++I) {
      LocalSize[I] = NDRDesc.LocalSize[I];
      GlobalSize[I] = NDRDesc.GlobalSize[I];
    }



    detail::NDLoop<Dims>::iterate(NGroups, [&](const id<Dims> &GroupID) {

      sycl::group<Dims> Group =
          IDBuilder::createGroup<Dims>(GlobalSize, LocalSize, NGroups, GroupID);
      MKernel(Group);
    });
  }

  ~HostKernel() = default;
};

}
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg.hpp" 2 3
# 35 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg.hpp" 3
inline namespace cl {
namespace sycl {


class queue;
namespace detail {
class queue_impl;
}

namespace detail {

class stream_impl;

class CG {
public:

  enum CGTYPE {
    NONE,
    KERNEL,
    COPY_ACC_TO_PTR,
    COPY_PTR_TO_ACC,
    COPY_ACC_TO_ACC,
    BARRIER,
    BARRIER_WAITLIST,
    FILL,
    UPDATE_HOST,
    RUN_ON_HOST_INTEL,
    COPY_USM,
    FILL_USM,
    PREFETCH_USM,
    CODEPLAY_INTEROP_TASK,
    CODEPLAY_HOST_TASK
  };

  CG(CGTYPE Type, vector_class<vector_class<char>> ArgsStorage,
     vector_class<detail::AccessorImplPtr> AccStorage,
     vector_class<shared_ptr_class<const void>> SharedPtrStorage,
     vector_class<Requirement *> Requirements,
     vector_class<detail::EventImplPtr> Events, detail::code_location loc = {})
      : MType(Type), MArgsStorage(std::move(ArgsStorage)),
        MAccStorage(std::move(AccStorage)),
        MSharedPtrStorage(std::move(SharedPtrStorage)),
        MRequirements(std::move(Requirements)), MEvents(std::move(Events)) {



    if (loc.functionName())
      MFunctionName = loc.functionName();
    if (loc.fileName())
      MFileName = loc.fileName();
    MLine = loc.lineNumber();
    MColumn = loc.columnNumber();
  }

  CG(CG &&CommandGroup) = default;

  CGTYPE getType() { return MType; }

  virtual ~CG() = default;

private:
  CGTYPE MType;



  vector_class<vector_class<char>> MArgsStorage;

  vector_class<detail::AccessorImplPtr> MAccStorage;

  vector_class<shared_ptr_class<const void>> MSharedPtrStorage;

public:


  vector_class<Requirement *> MRequirements;

  vector_class<detail::EventImplPtr> MEvents;



  string_class MFunctionName, MFileName;

  int32_t MLine, MColumn;
};


class CGExecKernel : public CG {
public:

  NDRDescT MNDRDesc;
  unique_ptr_class<HostKernelBase> MHostKernel;
  shared_ptr_class<detail::kernel_impl> MSyclKernel;
  vector_class<ArgDesc> MArgs;
  string_class MKernelName;
  detail::OSModuleHandle MOSModuleHandle;
  vector_class<shared_ptr_class<detail::stream_impl>> MStreams;

  CGExecKernel(NDRDescT NDRDesc, unique_ptr_class<HostKernelBase> HKernel,
               shared_ptr_class<detail::kernel_impl> SyclKernel,
               vector_class<vector_class<char>> ArgsStorage,
               vector_class<detail::AccessorImplPtr> AccStorage,
               vector_class<shared_ptr_class<const void>> SharedPtrStorage,
               vector_class<Requirement *> Requirements,
               vector_class<detail::EventImplPtr> Events,
               vector_class<ArgDesc> Args, string_class KernelName,
               detail::OSModuleHandle OSModuleHandle,
               vector_class<shared_ptr_class<detail::stream_impl>> Streams,
               CGTYPE Type, detail::code_location loc = {})
      : CG(Type, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MNDRDesc(std::move(NDRDesc)), MHostKernel(std::move(HKernel)),
        MSyclKernel(std::move(SyclKernel)), MArgs(std::move(Args)),
        MKernelName(std::move(KernelName)), MOSModuleHandle(OSModuleHandle),
        MStreams(std::move(Streams)) {
    (static_cast <bool> ((getType() == RUN_ON_HOST_INTEL || getType() == KERNEL) && "Wrong type of exec kernel CG.") ? void (0) : __assert_fail ("(getType() == RUN_ON_HOST_INTEL || getType() == KERNEL) && \"Wrong type of exec kernel CG.\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/detail/cg.hpp", 151, __extension__ __PRETTY_FUNCTION__));

  }

  vector_class<ArgDesc> getArguments() const { return MArgs; }
  string_class getKernelName() const { return MKernelName; }
  vector_class<shared_ptr_class<detail::stream_impl>> getStreams() const {
    return MStreams;
  }
};


class CGCopy : public CG {
  void *MSrc;
  void *MDst;

public:
  CGCopy(CGTYPE CopyType, void *Src, void *Dst,
         vector_class<vector_class<char>> ArgsStorage,
         vector_class<detail::AccessorImplPtr> AccStorage,
         vector_class<shared_ptr_class<const void>> SharedPtrStorage,
         vector_class<Requirement *> Requirements,
         vector_class<detail::EventImplPtr> Events,
         detail::code_location loc = {})
      : CG(CopyType, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MSrc(Src), MDst(Dst) {}
  void *getSrc() { return MSrc; }
  void *getDst() { return MDst; }
};


class CGFill : public CG {
public:
  vector_class<char> MPattern;
  Requirement *MPtr;

  CGFill(vector_class<char> Pattern, void *Ptr,
         vector_class<vector_class<char>> ArgsStorage,
         vector_class<detail::AccessorImplPtr> AccStorage,
         vector_class<shared_ptr_class<const void>> SharedPtrStorage,
         vector_class<Requirement *> Requirements,
         vector_class<detail::EventImplPtr> Events,
         detail::code_location loc = {})
      : CG(FILL, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MPattern(std::move(Pattern)), MPtr((Requirement *)Ptr) {}
  Requirement *getReqToFill() { return MPtr; }
};


class CGUpdateHost : public CG {
  Requirement *MPtr;

public:
  CGUpdateHost(void *Ptr, vector_class<vector_class<char>> ArgsStorage,
               vector_class<detail::AccessorImplPtr> AccStorage,
               vector_class<shared_ptr_class<const void>> SharedPtrStorage,
               vector_class<Requirement *> Requirements,
               vector_class<detail::EventImplPtr> Events,
               detail::code_location loc = {})
      : CG(UPDATE_HOST, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MPtr((Requirement *)Ptr) {}

  Requirement *getReqToUpdate() { return MPtr; }
};


class CGCopyUSM : public CG {
  void *MSrc;
  void *MDst;
  size_t MLength;

public:
  CGCopyUSM(void *Src, void *Dst, size_t Length,
            vector_class<vector_class<char>> ArgsStorage,
            vector_class<detail::AccessorImplPtr> AccStorage,
            vector_class<shared_ptr_class<const void>> SharedPtrStorage,
            vector_class<Requirement *> Requirements,
            vector_class<detail::EventImplPtr> Events,
            detail::code_location loc = {})
      : CG(COPY_USM, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MSrc(Src), MDst(Dst), MLength(Length) {}

  void *getSrc() { return MSrc; }
  void *getDst() { return MDst; }
  size_t getLength() { return MLength; }
};


class CGFillUSM : public CG {
  vector_class<char> MPattern;
  void *MDst;
  size_t MLength;

public:
  CGFillUSM(vector_class<char> Pattern, void *DstPtr, size_t Length,
            vector_class<vector_class<char>> ArgsStorage,
            vector_class<detail::AccessorImplPtr> AccStorage,
            vector_class<shared_ptr_class<const void>> SharedPtrStorage,
            vector_class<Requirement *> Requirements,
            vector_class<detail::EventImplPtr> Events,
            detail::code_location loc = {})
      : CG(FILL_USM, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MPattern(std::move(Pattern)), MDst(DstPtr), MLength(Length) {}
  void *getDst() { return MDst; }
  size_t getLength() { return MLength; }
  int getFill() { return MPattern[0]; }
};


class CGPrefetchUSM : public CG {
  void *MDst;
  size_t MLength;

public:
  CGPrefetchUSM(void *DstPtr, size_t Length,
                vector_class<vector_class<char>> ArgsStorage,
                vector_class<detail::AccessorImplPtr> AccStorage,
                vector_class<shared_ptr_class<const void>> SharedPtrStorage,
                vector_class<Requirement *> Requirements,
                vector_class<detail::EventImplPtr> Events,
                detail::code_location loc = {})
      : CG(PREFETCH_USM, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MDst(DstPtr), MLength(Length) {}
  void *getDst() { return MDst; }
  size_t getLength() { return MLength; }
};

class CGInteropTask : public CG {
public:
  std::unique_ptr<InteropTask> MInteropTask;

  CGInteropTask(std::unique_ptr<InteropTask> InteropTask,
                std::vector<std::vector<char>> ArgsStorage,
                std::vector<detail::AccessorImplPtr> AccStorage,
                std::vector<std::shared_ptr<const void>> SharedPtrStorage,
                std::vector<Requirement *> Requirements,
                std::vector<detail::EventImplPtr> Events, CGTYPE Type,
                detail::code_location loc = {})
      : CG(Type, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MInteropTask(std::move(InteropTask)) {}
};

class CGHostTask : public CG {
public:
  std::unique_ptr<HostTask> MHostTask;

  shared_ptr_class<detail::queue_impl> MQueue;

  shared_ptr_class<detail::context_impl> MContext;
  vector_class<ArgDesc> MArgs;

  CGHostTask(std::unique_ptr<HostTask> HostTask,
             std::shared_ptr<detail::queue_impl> Queue,
             std::shared_ptr<detail::context_impl> Context,
             vector_class<ArgDesc> Args,
             std::vector<std::vector<char>> ArgsStorage,
             std::vector<detail::AccessorImplPtr> AccStorage,
             std::vector<std::shared_ptr<const void>> SharedPtrStorage,
             std::vector<Requirement *> Requirements,
             std::vector<detail::EventImplPtr> Events, CGTYPE Type,
             detail::code_location loc = {})
      : CG(Type, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MHostTask(std::move(HostTask)), MQueue(Queue), MContext(Context),
        MArgs(std::move(Args)) {}
};

class CGBarrier : public CG {
public:
  vector_class<detail::EventImplPtr> MEventsWaitWithBarrier;

  CGBarrier(vector_class<detail::EventImplPtr> EventsWaitWithBarrier,
            std::vector<std::vector<char>> ArgsStorage,
            std::vector<detail::AccessorImplPtr> AccStorage,
            std::vector<std::shared_ptr<const void>> SharedPtrStorage,
            std::vector<Requirement *> Requirements,
            std::vector<detail::EventImplPtr> Events, CGTYPE Type,
            detail::code_location loc = {})
      : CG(Type, std::move(ArgsStorage), std::move(AccStorage),
           std::move(SharedPtrStorage), std::move(Requirements),
           std::move(Events), std::move(loc)),
        MEventsWaitWithBarrier(std::move(EventsWaitWithBarrier)) {}
};

}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 2 3
# 41 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
template <typename DataT, int Dimensions, cl::sycl::access::mode AccessMode,
          cl::sycl::access::target AccessTarget,
          cl::sycl::access::placeholder IsPlaceholder>
class __fill;

template <typename T> class __usmfill;

template <typename T_Src, typename T_Dst, int Dims,
          cl::sycl::access::mode AccessMode,
          cl::sycl::access::target AccessTarget,
          cl::sycl::access::placeholder IsPlaceholder>
class __copyAcc2Ptr;

template <typename T_Src, typename T_Dst, int Dims,
          cl::sycl::access::mode AccessMode,
          cl::sycl::access::target AccessTarget,
          cl::sycl::access::placeholder IsPlaceholder>
class __copyPtr2Acc;

template <typename T_Src, int Dims_Src, cl::sycl::access::mode AccessMode_Src,
          cl::sycl::access::target AccessTarget_Src, typename T_Dst,
          int Dims_Dst, cl::sycl::access::mode AccessMode_Dst,
          cl::sycl::access::target AccessTarget_Dst,
          cl::sycl::access::placeholder IsPlaceholder_Src,
          cl::sycl::access::placeholder IsPlaceholder_Dst>
class __copyAcc2Acc;

inline namespace cl {
namespace sycl {



class handler;
template <typename T, int Dimensions, typename AllocatorT, typename Enable>
class buffer;
namespace detail {



class auto_name {};

class kernel_impl;
class queue_impl;
class stream_impl;
template <typename DataT, int Dimensions, access::mode AccessMode,
          access::target AccessTarget, access::placeholder IsPlaceholder>
class image_accessor;
template <typename RetType, typename Func, typename Arg>
static Arg member_ptr_helper(RetType (Func::*)(Arg) const);



template <typename RetType, typename Func, typename Arg>
static Arg member_ptr_helper(RetType (Func::*)(Arg));







template <typename F, typename SuggestedArgType>
decltype(member_ptr_helper(&F::operator())) argument_helper(int);

template <typename F, typename SuggestedArgType>
SuggestedArgType argument_helper(...);

template <typename F, typename SuggestedArgType>
using lambda_arg_type = decltype(argument_helper<F, SuggestedArgType>(0));




template <typename Name, typename Type> struct get_kernel_name_t {
  using name = Name;
};


template <typename Type> struct get_kernel_name_t<detail::auto_name, Type> {
  using name = Type;
};

template <typename, typename T> struct check_fn_signature {
  static_assert(std::integral_constant<T, false>::value,
                "Second template parameter is required to be of function type");
};

template <typename F, typename RetT, typename... Args>
struct check_fn_signature<F, RetT(Args...)> {
private:
  template <typename T>
  static constexpr auto check(T *) -> typename std::is_same<
      decltype(std::declval<T>().operator()(std::declval<Args>()...)),
      RetT>::type;

  template <typename> static constexpr std::false_type check(...);

  using type = decltype(check<F>(0));

public:
  static constexpr bool value = type::value;
};

__attribute__((visibility("default"))) device getDeviceFromHandler(handler &);
# 174 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
template <int Dims, typename T>
typename std::enable_if<std::is_same<T, range<Dims>>::value ||
                        std::is_same<T, id<Dims>>::value>::type
checkValueRange(const T &V) {
# 191 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  (void)V;

}

template <int Dims>
void checkValueRange(const range<Dims> &R, const id<Dims> &O) {
# 207 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  (void)R;
  (void)O;

}

template <int Dims, typename T>
typename std::enable_if<std::is_same<T, nd_range<Dims>>::value>::type
checkValueRange(const T &V) {







  (void)V;

}

}

namespace ONEAPI {
namespace detail {
template <typename T, class BinaryOperation, int Dims, bool IsUSM,
          access::mode AccMode, access::placeholder IsPlaceholder>
class reduction_impl;

using cl::sycl::detail::enable_if_t;
using cl::sycl::detail::queue_impl;

template <typename KernelName, typename KernelType, int Dims, class Reduction,
          typename OutputT>
enable_if_t<Reduction::has_fast_atomics>
reduCGFunc(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
           Reduction &Redu, OutputT Out);

template <typename KernelName, typename KernelType, int Dims, class Reduction>
enable_if_t<!Reduction::has_fast_atomics>
reduCGFunc(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
           Reduction &Redu);

template <typename KernelName, typename KernelType, class Reduction>
enable_if_t<!Reduction::has_fast_atomics, size_t>
reduAuxCGFunc(handler &CGH, size_t NWorkItems, size_t MaxWGSize,
              Reduction &Redu);

__attribute__((visibility("default"))) size_t reduGetMaxWGSize(shared_ptr_class<queue_impl> Queue,
                                      size_t LocalMemBytesPerWorkItem);

}
}
# 292 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
class __attribute__((visibility("default"))) handler {
private:




  handler(shared_ptr_class<detail::queue_impl> Queue, bool IsHost)
      : MQueue(std::move(Queue)), MIsHost(IsHost) {}


  template <typename T, typename F = typename std::remove_const<
                            typename std::remove_reference<T>::type>::type>
  F *storePlainArg(T &&Arg) {
    MArgsStorage.emplace_back(sizeof(T));
    auto Storage = reinterpret_cast<F *>(MArgsStorage.back().data());
    *Storage = Arg;
    return Storage;
  }

  void throwIfActionIsCreated() {
    if (detail::CG::NONE != MCGType)
      throw sycl::runtime_error("Attempt to set multiple actions for the "
                                "command group. Command group must consist of "
                                "a single kernel or explicit memory operation.",
                                -59);
  }



  void
  extractArgsAndReqsFromLambda(char *LambdaPtr, size_t KernelArgsNum,
                               const detail::kernel_param_desc_t *KernelArgs);


  void extractArgsAndReqs();

  void processArg(void *Ptr, const detail::kernel_param_kind_t &Kind,
                  const int Size, const size_t Index, size_t &IndexShift,
                  bool IsKernelCreatedFromSource);


  string_class getKernelName();

  template <typename LambdaNameT> bool lambdaAndKernelHaveEqualName() {





    (static_cast <bool> (MKernel && "MKernel is not initialized") ? void (0) : __assert_fail ("MKernel && \"MKernel is not initialized\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp", 341, __extension__ __PRETTY_FUNCTION__));
    const string_class LambdaName = detail::KernelInfo<LambdaNameT>::getName();
    const string_class KernelName = getKernelName();
    return LambdaName == KernelName;
  }



  void saveCodeLoc(detail::code_location CodeLoc) { MCodeLoc = CodeLoc; }







  event finalize();






  void addStream(const shared_ptr_class<detail::stream_impl> &Stream) {
    MStreamStorage.push_back(Stream);
  }







  void addReduction(const shared_ptr_class<const void> &ReduObj) {
    MSharedPtrStorage.push_back(ReduObj);
  }

  ~handler() = default;

  bool is_host() { return MIsHost; }

  void associateWithHandler(detail::AccessorBaseHost *AccBase,
                            access::target AccTarget);



  template <typename T, typename... Ts>
  void setArgsHelper(int ArgIndex, T &&Arg, Ts &&... Args) {
    set_arg(ArgIndex, std::move(Arg));
    setArgsHelper(++ArgIndex, std::move(Args)...);
  }

  void setArgsHelper(int) {}


  template <typename DataT, int Dims, access::mode AccessMode,
            access::placeholder IsPlaceholder>
  void setArgHelper(int ArgIndex,
                    accessor<DataT, Dims, AccessMode, access::target::local,
                             IsPlaceholder> &&Arg) {
    detail::LocalAccessorBaseHost *LocalAccBase =
        (detail::LocalAccessorBaseHost *)&Arg;
    detail::LocalAccessorImplPtr LocalAccImpl =
        detail::getSyclObjImpl(*LocalAccBase);
    detail::LocalAccessorImplHost *Req = LocalAccImpl.get();
    MLocalAccStorage.push_back(std::move(LocalAccImpl));
    MArgs.emplace_back(detail::kernel_param_kind_t::kind_accessor, Req,
                       static_cast<int>(access::target::local), ArgIndex);
  }


  template <typename DataT, int Dims, access::mode AccessMode,
            access::target AccessTarget, access::placeholder IsPlaceholder>
  typename std::enable_if<AccessTarget != access::target::local, void>::type
  setArgHelper(
      int ArgIndex,
      accessor<DataT, Dims, AccessMode, AccessTarget, IsPlaceholder> &&Arg) {
    detail::AccessorBaseHost *AccBase = (detail::AccessorBaseHost *)&Arg;
    detail::AccessorImplPtr AccImpl = detail::getSyclObjImpl(*AccBase);
    detail::Requirement *Req = AccImpl.get();

    MRequirements.push_back(Req);

    MAccStorage.push_back(std::move(AccImpl));

    MArgs.emplace_back(detail::kernel_param_kind_t::kind_accessor, Req,
                       static_cast<int>(AccessTarget), ArgIndex);
  }

  template <typename T> void setArgHelper(int ArgIndex, T &&Arg) {
    auto StoredArg = static_cast<void *>(storePlainArg(Arg));

    if (!std::is_same<cl_mem, T>::value && std::is_pointer<T>::value) {
      MArgs.emplace_back(detail::kernel_param_kind_t::kind_pointer, StoredArg,
                         sizeof(T), ArgIndex);
    } else {
      MArgs.emplace_back(detail::kernel_param_kind_t::kind_std_layout,
                         StoredArg, sizeof(T), ArgIndex);
    }
  }

  void setArgHelper(int ArgIndex, sampler &&Arg) {
    auto StoredArg = static_cast<void *>(storePlainArg(Arg));
    MArgs.emplace_back(detail::kernel_param_kind_t::kind_sampler, StoredArg,
                       sizeof(sampler), ArgIndex);
  }

  void verifyKernelInvoc(const kernel &Kernel) {
    if (is_host()) {
      throw invalid_object_error(
          "This kernel invocation method cannot be used on the host",
          PI_INVALID_DEVICE);
    }
    if (Kernel.is_host()) {
      throw invalid_object_error("Invalid kernel type, OpenCL expected",
                                 PI_INVALID_KERNEL);
    }
  }

  static id<1> getDelinearizedIndex(const range<1>, const size_t Index) {
    return {Index};
  }

  static id<2> getDelinearizedIndex(const range<2> Range, const size_t Index) {
    size_t x = Index / Range[1];
    size_t y = Index % Range[1];
    return {x, y};
  }

  static id<3> getDelinearizedIndex(const range<3> Range, const size_t Index) {
    size_t x = Index / (Range[1] * Range[2]);
    size_t y = (Index / Range[2]) % Range[1];
    size_t z = Index % Range[2];
    return {x, y, z};
  }







  template <typename KernelName, typename KernelType, int Dims,
            typename LambdaArgType>
  void StoreLambda(KernelType KernelFunc) {
    MHostKernel.reset(
        new detail::HostKernel<KernelType, LambdaArgType, Dims>(KernelFunc));

    using KI = sycl::detail::KernelInfo<KernelName>;


    if (KI::getName() != nullptr && KI::getName()[0] != '\0') {
      MArgs.clear();
      extractArgsAndReqsFromLambda(MHostKernel->getPtr(), KI::getNumParams(),
                                   &KI::getParamDesc(0));
      MKernelName = KI::getName();
      MOSModuleHandle = detail::OSUtil::getOSModuleHandle(KI::getName());
    } else {



      MArgs = std::move(MAssociatedAccesors);
    }
  }





  template <int Dims_Src, int Dims_Dst>
  static bool IsCopyingRectRegionAvailable(const range<Dims_Src> Src,
                                           const range<Dims_Dst> Dst) {
    if (Dims_Src > Dims_Dst)
      return false;
    for (size_t I = 0; I < Dims_Src; ++I)
      if (Src[I] > Dst[I])
        return false;
    return true;
  }







  template <typename TSrc, int DimSrc, access::mode ModeSrc,
            access::target TargetSrc, typename TDst, int DimDst,
            access::mode ModeDst, access::target TargetDst,
            access::placeholder IsPHSrc, access::placeholder IsPHDst>
  detail::enable_if_t<(DimSrc > 0) && (DimDst > 0), bool>
  copyAccToAccHelper(accessor<TSrc, DimSrc, ModeSrc, TargetSrc, IsPHSrc> Src,
                     accessor<TDst, DimDst, ModeDst, TargetDst, IsPHDst> Dst) {
    if (!MIsHost &&
        IsCopyingRectRegionAvailable(Src.get_range(), Dst.get_range()))
      return false;

    range<1> LinearizedRange(Src.get_count());
    parallel_for<class __copyAcc2Acc<TSrc, DimSrc, ModeSrc, TargetSrc,
                                     TDst, DimDst, ModeDst, TargetDst,
                                     IsPHSrc, IsPHDst>>
                                     (LinearizedRange, [=](id<1> Id) {
      size_t Index = Id[0];
      id<DimSrc> SrcIndex = getDelinearizedIndex(Src.get_range(), Index);
      id<DimDst> DstIndex = getDelinearizedIndex(Dst.get_range(), Index);
      Dst[DstIndex] = Src[SrcIndex];
    });
    return true;
  }

  template <typename T, int Dim, access::mode Mode, access::target Target,
            access::placeholder IsPH>
  static detail::enable_if_t<Dim == 0 && Mode == access::mode::atomic, T>
  readFromFirstAccElement(accessor<T, Dim, Mode, Target, IsPH> Src) {



    atomic<T, access::address_space::global_space> AtomicSrc = Src;

    return AtomicSrc.load();
  }

  template <typename T, int Dim, access::mode Mode, access::target Target,
            access::placeholder IsPH>
  static detail::enable_if_t<(Dim > 0) && Mode == access::mode::atomic, T>
  readFromFirstAccElement(accessor<T, Dim, Mode, Target, IsPH> Src) {
    id<Dim> Id = getDelinearizedIndex(Src.get_range(), 0);
    return Src[Id].load();
  }

  template <typename T, int Dim, access::mode Mode, access::target Target,
            access::placeholder IsPH>
  static detail::enable_if_t<Mode != access::mode::atomic, T>
  readFromFirstAccElement(accessor<T, Dim, Mode, Target, IsPH> Src) {
    return *(Src.get_pointer());
  }

  template <typename T, int Dim, access::mode Mode, access::target Target,
            access::placeholder IsPH>
  static detail::enable_if_t<Dim == 0 && Mode == access::mode::atomic, void>
  writeToFirstAccElement(accessor<T, Dim, Mode, Target, IsPH> Dst, T V) {



    atomic<T, access::address_space::global_space> AtomicDst = Dst;

    AtomicDst.store(V);
  }

  template <typename T, int Dim, access::mode Mode, access::target Target,
            access::placeholder IsPH>
  static detail::enable_if_t<(Dim > 0) && Mode == access::mode::atomic, void>
  writeToFirstAccElement(accessor<T, Dim, Mode, Target, IsPH> Dst, T V) {
    id<Dim> Id = getDelinearizedIndex(Dst.get_range(), 0);
    Dst[Id].store(V);
  }

  template <typename T, int Dim, access::mode Mode, access::target Target,
            access::placeholder IsPH>
  static detail::enable_if_t<Mode != access::mode::atomic, void>
  writeToFirstAccElement(accessor<T, Dim, Mode, Target, IsPH> Dst, T V) {
    *(Dst.get_pointer()) = V;
  }
# 612 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename TSrc, int DimSrc, access::mode ModeSrc,
            access::target TargetSrc, typename TDst, int DimDst,
            access::mode ModeDst, access::target TargetDst,
            access::placeholder IsPHSrc, access::placeholder IsPHDst>
  detail::enable_if_t<DimSrc == 0 || DimDst == 0, bool>
  copyAccToAccHelper(accessor<TSrc, DimSrc, ModeSrc, TargetSrc, IsPHSrc> Src,
                     accessor<TDst, DimDst, ModeDst, TargetDst, IsPHDst> Dst) {
    if (!MIsHost)
      return false;

    single_task<class __copyAcc2Acc<TSrc, DimSrc, ModeSrc, TargetSrc,
                                    TDst, DimDst, ModeDst, TargetDst,
                                    IsPHSrc, IsPHDst>> ([=]() {
      writeToFirstAccElement(Dst, readFromFirstAccElement(Src));
    });
    return true;
  }







  template <typename TSrc, typename TDst, int Dim, access::mode AccMode,
            access::target AccTarget, access::placeholder IsPH>
  detail::enable_if_t<(Dim > 0)>
  copyAccToPtrHost(accessor<TSrc, Dim, AccMode, AccTarget, IsPH> Src,
                   TDst *Dst) {
    range<Dim> Range = Src.get_range();
    parallel_for<class __copyAcc2Ptr<TSrc, TDst, Dim, AccMode, AccTarget, IsPH>>
        (Range, [=](id<Dim> Index) {
      const size_t LinearIndex = detail::getLinearIndex(Index, Range);
      using TSrcNonConst = typename std::remove_const<TSrc>::type;
      (reinterpret_cast<TSrcNonConst *>(Dst))[LinearIndex] = Src[Index];
    });
  }






  template <typename TSrc, typename TDst, int Dim, access::mode AccMode,
            access::target AccTarget, access::placeholder IsPH>
  detail::enable_if_t<Dim == 0>
  copyAccToPtrHost(accessor<TSrc, Dim, AccMode, AccTarget, IsPH> Src,
                   TDst *Dst) {
    single_task<class __copyAcc2Ptr<TSrc, TDst, Dim, AccMode, AccTarget, IsPH>>
        ([=]() {
      using TSrcNonConst = typename std::remove_const<TSrc>::type;
      *(reinterpret_cast<TSrcNonConst *>(Dst)) = readFromFirstAccElement(Src);
    });
  }





  template <typename TSrc, typename TDst, int Dim, access::mode AccMode,
            access::target AccTarget, access::placeholder IsPH>
  detail::enable_if_t<(Dim > 0)>
  copyPtrToAccHost(TSrc *Src,
                   accessor<TDst, Dim, AccMode, AccTarget, IsPH> Dst) {
    range<Dim> Range = Dst.get_range();
    parallel_for<class __copyPtr2Acc<TSrc, TDst, Dim, AccMode, AccTarget, IsPH>>
        (Range, [=](id<Dim> Index) {
      const size_t LinearIndex = detail::getLinearIndex(Index, Range);
      Dst[Index] = (reinterpret_cast<const TDst *>(Src))[LinearIndex];
    });
  }






  template <typename TSrc, typename TDst, int Dim, access::mode AccMode,
            access::target AccTarget, access::placeholder IsPH>
  detail::enable_if_t<Dim == 0>
  copyPtrToAccHost(TSrc *Src,
                   accessor<TDst, Dim, AccMode, AccTarget, IsPH> Dst) {
    single_task<class __copyPtr2Acc<TSrc, TDst, Dim, AccMode, AccTarget, IsPH>>
        ([=]() {
      writeToFirstAccElement(Dst, *(reinterpret_cast<const TDst *>(Src)));
    });
  }


  constexpr static bool isConstOrGlobal(access::target AccessTarget) {
    return AccessTarget == access::target::global_buffer ||
           AccessTarget == access::target::constant_buffer;
  }

  constexpr static bool isImageOrImageArray(access::target AccessTarget) {
    return AccessTarget == access::target::image ||
           AccessTarget == access::target::image_array;
  }

  constexpr static bool
  isValidTargetForExplicitOp(access::target AccessTarget) {
    return isConstOrGlobal(AccessTarget) || isImageOrImageArray(AccessTarget);
  }
# 727 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName, typename KernelType, int Dims>
  void parallel_for_lambda_impl(range<Dims> NumWorkItems,
                                KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType = sycl::detail::lambda_arg_type<KernelType, item<Dims>>;
    using TransformedArgType =
        typename std::conditional<std::is_integral<LambdaArgType>::value &&
                                      Dims == 1,
                                  item<Dims>, LambdaArgType>::type;




    detail::checkValueRange<Dims>(NumWorkItems);
    MNDRDesc.set(std::move(NumWorkItems));
    StoreLambda<NameT, KernelType, Dims, TransformedArgType>(
        std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }
# 757 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <int Dims>
  void parallel_for_impl(range<Dims> NumWorkItems, kernel Kernel) {
    throwIfActionIsCreated();
    verifyKernelInvoc(Kernel);
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    detail::checkValueRange<Dims>(NumWorkItems);
    MNDRDesc.set(std::move(NumWorkItems));
    MCGType = detail::CG::KERNEL;
    extractArgsAndReqs();
    MKernelName = getKernelName();
  }
# 811 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
public:
  handler(const handler &) = delete;
  handler(handler &&) = delete;
  handler &operator=(const handler &) = delete;
  handler &operator=(handler &&) = delete;
# 824 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename DataT, int Dims, access::mode AccMode,
            access::target AccTarget>
  void
  require(accessor<DataT, Dims, AccMode, AccTarget, access::placeholder::true_t>
              Acc) {

    associateWithHandler(&Acc, AccTarget);



  }




  void depends_on(event Event) {
    MEvents.push_back(detail::getSyclObjImpl(Event));
  }




  void depends_on(const vector_class<event> &Events) {
    for (const event &Event : Events) {
      MEvents.push_back(detail::getSyclObjImpl(Event));
    }
  }

  template <typename T>
  using remove_cv_ref_t =
      typename std::remove_cv<detail::remove_reference_t<T>>::type;

  template <typename U, typename T>
  using is_same_type = std::is_same<remove_cv_ref_t<U>, remove_cv_ref_t<T>>;

  template <typename T> struct ShouldEnableSetArg {
    static constexpr bool value =
        std::is_trivially_copyable<detail::remove_reference_t<T>>::value



        || is_same_type<sampler, T>::value
        || (!is_same_type<cl_mem, T>::value &&
            std::is_pointer<remove_cv_ref_t<T>>::value)
        || is_same_type<cl_mem, T>::value;
  };







  template <typename T>
  typename std::enable_if<ShouldEnableSetArg<T>::value, void>::type
  set_arg(int ArgIndex, T &&Arg) {
    setArgHelper(ArgIndex, std::move(Arg));
  }

  template <typename DataT, int Dims, access::mode AccessMode,
            access::target AccessTarget, access::placeholder IsPlaceholder>
  void
  set_arg(int ArgIndex,
          accessor<DataT, Dims, AccessMode, AccessTarget, IsPlaceholder> Arg) {
    setArgHelper(ArgIndex, std::move(Arg));
  }






  template <typename... Ts> void set_args(Ts &&... Args) {
    setArgsHelper(0, std::move(Args)...);
  }
# 907 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>

  void single_task(KernelType KernelFunc) {



    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;





    MNDRDesc.set(range<1>{1});

    StoreLambda<NameT, KernelType, 0, void>(KernelFunc);
    MCGType = detail::CG::KERNEL;

  }

  template <typename KernelName = detail::auto_name, typename KernelType>

  void parallel_for(range<1> NumWorkItems, KernelType KernelFunc) {



    parallel_for_lambda_impl<KernelName>(NumWorkItems, std::move(KernelFunc));
  }

  template <typename KernelName = detail::auto_name, typename KernelType>

  void parallel_for(range<2> NumWorkItems, KernelType KernelFunc) {



    parallel_for_lambda_impl<KernelName>(NumWorkItems, std::move(KernelFunc));
  }

  template <typename KernelName = detail::auto_name, typename KernelType>

  void parallel_for(range<3> NumWorkItems, KernelType KernelFunc) {



    parallel_for_lambda_impl<KernelName>(NumWorkItems, std::move(KernelFunc));
  }





  template <typename FuncT> void run_on_host_intel(FuncT Func) {
    throwIfActionIsCreated();


    MNDRDesc.set(range<1>{1});

    MArgs = std::move(MAssociatedAccesors);
    MHostKernel.reset(new detail::HostKernel<FuncT, void, 1>(std::move(Func)));
    MCGType = detail::CG::RUN_ON_HOST_INTEL;
  }

  template <typename FuncT>
  detail::enable_if_t<detail::check_fn_signature<
      detail::remove_reference_t<FuncT>, void()>::value>
  codeplay_host_task(FuncT Func) {
    throwIfActionIsCreated();

    MNDRDesc.set(range<1>(1));
    MArgs = std::move(MAssociatedAccesors);

    MHostTask.reset(new detail::HostTask(std::move(Func)));

    MCGType = detail::CG::CODEPLAY_HOST_TASK;
  }

  template <typename FuncT>
  detail::enable_if_t<detail::check_fn_signature<
      detail::remove_reference_t<FuncT>, void(interop_handle)>::value>
  codeplay_host_task(FuncT Func) {
    throwIfActionIsCreated();

    MNDRDesc.set(range<1>(1));
    MArgs = std::move(MAssociatedAccesors);

    MHostTask.reset(new detail::HostTask(std::move(Func)));

    MCGType = detail::CG::CODEPLAY_HOST_TASK;
  }
# 1019 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for(range<Dims> NumWorkItems, id<Dims> WorkItemOffset,
                    KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType = sycl::detail::lambda_arg_type<KernelType, item<Dims>>;





    detail::checkValueRange<Dims>(NumWorkItems, WorkItemOffset);
    MNDRDesc.set(std::move(NumWorkItems), std::move(WorkItemOffset));
    StoreLambda<NameT, KernelType, Dims, LambdaArgType>(std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }
# 1051 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for(nd_range<Dims> ExecutionRange,
                    KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType =
        sycl::detail::lambda_arg_type<KernelType, nd_item<Dims>>;




    detail::checkValueRange<Dims>(ExecutionRange);
    MNDRDesc.set(std::move(ExecutionRange));
    StoreLambda<NameT, KernelType, Dims, LambdaArgType>(std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }





  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims, typename Reduction>
  detail::enable_if_t<Reduction::accessor_mode == access::mode::read_write &&
                      Reduction::has_fast_atomics && !Reduction::is_usm>
  parallel_for(nd_range<Dims> Range, Reduction Redu,
               KernelType KernelFunc) {
    ONEAPI::detail::reduCGFunc<KernelName>(*this, KernelFunc, Range, Redu,
                                           Redu.getUserAccessor());
  }





  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims, typename Reduction>
  detail::enable_if_t<Reduction::accessor_mode == access::mode::read_write &&
                      Reduction::has_fast_atomics && Reduction::is_usm>
  parallel_for(nd_range<Dims> Range, Reduction Redu,
               KernelType KernelFunc) {
    ONEAPI::detail::reduCGFunc<KernelName>(*this, KernelFunc, Range, Redu,
                                           Redu.getUSMPointer());
  }
# 1109 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims, typename Reduction>
  detail::enable_if_t<Reduction::accessor_mode == access::mode::discard_write &&
                      Reduction::has_fast_atomics>
  parallel_for(nd_range<Dims> Range, Reduction Redu,
               KernelType KernelFunc) {
    shared_ptr_class<detail::queue_impl> QueueCopy = MQueue;
    auto RWAcc = Redu.getReadWriteScalarAcc(*this);
    ONEAPI::detail::reduCGFunc<KernelName>(*this, KernelFunc, Range, Redu,
                                           RWAcc);
    this->finalize();


    handler CopyHandler(QueueCopy, MIsHost);
    CopyHandler.saveCodeLoc(MCodeLoc);

    CopyHandler.associateWithHandler(&RWAcc, access::target::global_buffer);
    Redu.associateWithHandler(CopyHandler);

    CopyHandler.copy(RWAcc, Redu.getUserAccessor());
    MLastEvent = CopyHandler.finalize();
  }
# 1147 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims, typename Reduction>
  detail::enable_if_t<!Reduction::has_fast_atomics>
  parallel_for(nd_range<Dims> Range, Reduction Redu,
               KernelType KernelFunc) {
# 1173 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
    constexpr bool HFR = Reduction::has_fast_reduce;
    size_t OneElemSize = HFR ? 0 : sizeof(typename Reduction::result_type);



    size_t MaxWGSize = ONEAPI::detail::reduGetMaxWGSize(MQueue, OneElemSize);
    if (Range.get_local_range().size() > MaxWGSize)
      throw sycl::runtime_error("The implementation handling parallel_for with"
                                " reduction requires smaller work group size.",
                                PI_INVALID_WORK_GROUP_SIZE);


    ONEAPI::detail::reduCGFunc<KernelName>(*this, KernelFunc, Range, Redu);
    shared_ptr_class<detail::queue_impl> QueueCopy = MQueue;
    this->finalize();






    if (MaxWGSize <= 1)
      throw sycl::runtime_error("The implementation handling parallel_for with "
                                "reduction requires the maximal work group "
                                "size to be greater than 1 to converge. "
                                "The maximal work group size depends on the "
                                "device and the size of the objects passed to "
                                "the reduction.",
                                PI_INVALID_WORK_GROUP_SIZE);
    size_t NWorkItems = Range.get_group_range().size();
    while (NWorkItems > 1) {
      handler AuxHandler(QueueCopy, MIsHost);
      AuxHandler.saveCodeLoc(MCodeLoc);

      NWorkItems = ONEAPI::detail::reduAuxCGFunc<KernelName, KernelType>(
          AuxHandler, NWorkItems, MaxWGSize, Redu);
      MLastEvent = AuxHandler.finalize();
    }
  }
# 1223 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for_work_group(range<Dims> NumWorkGroups,
                               KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType =
        sycl::detail::lambda_arg_type<KernelType, group<Dims>>;




    detail::checkValueRange<Dims>(NumWorkGroups);
    MNDRDesc.setNumWorkGroups(NumWorkGroups);
    StoreLambda<NameT, KernelType, Dims, LambdaArgType>(std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }
# 1255 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for_work_group(range<Dims> NumWorkGroups,
                               range<Dims> WorkGroupSize,
                               KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType =
        sycl::detail::lambda_arg_type<KernelType, group<Dims>>;





    nd_range<Dims> ExecRange =
        nd_range<Dims>(NumWorkGroups * WorkGroupSize, WorkGroupSize);
    detail::checkValueRange<Dims>(ExecRange);
    MNDRDesc.set(std::move(ExecRange));
    StoreLambda<NameT, KernelType, Dims, LambdaArgType>(std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }







  void single_task(kernel Kernel) {
    throwIfActionIsCreated();
    verifyKernelInvoc(Kernel);


    MNDRDesc.set(range<1>{1});
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    MCGType = detail::CG::KERNEL;
    extractArgsAndReqs();
    MKernelName = getKernelName();
  }

  void parallel_for(range<1> NumWorkItems, kernel Kernel) {
    parallel_for_impl(NumWorkItems, Kernel);
  }

  void parallel_for(range<2> NumWorkItems, kernel Kernel) {
    parallel_for_impl(NumWorkItems, Kernel);
  }

  void parallel_for(range<3> NumWorkItems, kernel Kernel) {
    parallel_for_impl(NumWorkItems, Kernel);
  }
# 1317 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <int Dims>
  void parallel_for(range<Dims> NumWorkItems, id<Dims> WorkItemOffset,
                    kernel Kernel) {
    throwIfActionIsCreated();
    verifyKernelInvoc(Kernel);
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    detail::checkValueRange<Dims>(NumWorkItems, WorkItemOffset);
    MNDRDesc.set(std::move(NumWorkItems), std::move(WorkItemOffset));
    MCGType = detail::CG::KERNEL;
    extractArgsAndReqs();
    MKernelName = getKernelName();
  }
# 1338 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <int Dims> void parallel_for(nd_range<Dims> NDRange, kernel Kernel) {
    throwIfActionIsCreated();
    verifyKernelInvoc(Kernel);
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    detail::checkValueRange<Dims>(NDRange);
    MNDRDesc.set(std::move(NDRange));
    MCGType = detail::CG::KERNEL;
    extractArgsAndReqs();
    MKernelName = getKernelName();
  }







  template <typename KernelName = detail::auto_name, typename KernelType>
  void single_task(kernel Kernel, KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;






    MNDRDesc.set(range<1>{1});
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    MCGType = detail::CG::KERNEL;
    if (!MIsHost && !lambdaAndKernelHaveEqualName<NameT>()) {
      extractArgsAndReqs();
      MKernelName = getKernelName();
    } else
      StoreLambda<NameT, KernelType, 0, void>(std::move(KernelFunc));

  }




  template <typename FuncT> void interop_task(FuncT Func) {

    MInteropTask.reset(new detail::InteropTask(std::move(Func)));
    MCGType = detail::CG::CODEPLAY_INTEROP_TASK;
  }
# 1393 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for(kernel Kernel, range<Dims> NumWorkItems,
                    KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType = sycl::detail::lambda_arg_type<KernelType, item<Dims>>;





    detail::checkValueRange<Dims>(NumWorkItems);
    MNDRDesc.set(std::move(NumWorkItems));
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    MCGType = detail::CG::KERNEL;
    if (!MIsHost && !lambdaAndKernelHaveEqualName<NameT>()) {
      extractArgsAndReqs();
      MKernelName = getKernelName();
    } else
      StoreLambda<NameT, KernelType, Dims, LambdaArgType>(
          std::move(KernelFunc));

  }
# 1428 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for(kernel Kernel, range<Dims> NumWorkItems,
                    id<Dims> WorkItemOffset, KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType = sycl::detail::lambda_arg_type<KernelType, item<Dims>>;






    detail::checkValueRange<Dims>(NumWorkItems, WorkItemOffset);
    MNDRDesc.set(std::move(NumWorkItems), std::move(WorkItemOffset));
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    MCGType = detail::CG::KERNEL;
    if (!MIsHost && !lambdaAndKernelHaveEqualName<NameT>()) {
      extractArgsAndReqs();
      MKernelName = getKernelName();
    } else
      StoreLambda<NameT, KernelType, Dims, LambdaArgType>(
          std::move(KernelFunc));

  }
# 1464 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for(kernel Kernel, nd_range<Dims> NDRange,
                    KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType =
        sycl::detail::lambda_arg_type<KernelType, nd_item<Dims>>;





    detail::checkValueRange<Dims>(NDRange);
    MNDRDesc.set(std::move(NDRange));
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    MCGType = detail::CG::KERNEL;
    if (!MIsHost && !lambdaAndKernelHaveEqualName<NameT>()) {
      extractArgsAndReqs();
      MKernelName = getKernelName();
    } else
      StoreLambda<NameT, KernelType, Dims, LambdaArgType>(
          std::move(KernelFunc));

  }
# 1504 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for_work_group(kernel Kernel, range<Dims> NumWorkGroups,
                               KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType =
        sycl::detail::lambda_arg_type<KernelType, group<Dims>>;





    detail::checkValueRange<Dims>(NumWorkGroups);
    MNDRDesc.setNumWorkGroups(NumWorkGroups);
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    StoreLambda<NameT, KernelType, Dims, LambdaArgType>(std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }
# 1541 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  void parallel_for_work_group(kernel Kernel, range<Dims> NumWorkGroups,
                               range<Dims> WorkGroupSize,
                               KernelType KernelFunc) {
    throwIfActionIsCreated();
    using NameT =
        typename detail::get_kernel_name_t<KernelName, KernelType>::name;
    using LambdaArgType =
        sycl::detail::lambda_arg_type<KernelType, group<Dims>>;






    nd_range<Dims> ExecRange =
        nd_range<Dims>(NumWorkGroups * WorkGroupSize, WorkGroupSize);
    detail::checkValueRange<Dims>(ExecRange);
    MNDRDesc.set(std::move(ExecRange));
    MKernel = detail::getSyclObjImpl(std::move(Kernel));
    StoreLambda<NameT, KernelType, Dims, LambdaArgType>(std::move(KernelFunc));
    MCGType = detail::CG::KERNEL;

  }
# 1579 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename T_Src, typename T_Dst, int Dims, access::mode AccessMode,
            access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t>
  void copy(accessor<T_Src, Dims, AccessMode, AccessTarget, IsPlaceholder> Src,
            shared_ptr_class<T_Dst> Dst) {
    throwIfActionIsCreated();
    static_assert(isValidTargetForExplicitOp(AccessTarget),
                  "Invalid accessor target for the copy method.");


    MSharedPtrStorage.push_back(Dst);
    T_Dst *RawDstPtr = Dst.get();
    copy(Src, RawDstPtr);
  }
# 1601 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename T_Src, typename T_Dst, int Dims, access::mode AccessMode,
            access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t>
  void
  copy(shared_ptr_class<T_Src> Src,
       accessor<T_Dst, Dims, AccessMode, AccessTarget, IsPlaceholder> Dst) {
    throwIfActionIsCreated();
    static_assert(isValidTargetForExplicitOp(AccessTarget),
                  "Invalid accessor target for the copy method.");


    MSharedPtrStorage.push_back(Src);
    T_Src *RawSrcPtr = Src.get();
    copy(RawSrcPtr, Dst);
  }
# 1624 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename T_Src, typename T_Dst, int Dims, access::mode AccessMode,
            access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t>
  void copy(accessor<T_Src, Dims, AccessMode, AccessTarget, IsPlaceholder> Src,
            T_Dst *Dst) {
    throwIfActionIsCreated();
    static_assert(isValidTargetForExplicitOp(AccessTarget),
                  "Invalid accessor target for the copy method.");

    if (MIsHost) {


      copyAccToPtrHost(Src, Dst);
      return;
    }

    MCGType = detail::CG::COPY_ACC_TO_PTR;

    detail::AccessorBaseHost *AccBase = (detail::AccessorBaseHost *)&Src;
    detail::AccessorImplPtr AccImpl = detail::getSyclObjImpl(*AccBase);

    MRequirements.push_back(AccImpl.get());
    MSrcPtr = static_cast<void *>(AccImpl.get());
    MDstPtr = static_cast<void *>(Dst);


    MAccStorage.push_back(std::move(AccImpl));
  }
# 1660 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename T_Src, typename T_Dst, int Dims, access::mode AccessMode,
            access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t>
  void
  copy(const T_Src *Src,
       accessor<T_Dst, Dims, AccessMode, AccessTarget, IsPlaceholder> Dst) {
    throwIfActionIsCreated();
    static_assert(isValidTargetForExplicitOp(AccessTarget),
                  "Invalid accessor target for the copy method.");

    if (MIsHost) {


      copyPtrToAccHost(Src, Dst);
      return;
    }

    MCGType = detail::CG::COPY_PTR_TO_ACC;

    detail::AccessorBaseHost *AccBase = (detail::AccessorBaseHost *)&Dst;
    detail::AccessorImplPtr AccImpl = detail::getSyclObjImpl(*AccBase);

    MRequirements.push_back(AccImpl.get());
    MSrcPtr = const_cast<T_Src *>(Src);
    MDstPtr = static_cast<void *>(AccImpl.get());


    MAccStorage.push_back(std::move(AccImpl));
  }
# 1697 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <
      typename T_Src, int Dims_Src, access::mode AccessMode_Src,
      access::target AccessTarget_Src, typename T_Dst, int Dims_Dst,
      access::mode AccessMode_Dst, access::target AccessTarget_Dst,
      access::placeholder IsPlaceholder_Src = access::placeholder::false_t,
      access::placeholder IsPlaceholder_Dst = access::placeholder::false_t>
  void copy(accessor<T_Src, Dims_Src, AccessMode_Src, AccessTarget_Src,
                     IsPlaceholder_Src>
                Src,
            accessor<T_Dst, Dims_Dst, AccessMode_Dst, AccessTarget_Dst,
                     IsPlaceholder_Dst>
                Dst) {
    throwIfActionIsCreated();
    static_assert(isValidTargetForExplicitOp(AccessTarget_Src),
                  "Invalid source accessor target for the copy method.");
    static_assert(isValidTargetForExplicitOp(AccessTarget_Dst),
                  "Invalid destination accessor target for the copy method.");
    (static_cast <bool> (Dst.get_size() >= Src.get_size() && "The destination accessor does not fit the copied memory.") ? void (0) : __assert_fail ("Dst.get_size() >= Src.get_size() && \"The destination accessor does not fit the copied memory.\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp", 1715, __extension__ __PRETTY_FUNCTION__));

    if (copyAccToAccHelper(Src, Dst))
      return;
    MCGType = detail::CG::COPY_ACC_TO_ACC;

    detail::AccessorBaseHost *AccBaseSrc = (detail::AccessorBaseHost *)&Src;
    detail::AccessorImplPtr AccImplSrc = detail::getSyclObjImpl(*AccBaseSrc);

    detail::AccessorBaseHost *AccBaseDst = (detail::AccessorBaseHost *)&Dst;
    detail::AccessorImplPtr AccImplDst = detail::getSyclObjImpl(*AccBaseDst);

    MRequirements.push_back(AccImplSrc.get());
    MRequirements.push_back(AccImplDst.get());
    MSrcPtr = AccImplSrc.get();
    MDstPtr = AccImplDst.get();


    MAccStorage.push_back(std::move(AccImplSrc));
    MAccStorage.push_back(std::move(AccImplDst));
  }





  template <typename T, int Dims, access::mode AccessMode,
            access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t>
  void
  update_host(accessor<T, Dims, AccessMode, AccessTarget, IsPlaceholder> Acc) {
    throwIfActionIsCreated();
    static_assert(isValidTargetForExplicitOp(AccessTarget),
                  "Invalid accessor target for the update_host method.");
    MCGType = detail::CG::UPDATE_HOST;

    detail::AccessorBaseHost *AccBase = (detail::AccessorBaseHost *)&Acc;
    detail::AccessorImplPtr AccImpl = detail::getSyclObjImpl(*AccBase);

    MDstPtr = static_cast<void *>(AccImpl.get());
    MRequirements.push_back(AccImpl.get());
    MAccStorage.push_back(std::move(AccImpl));
  }
# 1766 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  template <typename T, int Dims, access::mode AccessMode,
            access::target AccessTarget,
            access::placeholder IsPlaceholder = access::placeholder::false_t,
            typename PropertyListT = property_list>
  void
  fill(accessor<T, Dims, AccessMode, AccessTarget, IsPlaceholder, PropertyListT>
           Dst,
       const T &Pattern) {
    throwIfActionIsCreated();

    static_assert(isValidTargetForExplicitOp(AccessTarget),
                  "Invalid accessor target for the fill method.");
    if (!MIsHost && (((Dims == 1) && isConstOrGlobal(AccessTarget)) ||
                     isImageOrImageArray(AccessTarget))) {
      MCGType = detail::CG::FILL;

      detail::AccessorBaseHost *AccBase = (detail::AccessorBaseHost *)&Dst;
      detail::AccessorImplPtr AccImpl = detail::getSyclObjImpl(*AccBase);

      MDstPtr = static_cast<void *>(AccImpl.get());
      MRequirements.push_back(AccImpl.get());
      MAccStorage.push_back(std::move(AccImpl));

      MPattern.resize(sizeof(T));
      auto PatternPtr = reinterpret_cast<T *>(MPattern.data());
      *PatternPtr = Pattern;
    } else {



      range<Dims> Range = Dst.get_range();
      parallel_for<class __fill<T, Dims, AccessMode, AccessTarget,
                                IsPlaceholder>>(Range, [=](id<Dims> Index) {
        Dst[Index] = Pattern;
      });
    }
  }







  template <typename T> void fill(void *Ptr, const T &Pattern, size_t Count) {
    throwIfActionIsCreated();
    static_assert(std::is_trivially_copyable<T>::value,
                  "Pattern must be trivially copyable");
    parallel_for<class __usmfill<T>>(range<1>(Count), [=](id<1> Index) {
      T *CastedPtr = static_cast<T *>(Ptr);
      CastedPtr[Index] = Pattern;
    });
  }




  void barrier() {
    throwIfActionIsCreated();
    MCGType = detail::CG::BARRIER;
  }







  void barrier(const vector_class<event> &WaitList);
# 1845 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  void memcpy(void *Dest, const void *Src, size_t Count);
# 1855 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/handler.hpp" 3
  void memset(void *Dest, int Value, size_t Count);







  void prefetch(const void *Ptr, size_t Count);

private:
  shared_ptr_class<detail::queue_impl> MQueue;




  vector_class<vector_class<char>> MArgsStorage;
  vector_class<detail::AccessorImplPtr> MAccStorage;
  vector_class<detail::LocalAccessorImplPtr> MLocalAccStorage;
  vector_class<shared_ptr_class<detail::stream_impl>> MStreamStorage;
  vector_class<shared_ptr_class<const void>> MSharedPtrStorage;

  vector_class<detail::ArgDesc> MArgs;



  vector_class<detail::ArgDesc> MAssociatedAccesors;

  vector_class<detail::Requirement *> MRequirements;

  detail::NDRDescT MNDRDesc;
  string_class MKernelName;

  shared_ptr_class<detail::kernel_impl> MKernel;

  detail::CG::CGTYPE MCGType = detail::CG::NONE;

  void *MSrcPtr = nullptr;

  void *MDstPtr = nullptr;

  size_t MLength = 0;

  vector_class<char> MPattern;

  unique_ptr_class<detail::HostKernelBase> MHostKernel;

  unique_ptr_class<detail::HostTask> MHostTask;
  detail::OSModuleHandle MOSModuleHandle = detail::OSUtil::ExeModuleHandle;

  unique_ptr_class<detail::InteropTask> MInteropTask;

  vector_class<detail::EventImplPtr> MEvents;


  vector_class<detail::EventImplPtr> MEventsWaitWithBarrier;

  bool MIsHost = false;

  detail::code_location MCodeLoc = {};
  bool MIsFinalized = false;
  event MLastEvent;


  friend class detail::queue_impl;

  template <typename DataT, int Dims, access::mode AccMode,
            access::target AccTarget, access::placeholder isPlaceholder,
            typename PropertyListT>
  friend class accessor;
  friend device detail::getDeviceFromHandler(handler &);

  template <typename DataT, int Dimensions, access::mode AccessMode,
            access::target AccessTarget, access::placeholder IsPlaceholder>
  friend class detail::image_accessor;

  friend class stream;
  friend class detail::stream_impl;


  template <typename T, class BinaryOperation, int Dims, bool IsUSM,
            access::mode AccMode, access::placeholder IsPlaceholder>
  friend class ONEAPI::detail::reduction_impl;

  friend void detail::associateWithHandler(handler &,
                                           detail::AccessorBaseHost *,
                                           access::target);
};
}
}
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 2 3

inline namespace cl {
namespace sycl {
namespace ONEAPI {

namespace detail {

using cl::sycl::detail::queue_impl;

__attribute__((visibility("default"))) size_t reduGetMaxWGSize(shared_ptr_class<queue_impl> Queue,
                                      size_t LocalMemBytesPerWorkItem);
__attribute__((visibility("default"))) size_t reduComputeWGSize(size_t NWorkItems, size_t MaxWGSize,
                                       size_t &NWorkGroups);

using cl::sycl::detail::bool_constant;
using cl::sycl::detail::enable_if_t;
using cl::sycl::detail::is_geninteger16bit;
using cl::sycl::detail::is_geninteger32bit;
using cl::sycl::detail::is_geninteger64bit;
using cl::sycl::detail::is_geninteger8bit;
using cl::sycl::detail::remove_AS;

template <typename T, class BinaryOperation>
using IsReduPlus = detail::bool_constant<
    std::is_same<BinaryOperation, ONEAPI::plus<T>>::value ||
    std::is_same<BinaryOperation, ONEAPI::plus<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduMultiplies = detail::bool_constant<
    std::is_same<BinaryOperation, std::multiplies<T>>::value ||
    std::is_same<BinaryOperation, std::multiplies<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduMinimum = detail::bool_constant<
    std::is_same<BinaryOperation, ONEAPI::minimum<T>>::value ||
    std::is_same<BinaryOperation, ONEAPI::minimum<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduMaximum = detail::bool_constant<
    std::is_same<BinaryOperation, ONEAPI::maximum<T>>::value ||
    std::is_same<BinaryOperation, ONEAPI::maximum<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduBitOR = detail::bool_constant<
    std::is_same<BinaryOperation, ONEAPI::bit_or<T>>::value ||
    std::is_same<BinaryOperation, ONEAPI::bit_or<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduBitXOR = detail::bool_constant<
    std::is_same<BinaryOperation, ONEAPI::bit_xor<T>>::value ||
    std::is_same<BinaryOperation, ONEAPI::bit_xor<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduBitAND = detail::bool_constant<
    std::is_same<BinaryOperation, ONEAPI::bit_and<T>>::value ||
    std::is_same<BinaryOperation, ONEAPI::bit_and<void>>::value>;

template <typename T, class BinaryOperation>
using IsReduOptForFastAtomicFetch =
    detail::bool_constant<(is_geninteger32bit<T>::value ||
                           is_geninteger64bit<T>::value) &&
                          (IsReduPlus<T, BinaryOperation>::value ||
                           IsReduMinimum<T, BinaryOperation>::value ||
                           IsReduMaximum<T, BinaryOperation>::value ||
                           IsReduBitOR<T, BinaryOperation>::value ||
                           IsReduBitXOR<T, BinaryOperation>::value ||
                           IsReduBitAND<T, BinaryOperation>::value)>;

template <typename T, class BinaryOperation>
using IsReduOptForFastReduce = detail::bool_constant<
    (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value ||
     std::is_same<T, half>::value || std::is_same<T, float>::value ||
     std::is_same<T, double>::value) &&
    (IsReduPlus<T, BinaryOperation>::value ||
     IsReduMinimum<T, BinaryOperation>::value ||
     IsReduMaximum<T, BinaryOperation>::value)>;


template <typename T, class BinaryOperation>
using IsZeroIdentityOp = bool_constant<
    ((is_geninteger8bit<T>::value || is_geninteger16bit<T>::value ||
      is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
     (IsReduPlus<T, BinaryOperation>::value ||
      IsReduBitOR<T, BinaryOperation>::value ||
      IsReduBitXOR<T, BinaryOperation>::value)) ||
    ((std::is_same<T, half>::value || std::is_same<T, float>::value ||
      std::is_same<T, double>::value) &&
     IsReduPlus<T, BinaryOperation>::value)>;


template <typename T, class BinaryOperation>
using IsOneIdentityOp = bool_constant<
    (is_geninteger8bit<T>::value || is_geninteger16bit<T>::value ||
     is_geninteger32bit<T>::value || is_geninteger64bit<T>::value ||
     std::is_same<T, half>::value || std::is_same<T, float>::value ||
     std::is_same<T, double>::value) &&
    IsReduMultiplies<T, BinaryOperation>::value>;


template <typename T, class BinaryOperation>
using IsOnesIdentityOp = bool_constant<
    (is_geninteger8bit<T>::value || is_geninteger16bit<T>::value ||
     is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
    IsReduBitAND<T, BinaryOperation>::value>;


template <typename T, class BinaryOperation>
using IsMinimumIdentityOp = bool_constant<
    (is_geninteger8bit<T>::value || is_geninteger16bit<T>::value ||
     is_geninteger32bit<T>::value || is_geninteger64bit<T>::value ||
     std::is_same<T, half>::value || std::is_same<T, float>::value ||
     std::is_same<T, double>::value) &&
    IsReduMinimum<T, BinaryOperation>::value>;


template <typename T, class BinaryOperation>
using IsMaximumIdentityOp = bool_constant<
    (is_geninteger8bit<T>::value || is_geninteger16bit<T>::value ||
     is_geninteger32bit<T>::value || is_geninteger64bit<T>::value ||
     std::is_same<T, half>::value || std::is_same<T, float>::value ||
     std::is_same<T, double>::value) &&
    IsReduMaximum<T, BinaryOperation>::value>;

template <typename T, class BinaryOperation>
using IsKnownIdentityOp =
    bool_constant<IsZeroIdentityOp<T, BinaryOperation>::value ||
                  IsOneIdentityOp<T, BinaryOperation>::value ||
                  IsOnesIdentityOp<T, BinaryOperation>::value ||
                  IsMinimumIdentityOp<T, BinaryOperation>::value ||
                  IsMaximumIdentityOp<T, BinaryOperation>::value>;





template <typename T, class BinaryOperation, typename Subst = void>
class reducer {
public:
  reducer(const T &Identity, BinaryOperation BOp)
      : MValue(Identity), MIdentity(Identity), MBinaryOp(BOp) {}
  void combine(const T &Partial) { MValue = MBinaryOp(MValue, Partial); }

  T getIdentity() const { return MIdentity; }

  T MValue;

private:
  const T MIdentity;
  BinaryOperation MBinaryOp;
};
# 183 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename T, class BinaryOperation>
class reducer<T, BinaryOperation,
              enable_if_t<IsKnownIdentityOp<T, BinaryOperation>::value>> {
public:
  reducer() : MValue(getIdentity()) {}
  reducer(const T &, BinaryOperation) : MValue(getIdentity()) {}

  void combine(const T &Partial) {
    BinaryOperation BOp;
    MValue = BOp(MValue, Partial);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  static enable_if_t<IsZeroIdentityOp<_T, _BinaryOperation>::value, _T>
  getIdentity() {
    return 0;
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  static enable_if_t<IsOneIdentityOp<_T, _BinaryOperation>::value, _T>
  getIdentity() {
    return 1;
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  static enable_if_t<IsOnesIdentityOp<_T, _BinaryOperation>::value, _T>
  getIdentity() {
    return ~static_cast<_T>(0);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  static enable_if_t<IsMinimumIdentityOp<_T, _BinaryOperation>::value, _T>
  getIdentity() {
    return std::numeric_limits<_T>::has_infinity
               ? std::numeric_limits<_T>::infinity()
               : (std::numeric_limits<_T>::max)();
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  static enable_if_t<IsMaximumIdentityOp<_T, _BinaryOperation>::value, _T>
  getIdentity() {
    return std::numeric_limits<_T>::has_infinity
               ? static_cast<_T>(-std::numeric_limits<_T>::infinity())
               : std::numeric_limits<_T>::lowest();
  }

  template <typename _T = T>
  enable_if_t<std::is_same<_T, T>::value &&
                  IsReduPlus<T, BinaryOperation>::value,
              reducer &>
  operator+=(const _T &Partial) {
    combine(Partial);
    return *this;
  }

  template <typename _T = T>
  enable_if_t<std::is_same<_T, T>::value &&
                  IsReduMultiplies<T, BinaryOperation>::value,
              reducer &>
  operator*=(const _T &Partial) {
    combine(Partial);
    return *this;
  }

  template <typename _T = T>
  enable_if_t<std::is_same<_T, T>::value &&
                  IsReduBitOR<T, BinaryOperation>::value,
              reducer &>
  operator|=(const _T &Partial) {
    combine(Partial);
    return *this;
  }

  template <typename _T = T>
  enable_if_t<std::is_same<_T, T>::value &&
                  IsReduBitXOR<T, BinaryOperation>::value,
              reducer &>
  operator^=(const _T &Partial) {
    combine(Partial);
    return *this;
  }

  template <typename _T = T>
  enable_if_t<std::is_same<_T, T>::value &&
                  IsReduBitAND<T, BinaryOperation>::value,
              reducer &>
  operator&=(const _T &Partial) {
    combine(Partial);
    return *this;
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<std::is_same<typename remove_AS<_T>::type, T>::value &&
              (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
              IsReduPlus<T, _BinaryOperation>::value>
  atomic_combine(_T *ReduVarPtr) const {
    atomic<T, access::address_space::global_space>(global_ptr<T>(ReduVarPtr))
        .fetch_add(MValue);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<std::is_same<typename remove_AS<_T>::type, T>::value &&
              (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
              IsReduBitOR<T, _BinaryOperation>::value>
  atomic_combine(_T *ReduVarPtr) const {
    atomic<T, access::address_space::global_space>(global_ptr<T>(ReduVarPtr))
        .fetch_or(MValue);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<std::is_same<typename remove_AS<_T>::type, T>::value &&
              (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
              IsReduBitXOR<T, _BinaryOperation>::value>
  atomic_combine(_T *ReduVarPtr) const {
    atomic<T, access::address_space::global_space>(global_ptr<T>(ReduVarPtr))
        .fetch_xor(MValue);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<std::is_same<typename remove_AS<_T>::type, T>::value &&
              (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
              IsReduBitAND<T, _BinaryOperation>::value>
  atomic_combine(_T *ReduVarPtr) const {
    atomic<T, access::address_space::global_space>(global_ptr<T>(ReduVarPtr))
        .fetch_and(MValue);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<std::is_same<typename remove_AS<_T>::type, T>::value &&
              (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
              IsReduMinimum<T, _BinaryOperation>::value>
  atomic_combine(_T *ReduVarPtr) const {
    atomic<T, access::address_space::global_space>(global_ptr<T>(ReduVarPtr))
        .fetch_min(MValue);
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<std::is_same<typename remove_AS<_T>::type, T>::value &&
              (is_geninteger32bit<T>::value || is_geninteger64bit<T>::value) &&
              IsReduMaximum<T, _BinaryOperation>::value>
  atomic_combine(_T *ReduVarPtr) const {
    atomic<T, access::address_space::global_space>(global_ptr<T>(ReduVarPtr))
        .fetch_max(MValue);
  }

  T MValue;
};



template <typename T, class BinaryOperation, int Dims, bool IsUSM,
          access::mode AccMode = access::mode::read_write,
          access::placeholder IsPlaceholder = access::placeholder::false_t>
class reduction_impl {
public:
  using reducer_type = reducer<T, BinaryOperation>;
  using result_type = T;
  using binary_operation = BinaryOperation;
  using accessor_type =
      accessor<T, Dims, AccMode, access::target::global_buffer, IsPlaceholder,
               ONEAPI::accessor_property_list<>>;
  using rw_accessor_type =
      accessor<T, Dims, access::mode::read_write, access::target::global_buffer,
               IsPlaceholder, ONEAPI::accessor_property_list<>>;
  static constexpr access::mode accessor_mode = AccMode;
  static constexpr int accessor_dim = Dims;
  static constexpr int buffer_dim = (Dims == 0) ? 1 : Dims;
  static constexpr bool has_fast_atomics =
      IsReduOptForFastAtomicFetch<T, BinaryOperation>::value;
  static constexpr bool has_fast_reduce =
      IsReduOptForFastReduce<T, BinaryOperation>::value;
  static constexpr bool is_usm = IsUSM;
  static constexpr bool is_placeholder =
      (IsPlaceholder == access::placeholder::true_t);





  static_assert(Dims <= 1,
                "Multi-dimensional reductions are not supported yet.");


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<IsKnownIdentityOp<_T, _BinaryOperation>::value,
              _T> constexpr getIdentity() {
    return reducer_type::getIdentity();
  }


  template <typename _T = T, class _BinaryOperation = BinaryOperation>
  enable_if_t<!IsKnownIdentityOp<_T, _BinaryOperation>::value, _T>
  getIdentity() {
    return MIdentity;
  }




  template <
      typename _T = T, class _BinaryOperation = BinaryOperation,
      enable_if_t<IsKnownIdentityOp<_T, _BinaryOperation>::value> * = nullptr>
  reduction_impl(accessor_type &Acc)
      : MAcc(shared_ptr_class<accessor_type>(shared_ptr_class<accessor_type>{},
                                             &Acc)),
        MIdentity(getIdentity()) {
    (static_cast <bool> (Acc.get_count() == 1 && "Only scalar/1-element reductions are supported now.") ? void (0) : __assert_fail ("Acc.get_count() == 1 && \"Only scalar/1-element reductions are supported now.\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp", 401, __extension__ __PRETTY_FUNCTION__));

  }





  template <
      typename _T = T, class _BinaryOperation = BinaryOperation,
      enable_if_t<IsKnownIdentityOp<_T, _BinaryOperation>::value> * = nullptr>
  reduction_impl(accessor_type &Acc, const T &Identity, BinaryOperation)
      : MAcc(shared_ptr_class<accessor_type>(shared_ptr_class<accessor_type>{},
                                             &Acc)),
        MIdentity(getIdentity()) {
    (void)Identity;
    (static_cast <bool> (Acc.get_count() == 1 && "Only scalar/1-element reductions are supported now.") ? void (0) : __assert_fail ("Acc.get_count() == 1 && \"Only scalar/1-element reductions are supported now.\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp", 417, __extension__ __PRETTY_FUNCTION__));
# 429 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
  }




  template <
      typename _T = T, class _BinaryOperation = BinaryOperation,
      enable_if_t<!IsKnownIdentityOp<_T, _BinaryOperation>::value> * = nullptr>
  reduction_impl(accessor_type &Acc, const T &Identity, BinaryOperation BOp)
      : MAcc(shared_ptr_class<accessor_type>(shared_ptr_class<accessor_type>{},
                                             &Acc)),
        MIdentity(Identity), MBinaryOp(BOp) {
    (static_cast <bool> (Acc.get_count() == 1 && "Only scalar/1-element reductions are supported now.") ? void (0) : __assert_fail ("Acc.get_count() == 1 && \"Only scalar/1-element reductions are supported now.\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp", 442, __extension__ __PRETTY_FUNCTION__));

  }





  template <
      typename _T = T, class _BinaryOperation = BinaryOperation,
      enable_if_t<IsKnownIdentityOp<_T, _BinaryOperation>::value> * = nullptr>
  reduction_impl(T *VarPtr) : MIdentity(getIdentity()), MUSMPointer(VarPtr) {}






  template <
      typename _T = T, class _BinaryOperation = BinaryOperation,
      enable_if_t<IsKnownIdentityOp<_T, _BinaryOperation>::value> * = nullptr>
  reduction_impl(T *VarPtr, const T &Identity, BinaryOperation)
      : MIdentity(Identity), MUSMPointer(VarPtr) {
# 475 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
  }





  template <
      typename _T = T, class _BinaryOperation = BinaryOperation,
      enable_if_t<!IsKnownIdentityOp<_T, _BinaryOperation>::value> * = nullptr>
  reduction_impl(T *VarPtr, const T &Identity, BinaryOperation BOp)
      : MIdentity(Identity), MUSMPointer(VarPtr), MBinaryOp(BOp) {}



  void associateWithHandler(handler &CGH) {

    CGH.associateWithHandler(MAcc.get(), access::target::global_buffer);



  }

  accessor<T, buffer_dim, access::mode::discard_read_write,
           access::target::local>
  getReadWriteLocalAcc(size_t Size, handler &CGH) {
    return accessor<T, buffer_dim, access::mode::discard_read_write,
                    access::target::local>(Size, CGH);
  }

  accessor<T, buffer_dim, access::mode::read>
  getReadAccToPreviousPartialReds(handler &CGH) const {
    CGH.addReduction(MOutBufPtr);
    return accessor<T, buffer_dim, access::mode::read>(*MOutBufPtr, CGH);
  }

  template <access::placeholder _IsPlaceholder = IsPlaceholder>
  enable_if_t<_IsPlaceholder == access::placeholder::false_t, accessor_type>
  getWriteAccForPartialReds(size_t Size, handler &CGH) {
    if (Size == 1)
      return *MAcc;


    MOutBufPtr = std::make_shared<buffer<T, buffer_dim>>(range<1>(Size));
    CGH.addReduction(MOutBufPtr);
    return accessor_type(*MOutBufPtr, CGH);
  }

  template <access::placeholder _IsPlaceholder = IsPlaceholder>
  enable_if_t<_IsPlaceholder == access::placeholder::true_t, accessor_type>
  getWriteAccForPartialReds(size_t Size, handler &CGH) {
    if (Size == 1)
      return *MAcc;


    MOutBufPtr = std::make_shared<buffer<T, buffer_dim>>(range<1>(Size));
    accessor_type NewAcc(*MOutBufPtr);
    CGH.addReduction(MOutBufPtr);
    CGH.require(NewAcc);
    return NewAcc;
  }



  accessor<T, Dims, access::mode::read_write, access::target::global_buffer>
  getReadWriteScalarAcc(handler &CGH) const {
    auto RWReduVal = std::make_shared<T>(MIdentity);
    CGH.addReduction(RWReduVal);
    auto RWReduBuf =
        std::make_shared<buffer<T, 1>>(RWReduVal.get(), range<1>(1));
    CGH.addReduction(RWReduBuf);
    return accessor<T, Dims, access::mode::read_write,
                    access::target::global_buffer>(*RWReduBuf, CGH);
  }

  accessor_type &getUserAccessor() { return *MAcc; }

  T *getUSMPointer() {
    (static_cast <bool> (is_usm && "Unexpected call of getUSMPointer().") ? void (0) : __assert_fail ("is_usm && \"Unexpected call of getUSMPointer().\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp", 552, __extension__ __PRETTY_FUNCTION__));
    return MUSMPointer;
  }

  template <typename AccT>
  enable_if_t<std::is_same<AccT, rw_accessor_type>::value ||
                  std::is_same<AccT, accessor_type>::value,
              result_type *> static inline getOutPointer(const AccT &OutAcc) {
    return OutAcc.get_pointer().get();
  }

  template <typename ResT>
  enable_if_t<std::is_same<ResT, result_type>::value,
              result_type *> static inline getOutPointer(ResT *OutPtr) {
    return OutPtr;
  }


  BinaryOperation getBinaryOperation() const { return MBinaryOp; }

private:


  const T MIdentity;


  shared_ptr_class<accessor_type> MAcc;

  shared_ptr_class<buffer<T, buffer_dim>> MOutBufPtr;



  T *MUSMPointer = nullptr;

  BinaryOperation MBinaryOp;
};




template <typename T1, bool B1, bool B2, typename T2>
class __sycl_reduction_main_kernel;
template <typename T1, bool B1, bool B2, typename T2>
class __sycl_reduction_aux_kernel;




template <typename Name, typename Type, bool B1, bool B2, typename OutputT>
struct get_reduction_main_kernel_name_t {
  using name = __sycl_reduction_main_kernel<
      typename sycl::detail::get_kernel_name_t<Name, Type>::name, B1, B2,
      OutputT>;
};
template <typename Name, typename Type, bool B1, bool B2, typename OutputT>
struct get_reduction_aux_kernel_name_t {
  using name = __sycl_reduction_aux_kernel<
      typename sycl::detail::get_kernel_name_t<Name, Type>::name, B1, B2,
      OutputT>;
};
# 621 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename KernelName, typename KernelType, int Dims, class Reduction,
          bool UniformWG, typename OutputT>
enable_if_t<Reduction::has_fast_reduce && Reduction::has_fast_atomics>
reduCGFuncImpl(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
               Reduction &, OutputT Out) {
  size_t NWorkItems = Range.get_global_range().size();
  using Name = typename get_reduction_main_kernel_name_t<
      KernelName, KernelType, Reduction::is_usm, UniformWG, OutputT>::name;
  CGH.parallel_for<Name>(Range, [=](nd_item<Dims> NDIt) {

    typename Reduction::reducer_type Reducer;
    KernelFunc(NDIt, Reducer);

    typename Reduction::binary_operation BOp;
    typename Reduction::result_type Val =
        (UniformWG || NDIt.get_global_linear_id() < NWorkItems)
            ? Reducer.MValue
            : Reducer.getIdentity();
    Reducer.MValue = ONEAPI::reduce(NDIt.get_group(), Val, BOp);
    if (NDIt.get_local_linear_id() == 0)
      Reducer.atomic_combine(Reduction::getOutPointer(Out));
  });
}
# 653 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename KernelName, typename KernelType, int Dims, class Reduction,
          bool UniformPow2WG, typename OutputT>
enable_if_t<!Reduction::has_fast_reduce && Reduction::has_fast_atomics>
reduCGFuncImpl(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
               Reduction &Redu, OutputT Out) {
  size_t NWorkItems = Range.get_global_range().size();
  size_t WGSize = Range.get_local_range().size();





  size_t NLocalElements = WGSize + (UniformPow2WG ? 0 : 1);
  auto LocalReds = Redu.getReadWriteLocalAcc(NLocalElements, CGH);

  using Name = typename get_reduction_main_kernel_name_t<
      KernelName, KernelType, Reduction::is_usm, UniformPow2WG, OutputT>::name;
  CGH.parallel_for<Name>(Range, [=](nd_item<Dims> NDIt) {

    typename Reduction::reducer_type Reducer;
    KernelFunc(NDIt, Reducer);

    size_t WGSize = NDIt.get_local_range().size();
    size_t LID = NDIt.get_local_linear_id();


    typename Reduction::result_type ReduIdentity = Reducer.getIdentity();
    LocalReds[LID] = (UniformPow2WG || NDIt.get_global_linear_id() < NWorkItems)
                         ? Reducer.MValue
                         : ReduIdentity;
    if (!UniformPow2WG)
      LocalReds[WGSize] = ReduIdentity;
    NDIt.barrier();




    typename Reduction::binary_operation BOp;
    size_t PrevStep = WGSize;
    for (size_t CurStep = PrevStep >> 1; CurStep > 0; CurStep >>= 1) {
      if (LID < CurStep)
        LocalReds[LID] = BOp(LocalReds[LID], LocalReds[LID + CurStep]);
      else if (!UniformPow2WG && LID == CurStep && (PrevStep & 0x1))
        LocalReds[WGSize] = BOp(LocalReds[WGSize], LocalReds[PrevStep - 1]);
      NDIt.barrier();
      PrevStep = CurStep;
    }

    if (LID == 0) {
      Reducer.MValue =
          UniformPow2WG ? LocalReds[0] : BOp(LocalReds[0], LocalReds[WGSize]);
      Reducer.atomic_combine(Reduction::getOutPointer(Out));
    }
  });
}

template <typename KernelName, typename KernelType, int Dims, class Reduction,
          typename OutputT>
enable_if_t<Reduction::has_fast_atomics>
reduCGFunc(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
           Reduction &Redu, OutputT Out) {

  size_t NWorkItems = Range.get_global_range().size();
  size_t WGSize = Range.get_local_range().size();
  size_t NWorkGroups = Range.get_group_range().size();

  bool HasUniformWG = NWorkGroups * WGSize == NWorkItems;
  if (!Reduction::has_fast_reduce)
    HasUniformWG = HasUniformWG && (WGSize & (WGSize - 1)) == 0;
  if (HasUniformWG)
    reduCGFuncImpl<KernelName, KernelType, Dims, Reduction, true>(
        CGH, KernelFunc, Range, Redu, Out);
  else
    reduCGFuncImpl<KernelName, KernelType, Dims, Reduction, false>(
        CGH, KernelFunc, Range, Redu, Out);
}
# 738 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename KernelName, typename KernelType, int Dims, class Reduction,
          bool UniformWG, typename OutputT>
enable_if_t<Reduction::has_fast_reduce && !Reduction::has_fast_atomics>
reduCGFuncImpl(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
               Reduction &, OutputT Out) {

  size_t NWorkItems = Range.get_global_range().size();
  size_t NWorkGroups = Range.get_group_range().size();




  bool IsUpdateOfUserVar =
      Reduction::accessor_mode == access::mode::read_write && NWorkGroups == 1;

  using Name = typename get_reduction_main_kernel_name_t<
      KernelName, KernelType, Reduction::is_usm, UniformWG, OutputT>::name;
  CGH.parallel_for<Name>(Range, [=](nd_item<Dims> NDIt) {

    typename Reduction::reducer_type Reducer;
    KernelFunc(NDIt, Reducer);


    size_t WGID = NDIt.get_group_linear_id();
    typename Reduction::result_type PSum =
        (UniformWG || (NDIt.get_group_linear_id() < NWorkItems))
            ? Reducer.MValue
            : Reducer.getIdentity();
    typename Reduction::binary_operation BOp;
    PSum = ONEAPI::reduce(NDIt.get_group(), PSum, BOp);
    if (NDIt.get_local_linear_id() == 0) {
      if (IsUpdateOfUserVar)
        PSum = BOp(*(Reduction::getOutPointer(Out)), PSum);
      Reduction::getOutPointer(Out)[WGID] = PSum;
    }
  });
}
# 784 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename KernelName, typename KernelType, int Dims, class Reduction,
          bool UniformPow2WG, typename OutputT>
enable_if_t<!Reduction::has_fast_reduce && !Reduction::has_fast_atomics>
reduCGFuncImpl(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
               Reduction &Redu, OutputT Out) {
  size_t NWorkItems = Range.get_global_range().size();
  size_t WGSize = Range.get_local_range().size();
  size_t NWorkGroups = Range.get_group_range().size();

  bool IsUpdateOfUserVar =
      Reduction::accessor_mode == access::mode::read_write && NWorkGroups == 1;





  size_t NumLocalElements = WGSize + (UniformPow2WG ? 0 : 1);
  auto LocalReds = Redu.getReadWriteLocalAcc(NumLocalElements, CGH);
  typename Reduction::result_type ReduIdentity = Redu.getIdentity();
  using Name = typename get_reduction_main_kernel_name_t<
      KernelName, KernelType, Reduction::is_usm, UniformPow2WG, OutputT>::name;
  auto BOp = Redu.getBinaryOperation();
  CGH.parallel_for<Name>(Range, [=](nd_item<Dims> NDIt) {

    typename Reduction::reducer_type Reducer(ReduIdentity, BOp);
    KernelFunc(NDIt, Reducer);

    size_t WGSize = NDIt.get_local_range().size();
    size_t LID = NDIt.get_local_linear_id();
    size_t GID = NDIt.get_global_linear_id();

    LocalReds[LID] = (GID < NWorkItems) ? Reducer.MValue : ReduIdentity;
    if (!UniformPow2WG)
      LocalReds[WGSize] = ReduIdentity;
    NDIt.barrier();




    size_t PrevStep = WGSize;
    for (size_t CurStep = PrevStep >> 1; CurStep > 0; CurStep >>= 1) {
      if (LID < CurStep)
        LocalReds[LID] = BOp(LocalReds[LID], LocalReds[LID + CurStep]);
      else if (!UniformPow2WG && LID == CurStep && (PrevStep & 0x1))
        LocalReds[WGSize] = BOp(LocalReds[WGSize], LocalReds[PrevStep - 1]);
      NDIt.barrier();
      PrevStep = CurStep;
    }


    if (LID == 0) {
      size_t GrID = NDIt.get_group_linear_id();
      typename Reduction::result_type PSum =
          UniformPow2WG ? LocalReds[0] : BOp(LocalReds[0], LocalReds[WGSize]);
      if (IsUpdateOfUserVar)
        PSum = BOp(*(Reduction::getOutPointer(Out)), PSum);
      Reduction::getOutPointer(Out)[GrID] = PSum;
    }
  });
}

template <typename KernelName, typename KernelType, int Dims, class Reduction>
enable_if_t<!Reduction::has_fast_atomics>
reduCGFunc(handler &CGH, KernelType KernelFunc, const nd_range<Dims> &Range,
           Reduction &Redu) {
  size_t NWorkItems = Range.get_global_range().size();
  size_t WGSize = Range.get_local_range().size();
  size_t NWorkGroups = Range.get_group_range().size();




  bool HasUniformWG = NWorkGroups * WGSize == NWorkItems;
  if (!Reduction::has_fast_reduce)
    HasUniformWG = HasUniformWG && ((WGSize & (WGSize - 1)) == 0);

  if (Reduction::is_usm && NWorkGroups == 1) {
    if (HasUniformWG)
      reduCGFuncImpl<KernelName, KernelType, Dims, Reduction, true>(
          CGH, KernelFunc, Range, Redu, Redu.getUSMPointer());
    else
      reduCGFuncImpl<KernelName, KernelType, Dims, Reduction, false>(
          CGH, KernelFunc, Range, Redu, Redu.getUSMPointer());
  } else {
    auto Out = Redu.getWriteAccForPartialReds(NWorkGroups, CGH);
    if (HasUniformWG)
      reduCGFuncImpl<KernelName, KernelType, Dims, Reduction, true>(
          CGH, KernelFunc, Range, Redu, Out);
    else
      reduCGFuncImpl<KernelName, KernelType, Dims, Reduction, false>(
          CGH, KernelFunc, Range, Redu, Out);
  }
}
# 885 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename KernelName, typename KernelType, bool UniformWG,
          class Reduction, typename InputT, typename OutputT>
enable_if_t<Reduction::has_fast_reduce && !Reduction::has_fast_atomics>
reduAuxCGFuncImpl(handler &CGH, size_t NWorkItems, size_t NWorkGroups,
                  size_t WGSize, Reduction &, InputT In, OutputT Out) {
  using Name = typename get_reduction_aux_kernel_name_t<
      KernelName, KernelType, Reduction::is_usm, UniformWG, OutputT>::name;

  bool IsUpdateOfUserVar =
      Reduction::accessor_mode == access::mode::read_write && NWorkGroups == 1;
  nd_range<1> Range{range<1>(NWorkItems), range<1>(WGSize)};
  CGH.parallel_for<Name>(Range, [=](nd_item<1> NDIt) {
    typename Reduction::binary_operation BOp;
    size_t WGID = NDIt.get_group_linear_id();
    size_t GID = NDIt.get_global_linear_id();
    typename Reduction::result_type PSum =
        (UniformWG || (GID < NWorkItems))
            ? In[GID]
            : Reduction::reducer_type::getIdentity();
    PSum = ONEAPI::reduce(NDIt.get_group(), PSum, BOp);
    if (NDIt.get_local_linear_id() == 0) {
      if (IsUpdateOfUserVar)
        PSum = BOp(*(Reduction::getOutPointer(Out)), PSum);
      Reduction::getOutPointer(Out)[WGID] = PSum;
    }
  });
}
# 920 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/ONEAPI/reduction.hpp" 3
template <typename KernelName, typename KernelType, bool UniformPow2WG,
          class Reduction, typename InputT, typename OutputT>
enable_if_t<!Reduction::has_fast_reduce && !Reduction::has_fast_atomics>
reduAuxCGFuncImpl(handler &CGH, size_t NWorkItems, size_t NWorkGroups,
                  size_t WGSize, Reduction &Redu, InputT In, OutputT Out) {
  bool IsUpdateOfUserVar =
      Reduction::accessor_mode == access::mode::read_write && NWorkGroups == 1;





  size_t NumLocalElements = WGSize + (UniformPow2WG ? 0 : 1);
  auto LocalReds = Redu.getReadWriteLocalAcc(NumLocalElements, CGH);

  auto ReduIdentity = Redu.getIdentity();
  auto BOp = Redu.getBinaryOperation();
  using Name = typename get_reduction_aux_kernel_name_t<
      KernelName, KernelType, Reduction::is_usm, UniformPow2WG, OutputT>::name;
  nd_range<1> Range{range<1>(NWorkItems), range<1>(WGSize)};
  CGH.parallel_for<Name>(Range, [=](nd_item<1> NDIt) {
    size_t WGSize = NDIt.get_local_range().size();
    size_t LID = NDIt.get_local_linear_id();
    size_t GID = NDIt.get_global_linear_id();


    LocalReds[LID] =
        (UniformPow2WG || GID < NWorkItems) ? In[GID] : ReduIdentity;
    if (!UniformPow2WG)
      LocalReds[WGSize] = ReduIdentity;
    NDIt.barrier();




    size_t PrevStep = WGSize;
    for (size_t CurStep = PrevStep >> 1; CurStep > 0; CurStep >>= 1) {
      if (LID < CurStep)
        LocalReds[LID] = BOp(LocalReds[LID], LocalReds[LID + CurStep]);
      else if (!UniformPow2WG && LID == CurStep && (PrevStep & 0x1))
        LocalReds[WGSize] = BOp(LocalReds[WGSize], LocalReds[PrevStep - 1]);
      NDIt.barrier();
      PrevStep = CurStep;
    }


    if (LID == 0) {
      size_t GrID = NDIt.get_group_linear_id();
      typename Reduction::result_type PSum =
          UniformPow2WG ? LocalReds[0] : BOp(LocalReds[0], LocalReds[WGSize]);
      if (IsUpdateOfUserVar)
        PSum = BOp(*(Reduction::getOutPointer(Out)), PSum);
      Reduction::getOutPointer(Out)[GrID] = PSum;
    }
  });
}





template <typename KernelName, typename KernelType, class Reduction>
enable_if_t<!Reduction::has_fast_atomics, size_t>
reduAuxCGFunc(handler &CGH, size_t NWorkItems, size_t MaxWGSize,
              Reduction &Redu) {

  size_t NWorkGroups;
  size_t WGSize = reduComputeWGSize(NWorkItems, MaxWGSize, NWorkGroups);



  if (NWorkGroups == 1 && !Reduction::is_usm)
    Redu.associateWithHandler(CGH);




  bool HasUniformWG = NWorkGroups * WGSize == NWorkItems;
  if (!Reduction::has_fast_reduce)
    HasUniformWG = HasUniformWG && (WGSize & (WGSize - 1)) == 0;



  auto In = Redu.getReadAccToPreviousPartialReds(CGH);
  if (Reduction::is_usm && NWorkGroups == 1) {
    if (HasUniformWG)
      reduAuxCGFuncImpl<KernelName, KernelType, true>(
          CGH, NWorkItems, NWorkGroups, WGSize, Redu, In, Redu.getUSMPointer());
    else
      reduAuxCGFuncImpl<KernelName, KernelType, false>(
          CGH, NWorkItems, NWorkGroups, WGSize, Redu, In, Redu.getUSMPointer());
  } else {
    auto Out = Redu.getWriteAccForPartialReds(NWorkGroups, CGH);
    if (HasUniformWG)
      reduAuxCGFuncImpl<KernelName, KernelType, true>(
          CGH, NWorkItems, NWorkGroups, WGSize, Redu, In, Out);
    else
      reduAuxCGFuncImpl<KernelName, KernelType, false>(
          CGH, NWorkItems, NWorkGroups, WGSize, Redu, In, Out);
  }
  return NWorkGroups;
}

}





template <typename T, class BinaryOperation, int Dims, access::mode AccMode,
          access::placeholder IsPH>
detail::reduction_impl<T, BinaryOperation, Dims, false, AccMode, IsPH>
reduction(accessor<T, Dims, AccMode, access::target::global_buffer, IsPH> &Acc,
          const T &Identity, BinaryOperation BOp) {

  return detail::reduction_impl<T, BinaryOperation, Dims, false, AccMode, IsPH>(
      Acc, Identity, BOp);
}





template <typename T, class BinaryOperation, int Dims, access::mode AccMode,
          access::placeholder IsPH>
detail::enable_if_t<
    detail::IsKnownIdentityOp<T, BinaryOperation>::value,
    detail::reduction_impl<T, BinaryOperation, Dims, false, AccMode, IsPH>>
reduction(accessor<T, Dims, AccMode, access::target::global_buffer, IsPH> &Acc,
          BinaryOperation) {

  return detail::reduction_impl<T, BinaryOperation, Dims, false, AccMode, IsPH>(
      Acc);
}





template <typename T, class BinaryOperation>
detail::reduction_impl<T, BinaryOperation, 0, true, access::mode::read_write>
reduction(T *VarPtr, const T &Identity, BinaryOperation BOp) {
  return detail::reduction_impl<T, BinaryOperation, 0, true,
                                access::mode::read_write>(VarPtr, Identity,
                                                          BOp);
}






template <typename T, class BinaryOperation>
detail::enable_if_t<detail::IsKnownIdentityOp<T, BinaryOperation>::value,
                    detail::reduction_impl<T, BinaryOperation, 0, true,
                                           access::mode::read_write>>
reduction(T *VarPtr, BinaryOperation) {
  return detail::reduction_impl<T, BinaryOperation, 0, true,
                                access::mode::read_write>(VarPtr);
}

}
}
}
# 17 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3




# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/backend.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/backend.hpp" 3
inline namespace cl {
namespace sycl {

template <backend BackendName, class SyclObjectT>
auto get_native(const SyclObjectT &Obj) ->
    typename interop<BackendName, SyclObjectT>::type {
  return Obj.template get_native<BackendName>();
}


template <backend BackendName, typename DataT, int Dimensions,
          access::mode AccessMode, access::target AccessTarget,
          access::placeholder IsPlaceholder>
auto get_native(const accessor<DataT, Dimensions, AccessMode, AccessTarget,
                               IsPlaceholder> &Obj) ->
    typename interop<BackendName, accessor<DataT, Dimensions, AccessMode,
                                           AccessTarget, IsPlaceholder>>::type =
    delete;

}
}
# 22 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 38 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/pipes.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/pipes.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp" 3
inline namespace cl {
namespace sycl {
namespace INTEL {

template <class _name, class _dataT, int32_t _min_capacity = 0> class pipe {
public:



  static _dataT read(bool &Success) {
# 33 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp" 3
    (void)Success;
    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 34, __extension__ __PRETTY_FUNCTION__));

  }



  static void write(const _dataT &Data, bool &Success) {






    (void)Success;
    (void)Data;
    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 49, __extension__ __PRETTY_FUNCTION__));

  }




  static _dataT read() {







    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 64, __extension__ __PRETTY_FUNCTION__));

  }



  static void write(const _dataT &Data) {





    (void)Data;
    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 77, __extension__ __PRETTY_FUNCTION__));

  }

private:
  static constexpr int32_t m_Size = sizeof(_dataT);
  static constexpr int32_t m_Alignment = alignof(_dataT);
  static constexpr int32_t m_Capacity = _min_capacity;




};
# 111 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp" 3
template <class _name, class _dataT, size_t _min_capacity = 0>
class kernel_readable_io_pipe {
public:



  static _dataT read(bool &Success) {
# 126 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp" 3
    (void)Success;
    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 127, __extension__ __PRETTY_FUNCTION__));

  }




  static _dataT read() {







    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 142, __extension__ __PRETTY_FUNCTION__));

  }

private:
  static constexpr int32_t m_Size = sizeof(_dataT);
  static constexpr int32_t m_Alignment = alignof(_dataT);
  static constexpr int32_t m_Capacity = _min_capacity;
  static constexpr int32_t ID = _name::id;




};

template <class _name, class _dataT, size_t _min_capacity = 0>
class kernel_writeable_io_pipe {
public:



  static void write(const _dataT &Data, bool &Success) {






    (void)Data;
    (void)Success;
    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 172, __extension__ __PRETTY_FUNCTION__));

  }




  static void write(const _dataT &Data) {





    (void)Data;
    (static_cast <bool> (!"Pipes are not supported on a host device!") ? void (0) : __assert_fail ("!\"Pipes are not supported on a host device!\"", "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/INTEL/pipes.hpp", 186, __extension__ __PRETTY_FUNCTION__));

  }

private:
  static constexpr int32_t m_Size = sizeof(_dataT);
  static constexpr int32_t m_Alignment = alignof(_dataT);
  static constexpr int32_t m_Capacity = _min_capacity;
  static constexpr int32_t ID = _name::id;




};

}
}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/pipes.hpp" 2 3

inline namespace cl {
namespace sycl {
template <class name, class dataT, int32_t min_capacity = 0>
using pipe = INTEL::pipe<name, dataT, min_capacity>;
}
}
# 39 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3



# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/all_properties.hpp" 1 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/context_properties.hpp" 1 3
# 14 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/context_properties.hpp" 3
inline namespace cl {
namespace sycl {
namespace property {
namespace context {
namespace cuda {
class use_primary_context
    : public detail::DataLessProperty<detail::UsePrimaryContext> {};
}
}
}
}
}
# 4 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/all_properties.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/queue_properties.hpp" 1 3
# 13 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/queue_properties.hpp" 3
inline namespace cl {
namespace sycl {
namespace property {
namespace queue {
class in_order : public detail::DataLessProperty<detail::InOrder> {};
class enable_profiling
    : public detail::DataLessProperty<detail::QueueEnableProfiling> {};
}
}
}
}
# 6 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/properties/all_properties.hpp" 2 3
# 43 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 1 3
# 25 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
inline namespace cl {
namespace sycl {


class context;
class device;
namespace detail {
class queue_impl;
}
# 46 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
class __attribute__((visibility("default"))) queue {
public:




  explicit queue(const property_list &PropList = {})
      : queue(default_selector(), async_handler{}, PropList) {}






  queue(const async_handler &AsyncHandler, const property_list &PropList = {})
      : queue(default_selector(), AsyncHandler, PropList) {}






  queue(const device_selector &DeviceSelector,
        const property_list &PropList = {})
      : queue(DeviceSelector.select_device(), async_handler{}, PropList) {}







  queue(const device_selector &DeviceSelector,
        const async_handler &AsyncHandler, const property_list &PropList = {})
      : queue(DeviceSelector.select_device(), AsyncHandler, PropList) {}





  explicit queue(const device &SyclDevice, const property_list &PropList = {})
      : queue(SyclDevice, async_handler{}, PropList) {}







  explicit queue(const device &SyclDevice, const async_handler &AsyncHandler,
                 const property_list &PropList = {});







  queue(const context &SyclContext, const device_selector &DeviceSelector,
        const property_list &PropList = {});
# 115 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  queue(const context &SyclContext, const device_selector &DeviceSelector,
        const async_handler &AsyncHandler, const property_list &PropList = {});







  queue(const context &SyclContext, const device &SyclDevice,
        const property_list &PropList = {});
# 134 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  queue(const context &SyclContext, const device &SyclDevice,
        const async_handler &AsyncHandler, const property_list &PropList = {});
# 145 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  queue(cl_command_queue ClQueue, const context &SyclContext,
        const async_handler &AsyncHandler = {});

  queue(const queue &RHS) = default;

  queue(queue &&RHS) = default;

  queue &operator=(const queue &RHS) = default;

  queue &operator=(queue &&RHS) = default;

  bool operator==(const queue &RHS) const { return impl == RHS.impl; }

  bool operator!=(const queue &RHS) const { return !(*this == RHS); }



  cl_command_queue get() const;


  context get_context() const;


  device get_device() const;


  bool is_host() const;




  template <info::queue param>
  typename info::param_traits<info::queue, param>::return_type get_info() const;







  template <typename T>
  event
  submit(T CGF

         ,
         const detail::code_location &CodeLoc = detail::code_location::current()

  ) {



    return submit_impl(CGF, CodeLoc);
  }
# 210 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename T>
  event
  submit(T CGF, queue &SecondaryQueue

         ,
         const detail::code_location &CodeLoc = detail::code_location::current()

  ) {



    return submit_impl(CGF, SecondaryQueue, CodeLoc);
  }
# 231 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  event submit_barrier(

      const detail::code_location &CodeLoc = detail::code_location::current()

  ) {



    return submit([=](handler &CGH) { CGH.barrier(); }, CodeLoc);
  }
# 251 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  event submit_barrier(
      const vector_class<event> &WaitList

      ,
      const detail::code_location &CodeLoc = detail::code_location::current()

  ) {



    return submit([=](handler &CGH) { CGH.barrier(WaitList); }, CodeLoc);
  }






  void wait(

      const detail::code_location &CodeLoc = detail::code_location::current()

  ) {



    wait_proxy(CodeLoc);
  }
# 288 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  void wait_and_throw(

      const detail::code_location &CodeLoc = detail::code_location::current()

  ) {



    wait_and_throw_proxy(CodeLoc);
  }



  void wait_proxy(const detail::code_location &CodeLoc);


  void wait_and_throw_proxy(const detail::code_location &CodeLoc);






  void throw_asynchronous();



  template <typename PropertyT> bool has_property() const;




  template <typename PropertyT> PropertyT get_property() const;







  template <typename T> event fill(void *Ptr, const T &Pattern, size_t Count) {
    return submit([&](handler &CGH) { CGH.fill<T>(Ptr, Pattern, Count); });
  }
# 341 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  event memset(void *Ptr, int Value, size_t Count);
# 353 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  event memcpy(void *Dest, const void *Src, size_t Count);
# 362 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  event mem_advise(const void *Ptr, size_t Length, pi_mem_advice Advice);







  event prefetch(const void *Ptr, size_t Count) {
    return submit([=](handler &CGH) { CGH.prefetch(Ptr, Count); });
  }
# 408 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event single_task(KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;

    return submit(
        [&](handler &CGH) {
          CGH.template single_task<KernelName, KernelType>(KernelFunc);
        },
        CodeLoc);
  }






  template <typename KernelName = detail::auto_name, typename KernelType>
  event single_task(event DepEvent,
                    KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvent);
          CGH.template single_task<KernelName, KernelType>(KernelFunc);
        },
        CodeLoc);
  }







  template <typename KernelName = detail::auto_name, typename KernelType>
  event single_task(const vector_class<event> &DepEvents,
                    KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvents);
          CGH.template single_task<KernelName, KernelType>(KernelFunc);
        },
        CodeLoc);
  }







  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<1> NumWorkItems,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, KernelFunc, CodeLoc);
  }







  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<2> NumWorkItems,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, KernelFunc, CodeLoc);
  }







  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<3> NumWorkItems,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, KernelFunc, CodeLoc);
  }
# 500 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<1> NumWorkItems, event DepEvent,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, DepEvent, KernelFunc,
                                         CodeLoc);
  }
# 515 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<2> NumWorkItems, event DepEvent,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, DepEvent, KernelFunc,
                                         CodeLoc);
  }
# 530 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<3> NumWorkItems, event DepEvent,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, DepEvent, KernelFunc,
                                         CodeLoc);
  }
# 546 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<1> NumWorkItems,
                     const vector_class<event> &DepEvents,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, DepEvents, KernelFunc,
                                         CodeLoc);
  }
# 563 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<2> NumWorkItems,
                     const vector_class<event> &DepEvents,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, DepEvents, KernelFunc,
                                         CodeLoc);
  }
# 580 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType>
  event parallel_for(range<3> NumWorkItems,
                     const vector_class<event> &DepEvents,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return parallel_for_impl<KernelName>(NumWorkItems, DepEvents, KernelFunc,
                                         CodeLoc);
  }
# 596 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for(range<Dims> NumWorkItems, id<Dims> WorkItemOffset,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.template parallel_for<KernelName, KernelType>(
              NumWorkItems, WorkItemOffset, KernelFunc);
        },
        CodeLoc);
  }
# 617 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for(range<Dims> NumWorkItems, id<Dims> WorkItemOffset,
                     event DepEvent,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvent);
          CGH.template parallel_for<KernelName, KernelType>(
              NumWorkItems, WorkItemOffset, KernelFunc);
        },
        CodeLoc);
  }
# 641 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for(range<Dims> NumWorkItems, id<Dims> WorkItemOffset,
                     const vector_class<event> &DepEvents,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvents);
          CGH.template parallel_for<KernelName, KernelType>(
              NumWorkItems, WorkItemOffset, KernelFunc);
        },
        CodeLoc);
  }
# 663 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for(nd_range<Dims> ExecutionRange,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.template parallel_for<KernelName, KernelType>(ExecutionRange,
                                                            KernelFunc);
        },
        CodeLoc);
  }
# 684 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for(nd_range<Dims> ExecutionRange, event DepEvent,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvent);
          CGH.template parallel_for<KernelName, KernelType>(ExecutionRange,
                                                            KernelFunc);
        },
        CodeLoc);
  }
# 707 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for(nd_range<Dims> ExecutionRange,
                     const vector_class<event> &DepEvents,
                     KernelType KernelFunc , const detail::code_location &CodeLoc = detail::code_location::current()) {
                         ;
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvents);
          CGH.template parallel_for<KernelName, KernelType>(ExecutionRange,
                                                            KernelFunc);
        },
        CodeLoc);
  }
# 730 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  bool is_in_order() const;




  template <backend BackendName>
  auto get_native() const -> typename interop<BackendName, queue>::type {
    return reinterpret_cast<typename interop<BackendName, queue>::type>(
        getNative());
  }

private:
  pi_native_handle getNative() const;

  shared_ptr_class<detail::queue_impl> impl;
  queue(shared_ptr_class<detail::queue_impl> impl) : impl(impl) {}

  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);
  template <class T>
  friend T detail::createSyclObjFromImpl(decltype(T::impl) ImplObj);


  event submit_impl(function_class<void(handler &)> CGH,
                    const detail::code_location &CodeLoc);

  event submit_impl(function_class<void(handler &)> CGH, queue secondQueue,
                    const detail::code_location &CodeLoc);







  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for_impl(
      range<Dims> NumWorkItems, KernelType KernelFunc,
      const detail::code_location &CodeLoc = detail::code_location::current()) {
    return submit(
        [&](handler &CGH) {
          CGH.template parallel_for<KernelName, KernelType>(NumWorkItems,
                                                            KernelFunc);
        },
        CodeLoc);
  }
# 785 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for_impl(range<Dims> NumWorkItems, event DepEvent,
                          KernelType KernelFunc,
                          const detail::code_location &CodeLoc) {
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvent);
          CGH.template parallel_for<KernelName, KernelType>(NumWorkItems,
                                                            KernelFunc);
        },
        CodeLoc);
  }
# 807 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/queue.hpp" 3
  template <typename KernelName = detail::auto_name, typename KernelType,
            int Dims>
  event parallel_for_impl(range<Dims> NumWorkItems,
                          const vector_class<event> &DepEvents,
                          KernelType KernelFunc,
                          const detail::code_location &CodeLoc) {
    return submit(
        [&](handler &CGH) {
          CGH.depends_on(DepEvents);
          CGH.template parallel_for<KernelName, KernelType>(NumWorkItems,
                                                            KernelFunc);
        },
        CodeLoc);
  }
};

}
}

namespace std {
template <> struct hash<cl::sycl::queue> {
  size_t operator()(const cl::sycl::queue &Q) const {
    return std::hash<
        cl::sycl::shared_ptr_class<cl::sycl::detail::queue_impl>>()(
        cl::sycl::detail::getSyclObjImpl(Q));
  }
};
}
# 44 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3


# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stream.hpp" 1 3
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stream.hpp" 3
inline namespace cl {
namespace sycl {

namespace detail {

using FmtFlags = unsigned int;



static constexpr FmtFlags Dec = 0x0001;
static constexpr FmtFlags Hex = 0x0002;
static constexpr FmtFlags Oct = 0x0004;
static constexpr FmtFlags ShowBase = 0x0008;
static constexpr FmtFlags ShowPos = 0x0010;
static constexpr FmtFlags Fixed = 0x0020;
static constexpr FmtFlags Scientific = 0x0040;




static constexpr FmtFlags BaseField = Dec | Hex | Oct;




static constexpr FmtFlags FloatField = Scientific | Fixed;

constexpr size_t MAX_FLOATING_POINT_DIGITS = 24;
constexpr size_t MAX_INTEGRAL_DIGITS = 23;
constexpr const char *VEC_ELEMENT_DELIMITER = ", ";
constexpr char VEC_OPEN_BRACE = '{';
constexpr char VEC_CLOSE_BRACE = '}';

constexpr size_t MAX_DIMENSIONS = 3;



constexpr size_t MAX_ARRAY_SIZE =
    MAX_INTEGRAL_DIGITS * MAX_DIMENSIONS + 2 * (MAX_DIMENSIONS - 1) + 2;

template <class F, class T = void>
using EnableIfFP = typename std::enable_if<std::is_same<F, float>::value ||
                                               std::is_same<F, double>::value ||
                                               std::is_same<F, half>::value,
                                           T>::type;

using GlobalBufAccessorT = accessor<char, 1, cl::sycl::access::mode::read_write,
                                    cl::sycl::access::target::global_buffer,
                                    cl::sycl::access::placeholder::false_t>;

using GlobalOffsetAccessorT =
    accessor<unsigned, 1, cl::sycl::access::mode::atomic,
             cl::sycl::access::target::global_buffer,
             cl::sycl::access::placeholder::false_t>;

inline void write(GlobalBufAccessorT &GlobalFlushBuf, size_t FlushBufferSize,
                  unsigned WIOffset, unsigned &Offset, const char *Str,
                  unsigned Len, unsigned Padding = 0) {
  if ((FlushBufferSize - Offset < Len + Padding) ||
      (WIOffset + Offset + Len + Padding > GlobalFlushBuf.get_count()))

    return;


  for (size_t I = 0; I < Padding; ++I, ++Offset)
    GlobalFlushBuf[WIOffset + Offset] = ' ';

  for (size_t I = 0; I < Len; ++I, ++Offset) {
    GlobalFlushBuf[WIOffset + Offset] = Str[I];
  }
}

inline void reverseBuf(char *Buf, unsigned Len) {
  int I = Len - 1;
  int J = 0;
  while (I > J) {
    int Temp = Buf[I];
    Buf[I] = Buf[J];
    Buf[J] = Temp;
    I--;
    J++;
  }
}

template <typename T>
inline typename std::make_unsigned<T>::type getAbsVal(const T Val,
                                                      const int Base) {
  return ((Base == 10) && (Val < 0)) ? -Val : Val;
}

inline char digitToChar(const int Digit) {
  if (Digit < 10) {
    return '0' + Digit;
  } else {
    return 'a' + Digit - 10;
  }
}

template <typename T>
inline typename std::enable_if<std::is_integral<T>::value, unsigned>::type
integralToBase(T Val, int Base, char *Digits) {
  unsigned NumDigits = 0;

  do {
    Digits[NumDigits++] = digitToChar(Val % Base);
    Val /= Base;
  } while (Val);

  return NumDigits;
}


template <typename T>
inline typename std::enable_if<std::is_integral<T>::value, unsigned>::type
ScalarToStr(const T &Val, char *Buf, unsigned Flags, int, int Precision = -1) {
  (void)Precision;
  int Base = 10;


  switch (Flags & BaseField) {
  case Dec:
    Base = 10;
    break;
  case Hex:
    Base = 16;
    break;
  case Oct:
    Base = 8;
    break;
  default:

    break;
  }

  unsigned Offset = 0;



  if (Base == 10) {
    if ((Flags & ShowPos) && Val >= 0)
      Buf[Offset++] = '+';
    else if (Val < 0)
      Buf[Offset++] = '-';
  }


  if (Base != 10 && (Flags & ShowBase)) {
    Buf[Offset++] = '0';
    if (Base == 16)
      Buf[Offset++] = 'x';
  }

  auto AbsVal = getAbsVal(Val, Base);

  const unsigned NumBuf = integralToBase(AbsVal, Base, Buf + Offset);

  reverseBuf(Buf + Offset, NumBuf);
  return Offset + NumBuf;
}

inline unsigned append(char *Dst, const char *Src) {
  unsigned Len = 0;
  for (; Src[Len] != '\0'; ++Len)
    ;

  for (unsigned I = 0; I < Len; ++I)
    Dst[I] = Src[I];
  return Len;
}

template <typename T>
inline typename std::enable_if<std::is_same<T, float>::value ||
                                   std::is_same<T, double>::value,
                               unsigned>::type
checkForInfNan(char *Buf, T Val) {
  if (isnan(Val))
    return append(Buf, "nan");
  if (isinf(Val)) {
    if (signbit(Val))
      return append(Buf, "-inf");
    return append(Buf, "inf");
  }
  return 0;
}

template <typename T>
inline typename std::enable_if<std::is_same<T, half>::value, unsigned>::type
checkForInfNan(char *Buf, T Val) {
  if (Val != Val)
    return append(Buf, "nan");


  const uint16_t Sign = reinterpret_cast<uint16_t &>(Val) & 0x8000;

  const uint16_t Exp16 = (reinterpret_cast<uint16_t &>(Val) & 0x7c00) >> 10;

  if (Exp16 == 0x1f) {
    if (Sign)
      return append(Buf, "-inf");
    return append(Buf, "inf");
  }
  return 0;
}

template <typename T>
EnableIfFP<T, unsigned> floatingPointToDecStr(T AbsVal, char *Digits,
                                              int Precision, bool IsSci) {
  int Exp = 0;


  while (AbsVal >= 10.0) {
    ++Exp;
    AbsVal /= 10.0;
  }

  while (AbsVal > 0.0 && AbsVal < 1.0) {
    --Exp;
    AbsVal *= 10.0;
  }

  auto IntegralPart = static_cast<int>(AbsVal);
  auto FractionPart = AbsVal - IntegralPart;

  int FractionDigits[MAX_FLOATING_POINT_DIGITS] = {0};


  int P = Precision > 0 ? Precision : 4;
  size_t FractionLength = Exp + P;





  if (FractionLength > MAX_FLOATING_POINT_DIGITS - 5)
    FractionLength = MAX_FLOATING_POINT_DIGITS - 5;

  for (unsigned I = 0; I < FractionLength; ++I) {
    FractionPart *= 10.0;
    FractionDigits[I] = static_cast<int>(FractionPart);
    FractionPart -= static_cast<int>(FractionPart);
  }

  int Carry = FractionPart > static_cast<T>(0.5) ? 1 : 0;


  for (int I = FractionLength - 1; I >= 0 && Carry; --I) {
    auto Digit = FractionDigits[I] + Carry;
    FractionDigits[I] = Digit % 10;
    Carry = Digit / 10;
  }


  IntegralPart += Carry;
  if (IntegralPart == 10) {
    IntegralPart = 1;
    ++Exp;
  }

  unsigned Offset = 0;


  if (IsSci) {

    Digits[Offset++] = digitToChar(IntegralPart);
    Digits[Offset++] = '.';


    for (unsigned I = 0; I < FractionLength; ++I)
      Digits[Offset++] = digitToChar(FractionDigits[I]);


    Digits[Offset++] = 'e';
    Digits[Offset++] = Exp >= 0 ? '+' : '-';
    Digits[Offset++] = digitToChar(abs(Exp) / 10);
    Digits[Offset++] = digitToChar(abs(Exp) % 10);
  } else {
    if (Exp < 0) {
      Digits[Offset++] = '0';
      Digits[Offset++] = '.';
      while (++Exp)
        Digits[Offset++] = '0';


      Digits[Offset++] = digitToChar(IntegralPart);


      for (unsigned I = 0; I < FractionLength; ++I)
        Digits[Offset++] = digitToChar(FractionDigits[I]);
    } else {

      Digits[Offset++] = digitToChar(IntegralPart);
      unsigned I = 0;

      for (; I < FractionLength && Exp--; ++I)
        Digits[Offset++] = digitToChar(FractionDigits[I]);


      Digits[Offset++] = '.';


      for (; I < FractionLength; ++I)
        Digits[Offset++] = digitToChar(FractionDigits[I]);
    }


    while (Digits[Offset - 1] == '0')
      Offset--;


    if (Digits[Offset - 1] == '.')
      Offset--;
  }
  return Offset;
}


template <typename T>
inline EnableIfFP<T, unsigned>
ScalarToStr(const T &Val, char *Buf, unsigned Flags, int, int Precision = -1) {
  unsigned Offset = checkForInfNan(Buf, Val);
  if (Offset)
    return Offset;

  T Neg = -Val;
  auto AbsVal = Val < 0 ? Neg : Val;

  if (Val < 0) {
    Buf[Offset++] = '-';
  } else if (Flags & ShowPos) {
    Buf[Offset++] = '+';
  }

  bool IsSci = false;
  if (Flags & detail::Scientific)
    IsSci = true;


  Offset += floatingPointToDecStr(AbsVal, Buf + Offset, Precision, IsSci);

  return Offset;
}

template <typename T>
inline typename std::enable_if<std::is_integral<T>::value>::type
writeIntegral(GlobalBufAccessorT &GlobalFlushBuf, size_t FlushBufferSize,
              unsigned WIOffset, unsigned &Offset, unsigned Flags, int Width,
              const T &Val) {
  char Digits[MAX_INTEGRAL_DIGITS] = {0};
  unsigned Len = ScalarToStr(Val, Digits, Flags, Width);
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Digits, Len,
        (Width > 0 && static_cast<unsigned>(Width) > Len)
            ? static_cast<unsigned>(Width) - Len
            : 0);
}

template <typename T>
inline EnableIfFP<T>
writeFloatingPoint(GlobalBufAccessorT &GlobalFlushBuf, size_t FlushBufferSize,
                   unsigned WIOffset, unsigned &Offset, unsigned Flags,
                   int Width, int Precision, const T &Val) {
  char Digits[MAX_FLOATING_POINT_DIGITS] = {0};
  unsigned Len = ScalarToStr(Val, Digits, Flags, Width, Precision);
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Digits, Len,
        (Width > 0 && static_cast<unsigned>(Width) > Len)
            ? static_cast<unsigned>(Width) - Len
            : 0);
}




inline bool updateOffset(GlobalOffsetAccessorT &GlobalOffset,
                         GlobalBufAccessorT &GlobalBuf, unsigned Size,
                         unsigned &Cur) {
  unsigned New;
  Cur = GlobalOffset[0].load();
  do {
    if (GlobalBuf.get_range().size() - Cur < Size)

      return false;
    New = Cur + Size;
  } while (!GlobalOffset[0].compare_exchange_strong(Cur, New));
  return true;
}

inline void flushBuffer(GlobalOffsetAccessorT &GlobalOffset,
                        GlobalBufAccessorT &GlobalBuf,
                        GlobalBufAccessorT &GlobalFlushBuf, unsigned &WIOffset,
                        unsigned &Offset) {

  unsigned Cur = 0;
  if (!updateOffset(GlobalOffset, GlobalBuf, Offset, Cur))
    return;

  for (unsigned I = WIOffset; I < WIOffset + Offset; I++) {
    GlobalBuf[Cur++] = GlobalFlushBuf[I];
  }

  Offset = 0;
}

template <typename T, int VecLength>
typename std::enable_if<(VecLength == 1), unsigned>::type
VecToStr(const vec<T, VecLength> &Vec, char *VecStr, unsigned Flags, int Width,
         int Precision) {
  return ScalarToStr(static_cast<T>(Vec.x()), VecStr, Flags, Width, Precision);
}

template <typename T, int VecLength>
typename std::enable_if<(VecLength == 2 || VecLength == 4 || VecLength == 8 ||
                         VecLength == 16),
                        unsigned>::type
VecToStr(const vec<T, VecLength> &Vec, char *VecStr, unsigned Flags, int Width,
         int Precision) {
  unsigned Len =
      VecToStr<T, VecLength / 2>(Vec.lo(), VecStr, Flags, Width, Precision);
  Len += append(VecStr + Len, VEC_ELEMENT_DELIMITER);
  Len += VecToStr<T, VecLength / 2>(Vec.hi(), VecStr + Len, Flags, Width,
                                    Precision);
  return Len;
}

template <typename T, int VecLength>
typename std::enable_if<(VecLength == 3), unsigned>::type
VecToStr(const vec<T, VecLength> &Vec, char *VecStr, unsigned Flags, int Width,
         int Precision) {
  unsigned Len = VecToStr<T, 2>(Vec.lo(), VecStr, Flags, Width, Precision);
  Len += append(VecStr + Len, VEC_ELEMENT_DELIMITER);
  Len += VecToStr<T, 1>(Vec.z(), VecStr + Len, Flags, Width, Precision);
  return Len;
}

template <typename T, int VecLength>
inline void writeVec(GlobalBufAccessorT &GlobalFlushBuf, size_t FlushBufferSize,
                     unsigned WIOffset, unsigned &Offset, unsigned Flags,
                     int Width, int Precision, const vec<T, VecLength> &Vec) {

  constexpr size_t MAX_VEC_SIZE =
      MAX_FLOATING_POINT_DIGITS * VecLength + (VecLength - 1) * 2;
  char VecStr[MAX_VEC_SIZE] = {0};
  unsigned Len = VecToStr<T, VecLength>(Vec, VecStr, Flags, Width, Precision);
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, VecStr, Len,
        (Width > 0 && Width > Len) ? Width - Len : 0);
}

template <int ArrayLength>
inline unsigned ArrayToStr(char *Buf, const array<ArrayLength> &Arr) {
  unsigned Len = 0;
  Buf[Len++] = VEC_OPEN_BRACE;

  for (int I = 0; I < ArrayLength; ++I) {
    Len += ScalarToStr(Arr[I], Buf + Len, 0 , -1, -1);
    if (I != ArrayLength - 1)
      Len += append(Buf + Len, VEC_ELEMENT_DELIMITER);
  }

  Buf[Len++] = VEC_CLOSE_BRACE;

  return Len;
}

template <int ArrayLength>
inline void writeArray(GlobalBufAccessorT &GlobalFlushBuf,
                       size_t FlushBufferSize, unsigned WIOffset,
                       unsigned &Offset, const array<ArrayLength> &Arr) {
  char Buf[MAX_ARRAY_SIZE];
  unsigned Len = ArrayToStr(Buf, Arr);
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Buf, Len);
}

template <int Dimensions>
inline void writeItem(GlobalBufAccessorT &GlobalFlushBuf,
                      size_t FlushBufferSize, unsigned WIOffset,
                      unsigned &Offset, const item<Dimensions> &Item) {


  char Buf[3 * MAX_ARRAY_SIZE + 40];
  unsigned Len = 0;
  Len += append(Buf, "item(");
  Len += append(Buf + Len, "range: ");
  Len += ArrayToStr(Buf + Len, Item.get_range());
  Len += append(Buf + Len, ", id: ");
  Len += ArrayToStr(Buf + Len, Item.get_id());
  Len += append(Buf + Len, ", offset: ");
  Len += ArrayToStr(Buf + Len, Item.get_offset());
  Buf[Len++] = ')';
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Buf, Len);
}

template <int Dimensions>
inline void writeNDRange(GlobalBufAccessorT &GlobalFlushBuf,
                         size_t FlushBufferSize, unsigned WIOffset,
                         unsigned &Offset,
                         const nd_range<Dimensions> &ND_Range) {


  char Buf[3 * MAX_ARRAY_SIZE + 50];
  unsigned Len = 0;
  Len += append(Buf, "nd_range(");
  Len += append(Buf + Len, "global_range: ");
  Len += ArrayToStr(Buf + Len, ND_Range.get_global_range());
  Len += append(Buf + Len, ", local_range: ");
  Len += ArrayToStr(Buf + Len, ND_Range.get_local_range());
  Len += append(Buf + Len, ", offset: ");
  Len += ArrayToStr(Buf + Len, ND_Range.get_offset());
  Buf[Len++] = ')';
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Buf, Len);
}

template <int Dimensions>
inline void writeNDItem(GlobalBufAccessorT &GlobalFlushBuf,
                        size_t FlushBufferSize, unsigned WIOffset,
                        unsigned &Offset, const nd_item<Dimensions> &ND_Item) {


  char Buf[2 * MAX_ARRAY_SIZE + 40];
  unsigned Len = 0;
  Len += append(Buf, "nd_item(");
  Len += append(Buf + Len, "global_id: ");
  Len += ArrayToStr(Buf + Len, ND_Item.get_global_id());
  Len += append(Buf + Len, ", local_id: ");
  Len += ArrayToStr(Buf + Len, ND_Item.get_local_id());
  Buf[Len++] = ')';
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Buf, Len);
}

template <int Dimensions>
inline void writeGroup(GlobalBufAccessorT &GlobalFlushBuf,
                       size_t FlushBufferSize, unsigned WIOffset,
                       unsigned &Offset, const group<Dimensions> &Group) {


  char Buf[4 * MAX_ARRAY_SIZE + 60];
  unsigned Len = 0;
  Len += append(Buf, "group(");
  Len += append(Buf + Len, "id: ");
  Len += ArrayToStr(Buf + Len, Group.get_id());
  Len += append(Buf + Len, ", global_range: ");
  Len += ArrayToStr(Buf + Len, Group.get_global_range());
  Len += append(Buf + Len, ", local_range: ");
  Len += ArrayToStr(Buf + Len, Group.get_local_range());
  Len += append(Buf + Len, ", group_range: ");
  Len += ArrayToStr(Buf + Len, Group.get_group_range());
  Buf[Len++] = ')';
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Buf, Len);
}



constexpr size_t MAX_ITEM_SIZE = 2 * MAX_ARRAY_SIZE + 20;

template <int Dimensions>
inline unsigned ItemToStr(char *Buf, const item<Dimensions, false> &Item) {
  unsigned Len = 0;
  Len += append(Buf, "item(");
  for (int I = 0; I < 2; ++I) {
    Len += append(Buf + Len, I == 0 ? "range: " : ", id: ");
    Len += ArrayToStr(Buf + Len, I == 0 ? Item.get_range() : Item.get_id());
  }
  Buf[Len++] = ')';
  return Len;
}

template <int Dimensions>
inline void writeHItem(GlobalBufAccessorT &GlobalFlushBuf,
                       size_t FlushBufferSize, unsigned WIOffset,
                       unsigned &Offset, const h_item<Dimensions> &HItem) {


  char Buf[3 * MAX_ITEM_SIZE + 60];
  unsigned Len = 0;
  Len += append(Buf, "h_item(");
  for (int I = 0; I < 3; ++I) {
    Len += append(Buf + Len, I == 0 ? "\n  global "
                                    : I == 1 ? "\n  logical local "
                                             : "\n  physical local ");
    Len += ItemToStr(Buf + Len, I == 0 ? HItem.get_global()
                                       : I == 1 ? HItem.get_logical_local()
                                                : HItem.get_physical_local());
  }
  Len += append(Buf + Len, "\n)");
  write(GlobalFlushBuf, FlushBufferSize, WIOffset, Offset, Buf, Len);
}

template <typename> struct IsSwizzleOp : std::false_type {};

template <typename VecT, typename OperationLeftT, typename OperationRightT,
          template <typename> class OperationCurrentT, int... Indexes>
struct IsSwizzleOp<cl::sycl::detail::SwizzleOp<
    VecT, OperationLeftT, OperationRightT, OperationCurrentT, Indexes...>>
    : std::true_type {
  using T = typename VecT::element_type;
  using Type = typename cl::sycl::vec<T, (sizeof...(Indexes))>;
};

template <typename T>
using EnableIfSwizzleVec =
    typename std::enable_if<IsSwizzleOp<T>::value,
                            typename IsSwizzleOp<T>::Type>::type;

}

enum class stream_manipulator {
  dec,
  hex,
  oct,
  noshowbase,
  showbase,
  noshowpos,
  showpos,
  endl,
  flush,
  fixed,
  scientific,
  hexfloat,
  defaultfloat
};

constexpr stream_manipulator dec = stream_manipulator::dec;

constexpr stream_manipulator hex = stream_manipulator::hex;

constexpr stream_manipulator oct = stream_manipulator::oct;

constexpr stream_manipulator noshowbase = stream_manipulator::noshowbase;

constexpr stream_manipulator showbase = stream_manipulator::showbase;

constexpr stream_manipulator noshowpos = stream_manipulator::noshowpos;

constexpr stream_manipulator showpos = stream_manipulator::showpos;

constexpr stream_manipulator endl = stream_manipulator::endl;

constexpr stream_manipulator flush = stream_manipulator::flush;

constexpr stream_manipulator fixed = stream_manipulator::fixed;

constexpr stream_manipulator scientific = stream_manipulator::scientific;

constexpr stream_manipulator hexfloat = stream_manipulator::hexfloat;

constexpr stream_manipulator defaultfloat = stream_manipulator::defaultfloat;

class stream;

class __precision_manipulator__ {
  int Precision_;

public:
  __precision_manipulator__(int Precision) : Precision_(Precision) {}

  int precision() const { return Precision_; }

  friend const stream &operator<<(const stream &,
                                  const __precision_manipulator__ &);
};

class __width_manipulator__ {
  int Width_;

public:
  __width_manipulator__(int Width) : Width_(Width) {}

  int width() const { return Width_; }

  friend const stream &operator<<(const stream &,
                                  const __width_manipulator__ &);
};

inline __precision_manipulator__ setprecision(int Precision) {
  return __precision_manipulator__(Precision);
}

inline __width_manipulator__ setw(int Width) {
  return __width_manipulator__(Width);
}





class __attribute__((visibility("default"))) stream {
public:
  stream(size_t BufferSize, size_t MaxStatementSize, handler &CGH);

  size_t get_size() const;

  size_t get_max_statement_size() const;

  size_t get_precision() const { return Precision; }

  size_t get_width() const { return Width; }

  stream_manipulator get_stream_mode() const { return Manipulator; }

  bool operator==(const stream &RHS) const;

  bool operator!=(const stream &LHS) const;

private:



  std::shared_ptr<detail::stream_impl> impl;
  template <class Obj>
  friend decltype(Obj::impl) detail::getSyclObjImpl(const Obj &SyclObject);




  mutable detail::GlobalBufAccessorT GlobalBuf;




  mutable detail::GlobalOffsetAccessorT GlobalOffset;



  mutable detail::GlobalBufAccessorT GlobalFlushBuf;


  mutable unsigned WIOffset = 0;


  mutable unsigned Offset = 0;

  mutable size_t FlushBufferSize;


  mutable stream_manipulator Manipulator = defaultfloat;


  using FmtFlags = unsigned int;

  mutable int Precision = -1;
  mutable int Width = -1;
  mutable FmtFlags Flags = 0x0;

  void set_flag(FmtFlags FormatFlag) const { Flags |= FormatFlag; }

  void unset_flag(FmtFlags FormatFlag) const { Flags &= ~FormatFlag; }

  FmtFlags get_flags() const { return Flags; }




  void set_flag(FmtFlags FormatFlag, FmtFlags Mask) const {
    unset_flag(Mask);
    Flags |= FormatFlag & Mask;
  }


  void set_manipulator(const stream_manipulator SM) const {
    switch (SM) {
    case stream_manipulator::dec:
      set_flag(detail::Dec, detail::BaseField);
      break;
    case stream_manipulator::hex:
      set_flag(detail::Hex, detail::BaseField);
      break;
    case stream_manipulator::oct:
      set_flag(detail::Oct, detail::BaseField);
      break;
    case stream_manipulator::noshowbase:
      unset_flag(detail::ShowBase);
      break;
    case stream_manipulator::showbase:
      set_flag(detail::ShowBase);
      break;
    case stream_manipulator::noshowpos:
      unset_flag(detail::ShowPos);
      break;
    case stream_manipulator::showpos:
      set_flag(detail::ShowPos);
      break;
    case stream_manipulator::fixed:
      set_flag(detail::Fixed, detail::FloatField);
      break;
    case stream_manipulator::scientific:
      set_flag(detail::Scientific, detail::FloatField);
      break;
    case stream_manipulator::hexfloat:
      set_flag(detail::Fixed | detail::Scientific, detail::FloatField);
      break;
    case stream_manipulator::defaultfloat:
      unset_flag(detail::FloatField);
      break;
    default:

      break;
    }
  }
# 836 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/stream.hpp" 3
  friend const stream &operator<<(const stream &, const char);
  friend const stream &operator<<(const stream &, const char *);
  template <typename ValueType>
  friend typename std::enable_if<std::is_integral<ValueType>::value,
                                 const stream &>::type
  operator<<(const stream &, const ValueType &);
  friend const stream &operator<<(const stream &, const float &);
  friend const stream &operator<<(const stream &, const double &);
  friend const stream &operator<<(const stream &, const half &);

  friend const stream &operator<<(const stream &, const stream_manipulator);

  friend const stream &operator<<(const stream &Out,
                                  const __precision_manipulator__ &RHS);

  friend const stream &operator<<(const stream &Out,
                                  const __width_manipulator__ &RHS);
  template <typename T, int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const vec<T, Dimensions> &RHS);
  template <typename T>
  friend const stream &operator<<(const stream &Out, const T *RHS);
  template <int Dimensions>
  friend const stream &operator<<(const stream &Out, const id<Dimensions> &RHS);

  template <int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const range<Dimensions> &RHS);

  template <int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const item<Dimensions> &RHS);

  template <int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const nd_range<Dimensions> &RHS);

  template <int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const nd_item<Dimensions> &RHS);

  template <int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const group<Dimensions> &RHS);

  template <int Dimensions>
  friend const stream &operator<<(const stream &Out,
                                  const h_item<Dimensions> &RHS);
};


inline const stream &operator<<(const stream &Out, const char C) {
  if (Out.Offset >= Out.FlushBufferSize ||
      Out.WIOffset + Out.Offset + 1 > Out.GlobalFlushBuf.get_count())
    return Out;
  Out.GlobalFlushBuf[Out.WIOffset + Out.Offset] = C;
  ++Out.Offset;
  return Out;
}


inline const stream &operator<<(const stream &Out, const char *Str) {
  unsigned Len = 0;
  for (; Str[Len] != '\0'; Len++)
    ;

  detail::write(Out.GlobalFlushBuf, Out.FlushBufferSize, Out.WIOffset,
                Out.Offset, Str, Len);
  return Out;
}


inline const stream &operator<<(const stream &Out, const bool &RHS) {
  Out << (RHS ? "true" : "false");
  return Out;
}


template <typename ValueType>
inline typename std::enable_if<std::is_integral<ValueType>::value,
                               const stream &>::type
operator<<(const stream &Out, const ValueType &RHS) {
  detail::writeIntegral(Out.GlobalFlushBuf, Out.FlushBufferSize, Out.WIOffset,
                        Out.Offset, Out.get_flags(), Out.get_width(), RHS);
  return Out;
}



inline const stream &operator<<(const stream &Out, const float &RHS) {
  detail::writeFloatingPoint<float>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                    Out.WIOffset, Out.Offset, Out.get_flags(),
                                    Out.get_width(), Out.get_precision(), RHS);
  return Out;
}

inline const stream &operator<<(const stream &Out, const double &RHS) {
  detail::writeFloatingPoint<double>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                     Out.WIOffset, Out.Offset, Out.get_flags(),
                                     Out.get_width(), Out.get_precision(), RHS);
  return Out;
}

inline const stream &operator<<(const stream &Out, const half &RHS) {
  detail::writeFloatingPoint<half>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                   Out.WIOffset, Out.Offset, Out.get_flags(),
                                   Out.get_width(), Out.get_precision(), RHS);
  return Out;
}



template <typename ElementType, access::address_space Space>
inline const stream &operator<<(const stream &Out,
                                const multi_ptr<ElementType, Space> &RHS) {
  Out << RHS.get();
  return Out;
}

template <typename T>
const stream &operator<<(const stream &Out, const T *RHS) {
  detail::FmtFlags Flags = Out.get_flags();
  Flags &= ~detail::BaseField;
  Flags |= detail::Hex | detail::ShowBase;
  detail::writeIntegral(Out.GlobalFlushBuf, Out.FlushBufferSize, Out.WIOffset,
                        Out.Offset, Flags, Out.get_width(),
                        reinterpret_cast<size_t>(RHS));
  return Out;
}



inline const stream &operator<<(const stream &Out,
                                const __precision_manipulator__ &RHS) {
  Out.Precision = RHS.precision();
  return Out;
}

inline const stream &operator<<(const stream &Out,
                                const __width_manipulator__ &RHS) {
  Out.Width = RHS.width();
  return Out;
}

inline const stream &operator<<(const stream &Out,
                                const stream_manipulator RHS) {
  switch (RHS) {
  case stream_manipulator::endl:
    Out << '\n';
    flushBuffer(Out.GlobalOffset, Out.GlobalBuf, Out.GlobalFlushBuf,
                Out.WIOffset, Out.Offset);
    break;
  case stream_manipulator::flush:
    flushBuffer(Out.GlobalOffset, Out.GlobalBuf, Out.GlobalFlushBuf,
                Out.WIOffset, Out.Offset);
    break;
  default:
    Out.set_manipulator(RHS);
    break;
  }
  return Out;
}



template <typename T, int VectorLength>
const stream &operator<<(const stream &Out, const vec<T, VectorLength> &RHS) {
  detail::writeVec<T, VectorLength>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                    Out.WIOffset, Out.Offset, Out.get_flags(),
                                    Out.get_width(), Out.get_precision(), RHS);
  return Out;
}



template <int Dimensions>
inline const stream &operator<<(const stream &Out, const id<Dimensions> &RHS) {
  detail::writeArray<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                 Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <int Dimensions>
inline const stream &operator<<(const stream &Out,
                                const range<Dimensions> &RHS) {
  detail::writeArray<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                 Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <int Dimensions>
inline const stream &operator<<(const stream &Out,
                                const item<Dimensions> &RHS) {
  detail::writeItem<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <int Dimensions>
inline const stream &operator<<(const stream &Out,
                                const nd_range<Dimensions> &RHS) {
  detail::writeNDRange<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                   Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <int Dimensions>
inline const stream &operator<<(const stream &Out,
                                const nd_item<Dimensions> &RHS) {
  detail::writeNDItem<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                  Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <int Dimensions>
inline const stream &operator<<(const stream &Out,
                                const group<Dimensions> &RHS) {
  detail::writeGroup<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                 Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <int Dimensions>
inline const stream &operator<<(const stream &Out,
                                const h_item<Dimensions> &RHS) {
  detail::writeHItem<Dimensions>(Out.GlobalFlushBuf, Out.FlushBufferSize,
                                 Out.WIOffset, Out.Offset, RHS);
  return Out;
}

template <typename T, typename RT = detail::EnableIfSwizzleVec<T>>
inline const stream &operator<<(const stream &Out, const T &RHS) {
  RT V = RHS;
  Out << V;
  return Out;
}

}
}
namespace std {
template <> struct hash<cl::sycl::stream> {
  size_t operator()(const cl::sycl::stream &S) const {




    return hash<std::shared_ptr<cl::sycl::detail::stream_impl>>()(
        cl::sycl::detail::getSyclObjImpl(S));

  }
};
}
# 47 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3

# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm.hpp" 1 3
# 11 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm/usm_allocator.hpp" 1 3
# 15 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm/usm_allocator.hpp" 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm/usm_enums.hpp" 1 3
# 10 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm/usm_enums.hpp" 3
inline namespace cl {
namespace sycl {
namespace usm {

enum class alloc { host, device, shared, unknown };

}
}
}
# 16 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm/usm_allocator.hpp" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/cstdlib" 3
# 18 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm/usm_allocator.hpp" 2 3


inline namespace cl {
namespace sycl {


__attribute__((visibility("default"))) void *aligned_alloc(size_t alignment, size_t size,
                                  const device &dev, const context &ctxt,
                                  usm::alloc kind);
__attribute__((visibility("default"))) void free(void *ptr, const context &ctxt);

template <typename T, usm::alloc AllocKind, size_t Alignment = alignof(T)>
class usm_allocator {
public:
  using value_type = T;
  using propagate_on_container_copy_assignment = std::true_type;
  using propagate_on_container_move_assignment = std::true_type;
  using propagate_on_container_swap = std::true_type;

public:
  template <typename U> struct rebind {
    typedef usm_allocator<U, AllocKind, Alignment> other;
  };

  static_assert(
      AllocKind != usm::alloc::device,
      "usm_allocator does not support AllocKind == usm::alloc::device");

  usm_allocator() noexcept = delete;
  usm_allocator(const context &Ctxt, const device &Dev) noexcept
      : MContext(Ctxt), MDevice(Dev) {}
  usm_allocator(const queue &Q) noexcept
      : MContext(Q.get_context()), MDevice(Q.get_device()) {}
  usm_allocator(const usm_allocator &) noexcept = default;
  usm_allocator(usm_allocator &&) noexcept = default;
  usm_allocator &operator=(const usm_allocator &) = delete;
  usm_allocator &operator=(usm_allocator &&) = default;

  template <class U>
  usm_allocator(const usm_allocator<U, AllocKind, Alignment> &Other) noexcept
      : MContext(Other.MContext), MDevice(Other.MDevice) {}




  T *allocate(size_t NumberOfElements) {

    auto Result = reinterpret_cast<T *>(
        aligned_alloc(getAlignment(), NumberOfElements * sizeof(value_type),
                      MDevice, MContext, AllocKind));
    if (!Result) {
      throw memory_allocation_error();
    }
    return Result;
  }





  void deallocate(T *Ptr, size_t) {
    if (Ptr) {
      free(Ptr, MContext);
    }
  }

  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend bool operator==(const usm_allocator<T, AllocKind, Alignment> &One,
                         const usm_allocator<U, AllocKindU, AlignmentU> &Two) {
    return ((AllocKind == AllocKindU) && (One.MContext == Two.MContext) &&
            (One.MDevice == Two.MDevice));
  }

  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend bool operator!=(const usm_allocator<T, AllocKind, Alignment> &One,
                         const usm_allocator<U, AllocKindU, AlignmentU> &Two) {
    return !((AllocKind == AllocKindU) && (One.MContext == Two.MContext) &&
             (One.MDevice == Two.MDevice));
  }

private:
  constexpr size_t getAlignment() const { return Alignment; }

  template <class U, usm::alloc AllocKindU, size_t AlignmentU>
  friend class usm_allocator;

  const context MContext;
  const device MDevice;
};

}
}
# 12 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/usm.hpp" 2 3




inline namespace cl {
namespace sycl {



__attribute__((visibility("default"))) void *malloc_device(size_t size, const device &dev,
                                  const context &ctxt);
__attribute__((visibility("default"))) void *malloc_device(size_t size, const queue &q);

__attribute__((visibility("default"))) void *aligned_alloc_device(size_t alignment, size_t size,
                                         const device &dev,
                                         const context &ctxt);
__attribute__((visibility("default"))) void *aligned_alloc_device(size_t alignment, size_t size,
                                         const queue &q);

__attribute__((visibility("default"))) void free(void *ptr, const context &ctxt);
__attribute__((visibility("default"))) void free(void *ptr, const queue &q);




__attribute__((visibility("default"))) void *malloc_host(size_t size, const context &ctxt);
__attribute__((visibility("default"))) void *malloc_host(size_t size, const queue &q);

__attribute__((visibility("default"))) void *malloc_shared(size_t size, const device &dev,
                                  const context &ctxt);
__attribute__((visibility("default"))) void *malloc_shared(size_t size, const queue &q);

__attribute__((visibility("default"))) void *aligned_alloc_host(size_t alignment, size_t size,
                                       const context &ctxt);
__attribute__((visibility("default"))) void *aligned_alloc_host(size_t alignment, size_t size,
                                       const queue &q);

__attribute__((visibility("default"))) void *aligned_alloc_shared(size_t alignment, size_t size,
                                         const device &dev,
                                         const context &ctxt);
__attribute__((visibility("default"))) void *aligned_alloc_shared(size_t alignment, size_t size,
                                         const queue &q);




__attribute__((visibility("default"))) void *malloc(size_t size, const device &dev, const context &ctxt,
                           usm::alloc kind);
__attribute__((visibility("default"))) void *malloc(size_t size, const queue &q, usm::alloc kind);

__attribute__((visibility("default"))) void *aligned_alloc(size_t alignment, size_t size,
                                  const device &dev, const context &ctxt,
                                  usm::alloc kind);
__attribute__((visibility("default"))) void *aligned_alloc(size_t alignment, size_t size, const queue &q,
                                  usm::alloc kind);




template <typename T>
T *malloc_device(size_t Count, const device &Dev, const context &Ctxt) {
  return static_cast<T *>(malloc_device(Count * sizeof(T), Dev, Ctxt));
}

template <typename T> T *malloc_device(size_t Count, const queue &Q) {
  return malloc_device<T>(Count, Q.get_device(), Q.get_context());
}

template <typename T>
T *aligned_alloc_device(size_t Alignment, size_t Count, const device &Dev,
                        const context &Ctxt) {
  return static_cast<T *>(
      aligned_alloc_device(Alignment, Count * sizeof(T), Dev, Ctxt));
}

template <typename T>
T *aligned_alloc_device(size_t Alignment, size_t Count, const queue &Q) {
  return aligned_alloc_device<T>(Alignment, Count, Q.get_device(),
                                 Q.get_context());
}

template <typename T> T *malloc_host(size_t Count, const context &Ctxt) {
  return static_cast<T *>(malloc_host(Count * sizeof(T), Ctxt));
}

template <typename T> T *malloc_host(size_t Count, const queue &Q) {
  return malloc_host<T>(Count, Q.get_context());
}

template <typename T>
T *malloc_shared(size_t Count, const device &Dev, const context &Ctxt) {
  return static_cast<T *>(malloc_shared(Count * sizeof(T), Dev, Ctxt));
}

template <typename T> T *malloc_shared(size_t Count, const queue &Q) {
  return malloc_shared<T>(Count, Q.get_device(), Q.get_context());
}

template <typename T>
T *aligned_alloc_host(size_t Alignment, size_t Count, const context &Ctxt) {
  return static_cast<T *>(
      aligned_alloc_host(Alignment, Count * sizeof(T), Ctxt));
}

template <typename T>
T *aligned_alloc_host(size_t Alignment, size_t Count, const queue &Q) {
  return aligned_alloc_host<T>(Alignment, Count, Q.get_context());
}

template <typename T>
T *aligned_alloc_shared(size_t Alignment, size_t Count, const device &Dev,
                        const context &Ctxt) {
  return static_cast<T *>(
      aligned_alloc_shared(Alignment, Count * sizeof(T), Dev, Ctxt));
}

template <typename T>
T *aligned_alloc_shared(size_t Alignment, size_t Count, const queue &Q) {
  return aligned_alloc_shared<T>(Alignment, Count, Q.get_device(),
                                 Q.get_context());
}

template <typename T>
T *malloc(size_t Count, const device &Dev, const context &Ctxt,
          usm::alloc Kind) {
  return static_cast<T *>(malloc(Count * sizeof(T), Dev, Ctxt, Kind));
}

template <typename T> T *malloc(size_t Count, const queue &Q, usm::alloc Kind) {
  return malloc<T>(Count, Q.get_device(), Q.get_context(), Kind);
}

template <typename T>
T *aligned_alloc(size_t Alignment, size_t Count, const device &Dev,
                 const context &Ctxt, usm::alloc Kind) {
  return static_cast<T *>(
      aligned_alloc(Alignment, Count * sizeof(T), Dev, Ctxt, Kind));
}

template <typename T>
T *aligned_alloc(size_t Alignment, size_t Count, const queue &Q,
                 usm::alloc Kind) {
  return aligned_alloc<T>(Alignment, Count, Q.get_device(), Q.get_context(),
                          Kind);
}






__attribute__((visibility("default"))) usm::alloc get_pointer_type(const void *ptr, const context &ctxt);






__attribute__((visibility("default"))) device get_pointer_device(const void *ptr, const context &ctxt);

}
}
# 49 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 1 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl/version.hpp" 1 3
# 50 "/opt/intel/oneapi/compiler/2021.1.1/linux/bin/../include/sycl/CL/sycl.hpp" 2 3
# 2 "GEEM1.cpp" 2
# 1 "/opt/intel/oneapi/dev-utilities/2021.1.1/include/dpc_common.hpp" 1
# 12 "/opt/intel/oneapi/dev-utilities/2021.1.1/include/dpc_common.hpp"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/stdlib.h" 1 3
# 13 "/opt/intel/oneapi/dev-utilities/2021.1.1/include/dpc_common.hpp" 2




namespace dpc_common {

static auto exception_handler = [](cl::sycl::exception_list eList) {
  for (std::exception_ptr const &e : eList) {
    try {
      std::rethrow_exception(e);
    } catch (std::exception const &e) {



      std::terminate();
    }
  }
};





class TimeInterval {
 public:
  TimeInterval() : start_(std::chrono::steady_clock::now()) {}

  double Elapsed() {
    auto now = std::chrono::steady_clock::now();
    return std::chrono::duration_cast<Duration>(now - start_).count();
  }

 private:
  using Duration = std::chrono::duration<double>;
  std::chrono::steady_clock::time_point start_;
};

};
# 3 "GEEM1.cpp" 2

using namespace std;
using namespace sycl;




constexpr int M = 1280;
constexpr int N = 1280;
constexpr int P = 1280;


template <typename T>
static T rand_uniform_01() {
  return T(std::rand()) / T(2147483647);
}


template <typename T>
static std::vector<T> make_random_matrix(int m, int n) {
  std::vector<T> matrix(m * n);
  std::generate_n(matrix.data(), matrix.size(), rand_uniform_01<T>);
  return matrix;
}


int main() {




  std::cout << "make random matrix" << std::endl;
  auto A = make_random_matrix<float>(M, N);
  auto B = make_random_matrix<float>(N, P);
  auto C = std::vector<float>(M * P, 0);




  std::cout << "build buffer for matrix" << std::endl;
  buffer buf_a{A.data(), range<2>{M, N}};
  buffer buf_b{B.data(), range<2>{N, P}};
  buffer buf_c{C.data(), range<2>{M, P}};

  queue q{property::queue::enable_profiling{}};

  cout << "Device: " << q.get_device().get_info<info::device::name>() << "\n";

  std::cout << "submit the task" << std::endl;
  event e = q.submit([&](handler &cgh){
    auto a = buf_a.get_access<access::mode::read>(cgh);
    auto b = buf_b.get_access<access::mode::read>(cgh);
    auto c = buf_c.get_access<access::mode::write>(cgh);
    cgh.parallel_for(range<2>{M, P}, [=](id<2> index){
      size_t row = index[0];
      size_t col = index[1];
      float val = 0.0;
      for (size_t i = 0; i < N ; i++){
        val += a[row][i] * b[i][col];
      }
      c[row][col] = val;
    });
  });
  q.wait();
  double etime = e.get_profiling_info<info::event_profiling::command_end>() -
    e.get_profiling_info<info::event_profiling::command_start>();
  int iteration = M*P;
  double msecPerMatrixMul = etime / iteration;
  double gflops = (2 * M* N) / (msecPerMatrixMul / 1000.f)* P * 1.0e-9f;
  printf("GEMM performance with DPAS : M = %d, P = %d, N = %d, compute time = %.3lf msec, Gflops = %.3lf\n",
                                         M, P, N, msecPerMatrixMul, gflops);


  std::cout << "Done" << std::endl;

  return 0;
}
